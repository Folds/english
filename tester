to append the failures from a test result set to another test result set (copying failures):
  loop.
    get a test result from the test result set's test results.
    if the test result is nil, exit.
    if the test result is not OK,
      create a test result called duplicate given the test result;
      append the duplicate to the other test result set.
  repeat.

to append a test result to a result set:
  append the test result to the result set's test results.
  if the test result is OK, add one to the result set's passed.
  if the test result is not OK, add one to the result set's failed.

to check a test result given a string called actual:
  if the actual is the test result's expectation,
    pass the test result given the actual.
  if the actual is not the test result's expectation,
    fail the test result given the actual.

to create a test result:
  allocate memory for the test result.

to create a test result about a string called context and a string called test name and expecting an expectation:
  create the test result.
  describe the test result given the context and the test name.
  put the expectation in the test result's expectation.

to create a test result called duplicate given a test result:
  create the duplicate.
  put the test result's context in the duplicate's context.
  put the test result's test name in the duplicate's test name.
  put the test result's expectation in the duplicate's expectation.
  put the test result's actual value in the duplicate's actual value.
  put the test result's interpretation in the duplicate's interpretation.

to decide if 3-way-match given an expectation and a string and an interpretation:
  if the expectation is not the string, say no.
  if the expectation is the interpretation, say yes.
  say no.

to decide if a result set is OK:
  if the result set's passed is 0, say no.
  if the result set's failed is 0, say yes.
  say no.

to decide if a test result is OK:
  if the test result's interpretation
    is the test result's expectation, say yes.
  say no.

to decide if the tests failed:
  if the status' all test results' failed is 0, say no.
  say yes.

to decide if the tests passed:
  if the status' all test results is OK, say yes.
  say no.

to describe a test result given a string called context and a string called test name:
  put the context in the test result's context.
  put the test name in the test result's test name.

to destroy a test result set:
  destroy the test result set's test results.

an expectation is a string.

to fail a test result given a string called actual:
  \ assumes that the test result's expectation is already populated.
  put the actual in the test result's actual value.
  put the actual in the test result's interpretation.

to fail a test result given a string called expectation and a string called actual:
  populate the test result given the expectation and the actual and the actual.

to finalize a result set:
  destroy the result set's test results.

to finalize the status:
  finalize the status' all test results.
  finalize the status' failures.
  destroy the status' command.

to initialize a result set:
  put 0 in the result set's passed.
  put 0 in the result set's failed.

to initialize the status:
  create the status' command.
  initialize the status' all test results.
  initialize the status' failures.
  resize the status.
  put the lightest green color into the status' pass color.
  put the lightest red color into the status' fail color.
  untint the status.
  put no in the status' started tests.

an interpretation is a string.

to pass a test result given a string called actual:
  \ assumes that the test result's expectation is already populated.
  put the actual in the test result's actual value.
  put the test result's expectation in the test result's interpretation.

to pass a test result given a string called expectation and a string called actual:
  populate the test result given the expectation and the actual and the expectation.

to populate a test result given a string called expectation
    and a string called actual and a string called interpretation:
  put the expectation in the test result's expectation.
  put the actual in the test result's actual value.
  put the interpretation in the test result's interpretation.   

to put a test result set into another test result set:
  put the test result set's passed
    into the other test result set's passed.
  put the test result set's failed
    into the other test result set's failed.

a quota is a number.

a result set has a number called passed,
  a number called failed,
  a timer,
  and some test results.

to stash a test result given a number:
  put the number in a string called actual.
  stash the test result given the actual.

to stash a test result given a string:
  check the test result given the string.
  append the test result to the status' all test results.

the status has a string
  and a result set called all test results
  and a result set called failures
  and a flag called started tests.

to summarize failure given a number and a quota returning a string:
  summarize given the number and "failed" and the quota returning the string.

to summarize given a number and a string and a quota returning a string called result:
  if the number is less than 1,
    put "No tests " then the string then "." in the result; exit.
  if one should be hidden given the number and the quota,
    put "1 test " then the string then "." in the result; exit.
  if the quota is less than 1,
    put the number then " tests " then the string then "." in the result; exit.
  if the number is 1,
    put "1 test " then the string then ".  It was:" in the result; exit.
  if the quota is 1,
    put the number then " tests " then the string then "."
      then "  The first 1 is:" in the result; exit.
  put the number then " tests " then the string in the result.
  if the number is at most the quota,
    append ":" to the result.
  if the number is more than the quota,
    append ".  The first " then the quota then " were:" to the result.

to summarize given a number and a string returning a string called result:
  if the number is 0,
    put "No tests " then the string then "." into the result; exit.
  if the number is 1,
    put "1 test " then the string then "." into the result; exit.
  put the number then " tests " then the string then "." into the result.

to summarize success given a number and a quota returning a string:
  summarize given the number and "passed" and the quota returning the string.

to summarize a test result returning a string:
  summarize the test result returning the string (description).
  put the test result's expectation in an expectation.
  put the test result's actual value in a string called actual.
  put the test result's interpretation in an interpretation.
  append "  Expected '" then the expectation then "'" to the string.
  \ expectation == actual == interpretation => OK
  if 3-way-match given the expectation and the actual and the interpretation,
    append ", which I got." to the string; exit.
  \ expectation == interpretation != actual => OK
  if the expectation is the interpretation,
    append ", and got '" then the actual then "'"
      then ", which is OK." to the string; exit.
  \ actual == expectation != interpretation => not OK, but should not happen.
  if the actual is the expectation,
    append ", which I got, but it meant '" then the interpretation then "'"
      then ", so the test failed." to the string; cluck; exit.
  \ actual == interpretation != expectation -> not OK.
  if the actual is the interpretation,
    append ", but I got '" then the actual then "'"
      then ", so the test failed." to the string; exit.
  \ all 3 are different.
  append ", but I got '" then the actual then "'" to the string.
  append " which is '" then the interpretation then "'" to the string.
  append ", so the test failed." to the string.

to summarize a test result returning a string (description):
  put "In " then the test result's context
    then ", tried " then the test result's test name then "." in the string.

to summarize a test result set returning a string:
  put the test result set's passed in a number called passed.
  put the test result set's failed in a number called failed.
  put the passed plus the failed in a number called total.
  if the test result set is OK,
    summarize given the passed and "passed" returning the string; exit.
  if the test result set is not OK,
    summarize given the failed and "failed" returning the string;
    append "  Just " then the passed then " / " then the total then " were OK."
      to the string; exit.
  put "The tests have not run yet." into the string.

to test:
  test (all).
  append the failures from the status' all test results
    to the status' failures (copying failures).
  tint the status.

to test (all):
  start the status' all test results' timer.
  test (basic math).
  stop the status' all test results' timer.
  test (the testing time).

to test (the testing time):
  put 10 seconds in a number called maximum.
  put "at most " then the maximum
    then " ms" in a string called expectation.
  create a test result about "the status" and "maximum testing time"
    and expecting the expectation.
  put the status' all test results' timer's string
    then " ms" in a string called actual.
  if the status' all test results' timer's total ticks is at most the maximum,
    pass the test result given the actual.
  if the status' all test results' timer's total ticks is more than the maximum,
    fail the test result given the actual.
  append the test result to the status' all test results.

the test quota is a quota equal to 10.

a test result is a thing with
  a string called context,
  a string called test name,
  an expectation,
  a string called actual value, and
  an interpretation.



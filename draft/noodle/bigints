\ Copyright 2017-2019 by Jasper Paulsen.

\ Intel is "backways" (Little Endian).
\ The further left the byte, the less significant the byte is.
\ But within a byte, the further left the bit,
\ the more significant the bit is.

\ The low number is treated as unsigned.
\ The low number ranges from 0 through biggest number - smallest number,
\ not from smallest number through biggest number.
a bigint has
  a first byte,
  a second byte,
  a third byte,
  a fourth byte,
  a fifth byte,
  a sixth byte,
  a seventh byte,
  an eighth byte,
  a low byte at the first byte,
  a high byte at the eighth byte,
  a first wyrd at the first byte,
  a second wyrd at the third byte,
  a third wyrd at the fifth byte,
  a fourth wyrd at the seventh byte,
  a low wyrd at the first byte,
  a high wyrd at the seventh byte,
  a low number at the first byte, and
  a high number at the fifth byte.

\ a premix can store a mixio as a bigint, measured in trifles.
\ In other words, it is an implied ratio of the bigint / (43,200*43,200).
a premix is a bigint.

\ A binary logarithm represents log base 2 of a value.
\ A binary logarithm is similar to a float,
\ but the mantissa is used differently.
\ Both have some bits and a mantissa.
\
\ A float's mantissa is not logarithmic,
\ but a float's bits are logarithmic.
\ A float with positive bits is evaluated
\ by left shifting its mantissa by the bits.
\ A float with negative bits is evaluated
\ by right shifting its mantissa by the negative of the bits.
\
\ In a binary logarithm,
\ both the bits and the mantissa are logarithmic.
\
\ A binary logarithm is similar to a mixed:
\ The bits are the whole number (which can be negative, zero, or positive).
\ The mantissa is the fractional part (which can be zero or positive).
\ The bits are added to the mantissa to get the full value of the binary logarithm.
\
\ To find the antilog of a binary logarithm,
\ de-sign both the bits and the mantissa,
\ raise 2 to the power of the mantissa,
\ left shift the result by the bits,
\ and if the original logarithm was negative, invert the result.
\
a binary logarithm has some bits and a mantissa.

\ In this library,
\ a mantissa represents a ratio, with an implied denominator of 2^61.
\ Properties of the mantissa of a float during intermediate calculations:
\   Bit #64 (the sign bit) is 0.
\   Bit #63 (the 2^62 place) may be 0 or 1.
\ Properties of the mantissa of a float when normalized as a float:
\   Bit #64 is the sign bit.  It may be 0 or 1:
\     0 means the float is zero or positive.
\     1 means the float is zero or negative.
\   Bit #63 (the 2^62 place) is 0.
\   Either the mantissa is 0, or bit #62 (the 2^61 place) is 1.
\
\ The mantissa of a binary logarithm is never negative.
\ It represents a fractional logarithmic value in base 2.
\ Properties of the mantissa of a binary logarithm during intermediate calculations:
\   Bit #64 (the sign bit) is 0.
\   Bit #63 (the 2^62 place) may be 0 or 1.
\   Bit #62 (the 2^61 place) may be 0 or 1.
\ Properties of the mantissa of a binary logarithm when normalized:
\   Bit #64 (the sign bit) is 0.
\   Bit #63 (the 2^62 place) is 0.
\   Bit #62 (the 2^61 place) is 0.
\
a mantissa is a bigint.

to add a bigint to another bigint:
  privatize the bigint.
  add the bigint's low number to the other bigint's low number and carry a flag.
  add the bigint's high number to the other bigint's high number.
  if the flag is set, add one to the other bigint's high number.

to add a bigint to another bigint and carry a flag:
  privatize the bigint.
  add the bigint's low number to the other bigint's low number and carry another flag.
  add the bigint's high number to the other bigint's high number and carry the flag.
  if the other flag is set, add 1 to the other bigint's high number and carry a third flag.
  if the third flag is set, set the flag.

to add a binary logarithm to another binary logarithm:
  add the binary logarithm's bits to the other binary logarithm's bits.
  add the binary logarithm's mantissa to the other binary logarithm's mantissa.
  normalize the other binary logarithm.

to add a number to a bigint:
  convert the number to another bigint.
  add the other bigint to the bigint.

the antiscale mantissa is a mantissa. \ initialized to ln(2).

to append a bigint to a string:
  convert the bigint to another string.
  append the other string to the string.

to bitwise and a bigint with another bigint:
  bitwise and the bigint's high number with
    the other bigint's high number.
  bitwise and the bigint's low number with
    the other bigint's low number.

to bitwise xor a bigint with another bigint:
  bitwise xor the bigint's high number with
    the other bigint's high number.
  bitwise xor the bigint's low number with
    the other bigint's low number.

to clear a bigint:
  put 0 into the bigint's high number.
  put 0 into the bigint's low number.

to clear a binary logarithm:
  clear the binary logarithm's bits.
  clear the binary logarithm's mantissa.

to convert a bigint to a string:
  if the bigint is the smallest bigint,
    put "-9223372036854775808" in the string; exit.
  clear the string.
  privatize the bigint.
  de-sign the bigint.
  loop.
    divide the bigint by ten giving a quotient bigint and a remainder.
    add 48 to the remainder.
    put the remainder into a byte.
    prepend the byte to the string.
    if the quotient bigint is zero, break.
    put the quotient bigint into the bigint.
  repeat.
  if the original bigint is negative, prepend the dash byte to the string.

to convert a binary logarithm and a tolerance bigint to a string:
  convert the binary logarithm to the string.
  if the tolerance bigint is zero, exit.
  if the string ends with " right shifted 61 bits",
    remove trailing bytes from the string given 22.
  append " ± " then the tolerance bigint to the string.
  append " right shifted 61 bits" to the string.

to convert a binary logarithm to a premix:
  put the binary logarithm's mantissa as a bigint in the premix.
  multiply the premix right shifted 61 bits by the unit premix.
  put the unit premix in another premix.
  multiply the other premix by the binary logarithm's bits.
  add the other premix to the premix.

to convert a binary logarithm to a string:
  if the binary logarithm's bits are not 0,
    format the binary logarithm's bits and "bit" or "bits" into the string;
    set a flag.
  if the binary logarithm's mantissa as a bigint is not zero,
    set another flag.
  if the flag and the other flag are both clear,
    put "0" in the string; exit.
  if the other flag is clear, exit.
  if the flag and the other flag are both set,
    append " and " to the string.
  convert the binary logarithm's mantissa as a bigint to another string.
  append the other string to the string.
  append " right shifted 61 bits" to the string.

to convert some bits and a string into a binary logarithm:
  put the bits in the binary logarithm's bits.
  convert the string into the binary logarithm's mantissa as a bigint.

to convert a mixio to a premix:
  put the unit premix in the premix.
  multiply the premix as a bigint by the mixio's whole number.
  put the trifle root in a bigint.
  multiply the bigint by the mixio's nips.
  add the bigint to the premix as a bigint.
  add the mixio's trifles to the premix as a bigint.

to convert a number to a premix:
  put the unit premix in the premix.
  multiply the premix by the number.

to convert a premix to a mixio:
  divide the premix as a bigint by the unit premix as a bigint
    giving a quotient bigint and a remainder bigint.
  convert the remainder bigint to a number.
  convert the number / the trifle denominator to the mixio.
  convert the quotient bigint to another number.
  add the other number to the mixio.
  normalize the mixio.

to convert a ratio to a binary logarithm:
  convert the ratio to a mixed.
  put the mixed's whole number in the binary logarithm's bits.
  convert the mixed's numerator
    to the binary logarithm's mantissa as a bigint.
  convert the mixed's denominator to another bigint.
  divide the binary logarithm's mantissa as a bigint
    left shifted 61 bits by the other bigint.
  normalize the binary logarithm.

to convert a ratio to a premix:
  convert the ratio to a mixio.
  convert the mixio to the premix.

to convert a string to a bigint:
  put 0 into the bigint.
  slap a substring on the string.
  if the substring is blank, exit.
  if the substring's first's target is any sign, add 1 to the substring's first.
  loop.
    if the substring is blank, break.
    multiply the bigint by ten.
    put the substring's first's target into a number.
    subtract 48 from the number.
    convert the number to another bigint.
    add the other bigint to the bigint.
    add 1 to the substring's first.
  repeat.
  if the string's first's target is the dash byte, negate the bigint.

to de-sign a bigint:
  if the bigint is the smallest bigint,
    put the largest bigint into the bigint; exit.
  if the bigint is negative, negate the bigint.

to debug a bigint:
  convert the bigint to a string.
  debug the string.

to decide if a bigint is another bigint:
  if the bigint's low number is not
    the other bigint's low number, say no.
  if the bigint's high number is
    the other bigint's high number, say yes.
  say no.

to decide if a bigint is another bigint or less;
to decide if a bigint is at most another bigint;
to decide if a bigint is less than or equal to another bigint:
  if the bigint is the other bigint, say yes.
  if the bigint is less than the other bigint, say yes.
  say no.

to decide if a bigint is another bigint or more;
to decide if a bigint is at least another bigint;
to decide if a bigint is greater than or equal to another bigint:
  if the bigint is the other bigint, say yes.
  if the bigint is greater than the other bigint, say yes.
  say no.

to decide if a bigint is bitwise included in another bigint:
  if the bigint's low number is not bitwise included
    in the other bigint's low number, say no.
  if the bigint's high number is bitwise included
    in the other bigint's high number, say yes.
  say no.

to decide if a bigint is less than another bigint:
  if the other bigint is greater than the bigint, say yes.
  say no.

to decide if a bigint is less than a number:
  put the number in another bigint.
  if the bigint is less than the other bigint, say yes.
  say no.

to decide if a bigint is modest:
  if the bigint's high number is positive, say no.
  if the bigint's high number is less than -1, say no.
  clear a flag.
  clear another flag.
  if the bigint is negative, set the flag.
  if the bigint's low number is not negative, set the other flag.
  if the flag and the other flag are both set, say no.
  if the flag is set, say yes.
  if the bigint's low number is negative, say no.
  say yes.

to decide if a bigint is more than another bigint;
to decide if a bigint is greater than another bigint:
  if the bigint's high number is greater than
    the other bigint's high number, say yes.
  if the bigint's high number is less than
    the other bigint's high number, say no.
  \ the low numbers' "negatives" are actually
  \ positives that are bigger than the biggest number.
  clear a flag.
  clear another flag.
  if the bigint's low number is negative, set the flag.
  if the other bigint's low number is negative,
    invert the flag; set the other flag.
  if the flag and the other flag are both set,
    say no.
  if the flag is set, say yes.
  if the bigint's low number is greater than
    the other bigint's low number, say yes.
  say no.

to decide if a bigint is negative:
  if the bigint's high number is negative, say yes.
  say no.

to decide if a bigint is a number:
  convert the number to another bigint.
  if the bigint is the other bigint, say yes.
  say no.

to decide if a bigint is a number or less;
to decide if a bigint is at most a number;
to decide if a bigint is less than or equal to a number:
  convert the number to another bigint.
  if the bigint is the other bigint, say yes.
  if the bigint is less than the other bigint, say yes.
  say no.

to decide if a bigint is positive:
  if the bigint is negative, say no.
  if the bigint is zero, say no.
  say yes.

to decide if a bigint is zero:
  if the bigint's high number is not 0, say no.
  if the bigint's low number is 0, say yes.
  say no.

to decide if some bits are some wanted bits and some other bits are some other wanted bits:
  if the bits are not the wanted bits, say no.
  if the other bits are not the other wanted bits, say no.
  say yes.

to decrement a bigint;
to subtract one from a bigint:
  if the bigint is the smallest bigint,
    put the largest bigint in the bigint; exit.
  if the bigint's low number is the smallest number,
    put the largest number in the bigint's low number; exit.
  if the bigint's low number is 0,
    put the largest number in the bigint's low number;
    subtract 1 from the bigint's high number; exit.
  subtract 1 from the bigint's low number.

the denomlog is a binary logarithm.  \ initialized to log base 2 of (43,200)*(43,200).

to divide a bigint by another bigint:
  divide the bigint by the other bigint
    giving a quotient bigint and a remainder bigint.
  put the quotient bigint in the bigint.

to divide a bigint by another bigint giving some bits and a remainder bigint:
  \ assumes the bigint and the other bigint are both positive.
  \ assumes that the bigint has been right shifted to the other bigint.
  put the bigint's highest bit into the bits.
  put the other bigint's highest bit into some other bits.
  subtract the other bits from the bits.
  privatize the bigint.
  privatize the other bigint.
  left shift the other bigint by the bits.
  subtract the other bigint from the bigint.
  put the bigint in the remainder bigint.

to divide a bigint by another bigint giving a quotient bigint and a remainder bigint:
  privatize the bigint.
  privatize the other bigint.
  clear the quotient bigint.
  clear the remainder bigint.
  if the other bigint is zero,
    put the largest bigint in the quotient bigint; exit.
  \
  if the bigint is modest, set a flag.
  if the other bigint is modest, set another flag.
  if the flag and the other flag are both set, \ both modest
    convert the bigint to a number;
    convert the other bigint to another number;
    divide the number by the other number
      giving a quotient and a remainder;
    convert the quotient to the quotient bigint;
    convert the remainder to the remainder bigint;
    exit.
  invert the other flag.
  if the flag and the other flag are both set, \ modest over immodest
    put the bigint in the remainder bigint; exit.
  \
  clear the flag.
  clear the other flag.
  if the bigint is the smallest bigint, set the flag.
  if the other bigint is the smallest bigint, set the other flag.
  if the flag and the other flag are both set,
    convert 1 to the quotient bigint; exit.
  if the other flag is set,
    put the bigint in the remainder bigint; exit.
  if the flag is set,
    add one to the bigint;
    subtract one from the remainder bigint.
  \ At this point, neither bigint is the smallest bigint,
  \ so de-signing will not change their absolute values.
  if the bigint is negative, set a sign flag.
  if the other bigint is negative, invert the sign flag.
  if the sign flag is set, negate the remainder bigint.
  de-sign the bigint.
  de-sign the other bigint.
  clear the flag.
  if the bigint is less than the other bigint, set the flag.
  if the flag is set,
    add the bigint to the remainder bigint.
  if the flag and the sign flag are both set,
    negate the quotient bigint;
    negate the remainder bigint;
    exit.
  if the flag is set, exit.
\ to-do: convert most of what follows to assembly code.
  put the bigint's highest bit into some bits.
  put the other bigint's highest bit into some other bits.
  subtract the other bits from the bits.
  put 1 into a power bigint.
  shift the power bigint left the bits.
  put the other bigint in a subtractee bigint.
  shift the subtractee bigint left the bits.
  loop.
    if the bigint is at least the subtractee bigint,
      add the power bigint to the quotient bigint;
      subtract the subtractee bigint from the bigint.
    subtract 1 from the bits.
    if the bits are negative, break.
    shift the subtractee bigint right 1 bit. 
    shift the power bigint right 1 bit. 
  repeat.
  add the bigint to the remainder bigint.
  if the sign flag is set,
    negate the quotient bigint;
    negate the remainder bigint.

to divide a bigint by a number:
  convert the number to another bigint.
  divide the bigint by the other bigint.

to divide a bigint by ten giving a quotient bigint and a remainder:
  clear the quotient bigint.
  divide the bigint's high number by 10
    giving the quotient bigint's high number
    and a temp remainder.
  if the temp remainder is at least 5,
    put the smallest number in the quotient bigint's low number;
    subtract 5 from the temp remainder.
  put 429496729 in a number.
  multiply the number by the temp remainder.
  add the number to the quotient bigint's low number.
  put 6 in the number.
  multiply the number by the temp remainder.
  divide the number by 10 giving a bonus number and the remainder.
  add the bonus number to the quotient bigint's low number.
  if the bigint's low number is negative,
    add 429496729 to the quotient bigint's low number;
    add 6 to the remainder.
  divide the bigint's low number by 10
    giving the bonus number and an extra number.
  add the bonus number to the quotient bigint's low number.
  add the extra number to the remainder.
  divide the remainder by 10
    giving the bonus number and the extra number.
  add the bonus number to the quotient bigint's low number.
  put the extra number in the remainder.
  if the remainder is negative,
    add 10 to the remainder;
    subtract 1 from the quotient bigint.

to divide a bigint left shifted some bits by another bigint:
  if the other bigint is zero,
    put the largest bigint in the bigint; exit.
  privatize the bits.
  if the bits are not positive,
    divide the bigint by the other bigint;
    negate the bits;
    right shift the bigint the bits;
    exit.
  if the bits are at least 128,
    put the largest bigint in the bigint; exit.
  privatize the bigint.
  privatize the other bigint.
  clear the original bigint.
  \
  if the bigint is negative, set a sign flag.
  if the other bigint is negative, invert the sign flag.
  if the bigint is the smallest bigint,
    divide the bigint by 2;
    add 1 to the bits.
  if the other bigint is the smallest bigint,
    divide the other bigint by 2;
    subtract 1 from the bits.
  \ At this point, neither bigint is the smallest bigint,
  \ so de-signing will not change their absolute values.
  de-sign the bigint.
  de-sign the other bigint.
\ to-do: convert most of what follows to assembly code.
  put the bigint's highest bit into some temp bits.
  subtract 63 from the temp bits.
  negate the temp bits.
  shift the bigint left the temp bits.
  subtract the temp bits from the bits.
  put the other bigint's highest bit into the temp bits.
  subtract 63 from the temp bits.
  negate the temp bits.
  shift the other bigint left the temp bits.
  add the temp bits to the bits.
  put 1 into a power bigint.
  shift the power bigint left the bits.
  loop.
    if the bigint is at least the other bigint,
      add the power bigint to the original bigint;
      subtract the other bigint from the bigint.
    subtract 1 from the bits.
    if the bits are negative, break.
    shift the other bigint right 1 bit.
    shift the power bigint right 1 bit.
  repeat.
  if the sign flag is set,
    negate the original bigint.

to divide a binary logarithm by a number:
  privatize the number.
  divide the binary logarithm's bits by the number
    giving a quotient and a remainder.
  put the quotient in the binary logarithm's bits.
  divide the binary logarithm's mantissa as a bigint by the number.
  convert the remainder to a bigint.
  convert the number to another bigint.
  divide the bigint left shifted 61 bits by the other bigint.
  add the bigint to the binary logarithm's mantissa as a bigint.
  normalize the binary logarithm.

to divide a mantissa by another mantissa:
  divide the mantissa as a bigint left shifted 61 bits
    by the other mantissa as a bigint.

to finalize bigints:

to half natural logify an arg mantissa giving a mantissa:
  put the arg mantissa into a numerator mantissa.
  subtract the unit mantissa from the numerator mantissa.
  put the arg mantissa into a denominator mantissa.
  add the unit mantissa to the denominator mantissa.
  put the numerator mantissa into a first mantissa.
  divide the first mantissa by the denominator mantissa.
  \ the first mantissa is in the range 0 < mantissa < 2^61 / 184.66…
  put the first mantissa in the mantissa.
  \
  put the first mantissa in a factor mantissa.
  multiply the factor mantissa by the first mantissa.
  put the first mantissa in a third mantissa.
  multiply the third mantissa by the factor mantissa.
  \ the third mantissa is in the range 0 < mantissa < 2^61 / 6,297,472.…
  if the third mantissa is less than 2, exit.
  put the third mantissa in a temp mantissa.
  divide the temp mantissa as a bigint by 3.
  add the temp mantissa to the mantissa.
  \
  put the factor mantissa in a square mantissa.
  multiply the square mantissa by the factor mantissa.
  put the first mantissa in a fifth mantissa.
  multiply the fifth mantissa by the square mantissa.
  \ the fifth mantissa is in the range 0 < mantissa < 2^61 / 214,755,239.…
  if the fifth mantissa as a bigint is less than 3, exit.
  put the fifth mantissa in the temp mantissa.
  divide the temp mantissa as a bigint by 5.
  add the temp mantissa to the mantissa.
  \
  put the third mantissa in a seventh mantissa.
  multiply the seventh mantissa by the square mantissa.
  \ the seventh mantissa is in the range 0 < mantissa < 2^61 / 7,323,543,679,278.…
  if the seventh mantissa as a bigint is less than 4, exit.
  put the seventh mantissa in the temp mantissa.
  divide the temp mantissa as a bigint by 7.
  add the temp mantissa to the mantissa.
  \ the ninth mantissa will be less than 5.

to half natural logify a bigint giving a mantissa:
  \ assumes that the bigint has already been prepared.
  \ assumes that the bigint is already less than the threshold bigint.
  clear the mantissa.
  if the bigint is zero, exit.
  \ the bigint now satisfies the invariants of a mantissa
  \ of a binary logarithm during intermediate calculations.
  put the bigint into an arg mantissa as a bigint.
  if the arg mantissa is the unit mantissa,
    clear the mantissa; exit.
  half natural logify the arg mantissa giving the mantissa.

the halfmax bigint is a bigint. \ initialized to 2^62 

to increment a bigint;
to add one to a bigint:
  if the bigint is the largest bigint,
    put the smallest bigint in the bigint; exit.
  if the bigint's low number is the largest number,
    put the smallest number in the bigint's low number; exit.
  if the bigint's low number is -1,
    clear the bigint's low number;
    add one to the bigint's high number; exit.
  add one to the bigint's low number.

to initialize bigints:
  clear the smallest bigint.
  put the smallest number in the smallest bigint's high number.
  clear the largest bigint.
  put the largest number in the largest bigint's high number.
  put -1 in the largest bigint's low number.
  convert the trifle denominator to the unit premix as a bigint.
  \ Set 2^61
  clear the unit mantissa.
  put 1 in the unit mantissa's high number.
  left shift the unit mantissa's high number 29 bits.
\  debug the unit mantissa as a bigint.
\ 2305843009213693952
  \ Set 2^62
  put the unit mantissa as a bigint in the halfmax bigint.
  left shift the halfmax bigint 1 bit.
  \ Set 2^61.5 = 3260954456333195553
  put 759250124 in the threshold mantissa's high number.
  put -25716447 in the threshold mantissa's low number.
  \ Set 2^61 * 2 / ln 2 = 6653256548922161246
  put  1549082004 in the rescale mantissa's high number.
  put -1374947234 in the rescale mantissa's low number.
  \ Set 2^61 / ln 2 = 3326628274461080623
  put the rescale mantissa in the rebase mantissa.
  right shift the rebase mantissa as a bigint by 1 bit.
  \ Set 2^61 * (ln 2) / 2 = 799144290325165979
  put  186065279 in the offset mantissa's high number.
  put 2099050395 in the offset mantissa's low number.
  \ Set 2^61 * (ln 2) = 1598288580650331958
  put the offset mantissa in the antiscale mantissa.
  left shift the antiscale mantissa as a bigint by 1 bit.
  \ Set log base 2 of (43,200)*(43,200) = 30 bits and 1838880709047483325
  clear the denomlog.
  put 30 in the denomlog's bits.
  put  428147779 in the denomlog's high number.
  put  387447741 in the denomlog's low number.

the largest bigint is a bigint.

to logify a bigint giving a binary logarithm:
  logify the bigint giving the binary logarithm's bits.
  logify the bigint giving the binary logarithm's mantissa.

to logify a bigint giving some bits:
  if the bigint is zero,
    put the smallest number in the bits; exit.
  privatize the bigint.
  de-sign the bigint.
  put the bigint's highest bit into the bits.
  subtract 1 from the bits.

to logify a bigint giving a mantissa:
  privatize the bigint.
  logify the bigint giving the mantissa (high bits).
  half natural logify the bigint giving another mantissa.
  multiply the other mantissa by the rescale mantissa.
  add the other mantissa to the mantissa.

to logify a bigint giving a mantissa (high bits):
  \ this routine reduces the bigint by the portion
  \ it extracts into the mantissa.
  if the bigint is zero, exit.
  prepare the bigint for logification (into a mantissa).
  \ the bigint now satisfies the invariants of a mantissa
  \ of a binary logarithm during intermediate calculations.
  put the bigint into an arg mantissa as a bigint.
  if the arg mantissa is the unit mantissa,
    clear the mantissa; exit.
  logify two bits of the arg mantissa from 61 bits giving another mantissa.
  add the other mantissa to the mantissa.
  logify two bits of the arg mantissa from 59 bits giving the other mantissa.
  add the other mantissa to the mantissa.
  logify two bits of the arg mantissa from 57 bits giving the other mantissa.
  add the other mantissa to the mantissa.
  put the arg mantissa as a bigint in the bigint.

to logify a premix giving a binary logarithm:
  if the premix is zero,
    put the smallest number in the binary logarithm's bits;
    clear the binary logarithm's mantissa;
    exit.
  logify the premix as a bigint giving the binary logarithm.
  subtract the denomlog from the binary logarithm.

to logify two bits of an arg mantissa from some bits giving a mantissa:
  put the bits in some next bits.
  subtract 1 from the next bits.
  unlogify the bits and the next bits giving a temp mantissa.
  if the arg mantissa is at least the temp mantissa,
    put 1 in a place mantissa as a bigint;
    left shift the place mantissa by the next bits;
    put the place mantissa in the mantissa;
    right shift the place mantissa by 1 bit;
    add the place mantissa to the mantissa;
    divide the arg mantissa by the temp mantissa;
    exit.
  unlogify the bits giving the temp mantissa.
  if the arg mantissa is at least the temp mantissa,
    put 1 in the place mantissa;
    left shift the place mantissa by the next bits;
    put the place mantissa in the mantissa;
    divide the arg mantissa by the temp mantissa;
    exit.
  unlogify the next bits giving the temp mantissa.
  if the arg mantissa is at least the temp mantissa,
    put 1 in the place mantissa;
    subtract 1 from the next bits;
    left shift the place mantissa by the next bits;
    put the place mantissa in the mantissa;
    divide the arg mantissa by the temp mantissa;
    exit.
  clear the mantissa.

to multiply a bigint by another bigint:
  if the bigint is zero, exit.
  if the other bigint is 1, exit.
  if the other bigint is zero, clear the bigint; exit.
  if the bigint is 1, put the other bigint in the bigint; exit.
  if the bigint is negative, set a sign flag.
  if the other bigint is negative, invert the sign flag.
  if the bigint is the smallest bigint, set a flag.
  if the other bigint is the smallest bigint, set the flag.
  if the flag and the sign flag are both set,
    put the smallest bigint in the bigint; exit.
  if the flag is set,
    put the largest bigint in the bigint; exit.
  \ At this point, neither bigint is the smallest bigint,
  \ so de-signing will not change their absolute values.
  privatize the other bigint.
  de-sign the bigint.
  de-sign the other bigint.
\ to-do: convert most of what follows to assembly code.
  if the bigint is less than the other bigint,
    swap the bigint with the other bigint.
  put the bigint's highest bit into some bits.
  put the other bigint's highest bit into some other bits.
  clear the flag.
  if the bits plus the other bits are at least 65 bits, set the flag.
  if the flag and the sign flag are both set,
    put the smallest bigint in the bigint; exit.
  if the flag is set,
    put the largest bigint in the bigint; exit.
  put the bigint into an addend bigint.
  put 1 into a power bigint.
  clear the bigint.
  loop.
    decrement the other bits.
    if the other bits are 0, break.
    if the power bigint is bitwise included in the other bigint,
      add the addend bigint to the bigint.
    shift the addend bigint left 1 bit.
    shift the power bigint left 1 bit.
  repeat.
  if the power bigint is bitwise included in the other bigint,
    add the addend bigint to the bigint and carry the flag.
  if the flag and the sign flag are both set,
    put the smallest bigint in the bigint; exit.
  if the flag is set,
    put the largest bigint in the bigint; exit.
  if the sign flag is set, negate the bigint.

to multiply a bigint by a number:
  convert the number to another bigint.
  multiply the bigint by the other bigint.

to multiply a bigint by ten:
  multiply the bigint's high number by 10.
  put the bigint's low wyrd in a first number.
  multiply the first number by 10.
  if the first number is negative,
    add 655360 to the first number.
  put the bigint's second wyrd in a second number.
  multiply the second number by 10.  
  if the second number is negative,
    add 655360 to the second number.
  clear the bigint's low number.
  divide the first number by 65536
    giving a first quotient and a first remainder.
  add the first quotient to the second number.
  put the first remainder in the bigint's low wyrd.
  divide the second number by 65536
    giving a second quotient and a second remainder.
  add the second quotient to the bigint's high number.
  put the second remainder in the bigint's second wyrd.

to multiply a bigint right shifted some bits by another bigint:
  if the bigint is zero, exit.
  if the other bigint is zero, clear the bigint; exit.
  if the bits are at least 128, clear the bigint; exit.
  privatize the bits.
  if the bits are not positive,
    multiply the bigint by the other bigint;
    negate the bits;
    left shift the bigint the bits;
    exit.
  if the bigint is negative, set a sign flag.
  if the other bigint is negative, invert the sign flag.
  privatize the other bigint.
  if the bigint is the smallest bigint,
    divide the bigint by 2;
    subtract 1 from the bits.
  if the other bigint is the smallest bigint,
    divide the other bigint by 2;
    subtract 1 from the bits.
  \ At this point, neither bigint is the smallest bigint,
  \ so de-signing will not change their absolute values.
  de-sign the bigint.
  de-sign the other bigint.
  put the bigint in a left bigint.
  put the other bigint in a right bigint.
  put the bits in some spare bits.
  prepare the bigint and the other bigint
    for multiplication with right shift by the bits.
  divide the left bigint by the bigint giving some left bits and a left residual bigint.
  divide the right bigint by the other bigint giving some right bits and a right residual bigint.
  multiply the left residual bigint by the other bigint.
  right shift the left residual bigint by the left bits.
  multiply the right residual bigint by the bigint.
  right shift the right residual bigint by the right bits.
  multiply the bigint by the other bigint.
  add the left residual bigint to the bigint.
  add the right residual bigint to the bigint.
  if the bits are positive,
    right shift the bigint by the bits;
    clear the bits.
  if the bits are negative,
    left shift the bigint by the bits;
    clear the bits.
  if the sign flag is set, negate the bigint.

to multiply a binary logarithm by a multiplicand mantissa:
  multiply the binary logarithm's mantissa by the multiplicand mantissa.
  if the binary logarithm's bits are negative,
    set a sign flag.
  convert the binary logarithm's bits to a bitty mantissa as a bigint.  
  if the sign flag is set,
    negate the bitty mantissa.
  put the bitty mantissa's highest bit into some bits.
  put the bits into some other bits.
  subtract 61 from the bits.
  negate the bits.
  \ bits have 61 minus the highest bit of the binary logarithm's bits.
  \ other bits have    the highest bit of the binary logarithm's bits.
  if the bits are positive,
    left shift the bitty mantissa by the bits.
  multiply the bitty mantissa by the multiplicand mantissa.
  \ split into bits and fraction.
  put the bitty mantissa into a third mantissa.
  if the bits are positive,
    right shift the third mantissa by the bits.
  convert the third mantissa to the binary logarithm's bits.
  if the bits are positive,
    left shift the third mantissa by the bits.
  subtract the third mantissa from the bitty mantissa.
  \ the following line might need special cases
  \  -- but only for ridiculously extreme logarithms.
  left shift the bitty mantissa by the other bits.
  if the sign flag is set,
    negate the binary logarithm's bits;
    negate the bitty mantissa.
  add the bitty mantissa to the binary logarithm's mantissa.
  normalize the binary logarithm.

to multiply a mantissa by another mantissa:
  multiply the mantissa as a bigint right shifted 61 bits
    by the other mantissa as a bigint.

to natural unlogify an arg mantissa giving a result mantissa (other bits):
  \ assumes that 0 <= arg mantissa < 2^54 * ln(2).
  put the unit mantissa in the result mantissa.
  if the arg mantissa is not positive, exit.
  add the arg mantissa to the result mantissa.
  \
  put the arg mantissa in a factor mantissa.
  put the factor mantissa in a square mantissa.
  multiply the square mantissa by the factor mantissa.
  put the square mantissa in a temp mantissa.
  right shift the temp mantissa by 1 bit.
  add the temp mantissa to the result mantissa.
  \
  put the square mantissa in a cube mantissa.
  multiply the cube mantissa by the factor mantissa.
  put the cube mantissa in the temp mantissa.
  divide the temp mantissa by 6.
  add the temp mantissa to the result mantissa.
  \
  put the square mantissa in a quad mantissa.
  multiply the quad mantissa by the square mantissa.
  put the quad mantissa in the temp mantissa.
  divide the temp mantissa by 24.
  add the temp mantissa to the result mantissa.
  \
  put the factor mantissa in a fifth mantissa.
  multiply the fifth mantissa by the quad mantissa.
  put the fifth mantissa in the temp mantissa.
  divide the temp mantissa by 120.
  add the temp mantissa to the result mantissa.
  \
  put the factor mantissa in a sixth mantissa.
  multiply the sixth mantissa by the quad mantissa.
  put the sixth mantissa in the temp mantissa.
  divide the temp mantissa by 720.
  add the temp mantissa to the result mantissa.
  \
  put the factor mantissa in a seventh mantissa.
  multiply the seventh mantissa by the quad mantissa.
  put the seventh mantissa in the temp mantissa.
  divide the temp mantissa by 5040.
  add the temp mantissa to the result mantissa.

to negate a bigint:
  put -1 in another bigint.
  bitwise xor the bigint with the other bigint. \ flip all the bits.
  increment the bigint.

to normalize a binary logarithm:
  if the binary logarithm's mantissa as a bigint
    is at least the halfmax bigint,
      subtract the halfmax bigint from the binary logarithm's mantissa as a bigint;
      add 2 to the binary logarithm's bits.
  if the binary logarithm's mantissa is at least the unit mantissa,
      subtract the unit mantissa from the binary logarithm's mantissa;
      add 1 to the binary logarithm's bits.
  if the binary logarithm's mantissa is not negative, exit.
  if the binary logarithm's mantissa as a bigint is the smallest bigint,
    clear the binary logarithm's mantissa;
    subtract 4 from the binary logarithm's bits;
    exit.
  if the binary logarithm's mantissa as a bigint is at most - the halfmax bigint,
    add the halfmax bigint to the binary logarithm's mantissa as a bigint;
    subtract 2 from the binary logarithm's bits.
  if the binary logarithm's mantissa is not negative, exit.
  add the unit mantissa to the binary logarithm's mantissa.
  subtract 1 from the binary logarithm's bits.

the offset mantissa is a mantissa.   \ initialized to (1/2) ln 2

to prepare a bigint and another bigint for multiplication with right shift by some bits:
  \ assumes that both bigints are positive.
  \ assumes that the bits are positive.
  put the bigint's highest bit into some temp bits.
  put the other bigint's highest bit into some other bits.
  put the bits in some later bits.
  add 60 to the later bits.
  subtract the temp bits from the later bits.
  subtract the other bits from the later bits.
  if the later bits are negative,
    clear the later bits.
  subtract the later bits from the bits.
  subtract the other bits from the temp bits.
  if the temp bits are at least the bits,
    right shift the bigint the bits;
    put the later bits in the bits;
    exit.
  if the temp bits are negative, set a flag.
  if - the temp bits are at least the bits, set another flag.
  if the flag and the other flag are both set,
    right shift the other bigint the bits;
    put the later bits in the bits;
    exit.
  add the bits to the temp bits.
  divide the temp bits by 2.
  if the temp bits are positive,
    right shift the bigint by the temp bits.
  if the temp bits are negative,
    left shift the bigint by the temp bits.
  subtract the temp bits from the bits.
  if the bits are positive,
    right shift the other bigint by the bits.
  if the bits are negative,
    left shift the other bigint by the bits.
  put the later bits in the bits.

to prepare a bigint for logification (into a mantissa):
  if the bigint is zero, exit.
  de-sign the bigint.
  put the bigint's highest bit into some bits.
  if the bits are 63,
    right shift the bigint by 1 bit.
  if the bits are less than 62,
    subtract 62 from the bits;
    negate the bits;
    left shift the bigint by the bits.

to put a bigint into another bigint:
  put the bigint's high number into the other bigint's high number.
  put the bigint's low number into the other bigint's low number.

to put a bigint into a number;
to convert a bigint into a number:
  if the bigint is modest, 
    put the bigint's low number in the number; exit.
  if the bigint's high number is negative,
    put the smallest number in the number; exit.
  put the largest number in the number.

to put a bigint's highest bit into some bits:
  put the bigint's high number's highest bit into the bits.
  if the bits are positive, add 32 to the bits; exit.
  put the bigint's low number's highest bit into the bits.

to put a binary logarithm into another binary logarithm:
  put the binary logarithm's bits into the other binary logarithm's bits.
  put the binary logarithm's mantissa into the other binary logarithm's mantissa.  

to put a number into a bigint;
to convert a number to a bigint:
  privatize the number.
  clear the bigint.
  if the number is not negative,
    put the number into the bigint's low number; exit.
  put -1 into the bigint's high number.
  put the number into the bigint's low number.

the rebase mantissa is a mantissa.

the rescale mantissa is a mantissa.  \ initialized to 1 / (2 ln 2).

to shift a bigint left some bits;
to left shift a bigint some bits;
to left shift a bigint by some bits:
  if the bits are at most 0, exit.
  if the bits are at least 32,
    put the bigint's low number in the bigint's high number;
    shift the bigint's high number left the bits minus 32 bits;
    clear the bigint's low number;
    exit.
  shift the bigint's high number left the bits.
  put the bigint's low number in a number.
  put 32 in some other bits.
  subtract the bits from the other bits.
  shift the number right the other bits.
  bitwise or the bigint's high number with the number.
  shift the bigint's low number left the bits.

to shift a bigint right some bits;
to right shift a bigint some bits;
to right shift a bigint by some bits:
  if the bits are at most 0, exit.
  if the bits are at least 32,
    put the bigint's high number in the bigint's low number;
    shift the bigint's low number right the bits minus 32 bits;
    clear the bigint's high number;
    exit.
  shift the bigint's low number right the bits.
  put the bigint's high number in a number.
  put 32 in some other bits.
  subtract the bits from the other bits.
  shift the number left the other bits.
  bitwise or the bigint's low number with the number.
  shift the bigint's high number right the bits.

the smallest bigint is a bigint.

to subtract a bigint from another bigint:
  privatize the bigint.
  negate the bigint.
  add the bigint to the other bigint.
  if the original bigint is the smallest bigint,
    add one to the other bigint.

to subtract a binary logarithm from another binary logarithm:
  subtract the binary logarithm's bits from the other binary logarithm's bits.
  subtract the binary logarithm's mantissa from the other binary logarithm's mantissa.
  if the other binary logarithm's mantissa is negative,
    add the unit mantissa to the other binary logarithm's mantissa;
    subtract 1 from the other binary logarithm's bits.

to subtract a number from a bigint:
  convert the number to another bigint.
  subtract the other bigint from the bigint.

to swap a bigint with another bigint:
  swap the bigint's high number with the other bigint's high number.
  swap the bigint's low number with the other bigint's low number.

to test (bigints - 799/40 as a natural logarithm):
  convert 28 bits and "1885795524376654787" into a binary logarithm.
  make a fuzzy test about "bigints" and "799/40 as a natural logarithm"
    and targeting the binary logarithm with tolerance 60.
  convert 799/40 to another binary logarithm.
  multiply the other binary logarithm by the rebase mantissa.
  stash the fuzzy test given the other binary logarithm.

to test (bigints - add large negative bigints):
  create a test result about "bigints"
    and "add large negative bigints" and expecting "-8010008006004002000".
  convert "-3005004003002001000" to a bigint.
  convert "-5005004003002001000" to another bigint.
  add the other bigint to the bigint.
  stash the test result given the bigint.

to test (bigints - add large positive bigints):
  create a test result about "bigints"
    and "add large positive bigints" and expecting "7010008006004002000".
  convert "6005004003002001000" to a bigint.
  convert "1005004003002001000" to another bigint.
  add the other bigint to the bigint.
  stash the test result given the bigint.

to test (bigints - add small bigints):
  create a test result about "bigints" and "3 plus 7" and expecting "10".
  put 7 in a bigint.
  put 3 in another bigint.
  add the other bigint to the bigint.
  stash the test result given the bigint.

to test (bigints - convert -1 to number):
  create a test result about "bigints" and "convert -1 to number"
    and expecting "-1".
  convert -1 to a bigint.
  convert the bigint to a number.
  stash the test result given the number.

to test (bigints - convert -123456789 to number):
  create a test result about "bigints"
    and "convert -123456789 to number"
    and expecting "-123456789".
  convert -123456789 to a bigint.
  convert the bigint to a number.
  stash the test result given the number.

to test (bigints - convert 0 to number):
  create a test result about "bigints"
    and "convert 0 to number" and expecting "0".
  convert 0 to a bigint.
  convert the bigint to a number.
  stash the test result given the number.

to test (bigints - convert 123456789 to number):
  create a test result about "bigints"
    and "convert 123456789 to number"
    and expecting "123456789".
  convert 123456789 to a bigint.
  convert the bigint to a number.
  stash the test result given the number.

to test (bigints - convert 19/40 to a binary logarithm):
  convert 0 bits and "1095275429376504627" into a binary logarithm.
  make a fuzzy test about "bigints" and "convert 19/40 to a binary logarithm"
    and targeting the binary logarithm with tolerance 1.
  convert 19/40 to another binary logarithm.
  stash the fuzzy test given the other binary logarithm.

to test (bigints - convert 799/40 to a binary logarithm):
  convert 19 bits and "2248196933983351603" into a binary logarithm.
  make a fuzzy test about "bigints" and "convert 799/40 to a binary logarithm"
    and targeting the binary logarithm with tolerance 1.
  convert 799/40 to another binary logarithm.
  stash the fuzzy test given the other binary logarithm.

to test (bigints - convert largest bigint to largest number):
  create a test result about "bigints"
    and "convert largest bigint to largest number"
    and expecting "2147483647".
  convert the largest bigint to a number.
  stash the test result given the number.

to test (bigints - convert smallest bigint to smallest number):
  create a test result about "bigints"
    and "convert smallest bigint to smallest number"
    and expecting "-2147483648".
  convert the smallest bigint to a number.
  stash the test result given the number.

to test (bigints - convert too big to largest number):
  create a test result about "bigints"
    and "convert too big to largest number"
    and expecting "2147483647".
  convert the largest number to a bigint.
  add 1 to the bigint.
  convert the bigint to a number.
  stash the test result given the number.

to test (bigints - convert too small to smallest number):
  create a test result about "bigints"
    and "convert too small to smallest number"
    and expecting "-2147483648".
  convert the smallest number to a bigint.
  subtract 1 from the bigint.
  convert the bigint to a number.
  stash the test result given the number.

to test (bigints - copy bigint):
  create a test result about "the noodle" and "copy bigint"
    and expecting "5".
  put 5 in a bigint.
  put the bigint in another bigint.
  stash the test result given the other bigint.

to test (bigints - divide 5 bit binary logarithm by 5):
  create a test result about "bigints"
    and "divide 5 bit binary logarithm by 5"
    and expecting "1 bit".
  put 5 in a binary logarithm's bits.
  divide the binary logarithm by 5.
  stash the test result given the binary logarithm.

to test (bigints - divide by large number):
  \ numerator       = 2^62 + 2^30
  \ denominator     = 2^30 +    1
  \ expected result = 2^32 - 3 with remainder 3
  create a test result about "bigints"
    and "divide by large number"
    and   expecting "4294967293 with remainder 3".
  convert "4611686019501129728" to a bigint.
  convert "1073741825" to a divisor bigint.
  divide the bigint by the divisor bigint
    giving a quotient bigint and a remainder bigint.
  stash the test result given the quotient bigint
    then " with remainder " then the remainder bigint.

to test (bigints - divide by three):
  \ numerator       = 2^31
  \ denominator     = 3
  create a test result about "bigints"
    and "divide by three"
    and   expecting "715827882 with remainder 2".
  convert the smallest number to a bigint.
  negate the bigint.
  convert 3 to a divisor bigint.
  divide the bigint by the divisor bigint
    giving a quotient bigint and a remainder bigint.
  stash the test result given the quotient bigint
    then " with remainder " then the remainder bigint.

to test (bigints - divide negative by positive):
  create a test result about "bigints" and "divide negative by positive"
    and expecting "-1000".
  convert "-10000000000000" to a bigint.
  convert     "10000000000" to another bigint.
  divide the bigint by the other bigint.
  stash the test result given the bigint.

to test (bigints - divide negatives):
  create a test result about "bigints" and "divide negatives"
    and expecting "12345678901".
  convert "-4267640714596567801" to a bigint.
  convert "-345678901" to another bigint.
  divide the bigint by the other bigint.
  stash the test result given the bigint.

to test (bigints - divide positive by negative):
  create a test result about "bigints" and "divide positive by negative"
    and expecting "-123456".
  convert "42676134430744704" to a bigint.
  convert "-345678901234" to another bigint.
  divide the bigint by the other bigint.
  stash the test result given the bigint.

to test (bigints - divide with shift):
  create a test result about "bigints" and "divide with shift"
    and expecting "161571587009907888".
  convert  "347492122999483937" to a bigint.
  convert "4959178141426871841" to another bigint.
  divide the bigint left shifted 61 bits by the other bigint.
  stash the test result given the bigint.

to test (bigints - half natural logify 2306821983129182773):
  make a fuzzy test about "bigints"
    and "half natural logify 2306821983129182773"
    and targeting "489383078301448" with tolerance 2. 
  convert "2306821983129182773" to a bigint.
  half natural logify the bigint giving a result mantissa.
  stash the fuzzy test given the result mantissa as a bigint.

to test (bigints - half natural logify 2329962779071883937):
  make a fuzzy test about "bigints"
    and "half natural logify 2329962779071883937"
    and targeting "11997246458029270" with tolerance 8. 
  convert "2329962779071883937" to a bigint.
  put the bigint into an arg mantissa as a bigint.
  half natural logify the arg mantissa giving a result mantissa.
  stash the fuzzy test given the result mantissa as a bigint.

to test (bigints - largest bigint):
  create a test result about "bigints" and "largest bigint"
    and expecting "9223372036854775807".
  stash the test result given the largest bigint.

to test (bigints - logify 1/2 unit):
  create a test result about "bigints" and "logify 1/2 unit"
    and expecting "-1 bits". \ -1 bits + 0 * 2^61 [/ 2^61]
  convert 1/2 to a premix.
  logify the premix giving a binary logarithm.
  stash the test result given the binary logarithm.

to test (bigints - logify 1/256 units):
  create a test result about "bigints" and "logify 1/256 units"
    and expecting "-8 bits". \ -8 bits + 0 * 2^61 [/ 2^61]
  convert 1/256 to a premix.
  logify the premix giving a binary logarithm.
  stash the test result given the binary logarithm.

to test (bigints - logify 1/5 unit):
  convert -3 bits and "1563527362148186753" into a binary logarithm.
  make a fuzzy test about "bigints" and "logify 1/5 unit"
    and targeting the binary logarithm with tolerance 20.
  convert 1/5 to a premix.
  logify the premix giving another binary logarithm.
  stash the fuzzy test given the other binary logarithm.

to test (bigints - logify 2 units):
  create a test result about "bigints" and "logify 2 units"
    and expecting "1 bit". \ 1 bit + 0 * 2^61 [/ 2^61]
  convert 2 to a premix.
  logify the premix giving a binary logarithm.
  stash the test result given the binary logarithm.

to test (bigints - logify 256 units):
  create a test result about "bigints" and "logify 256 units"
    and expecting "8 bits". \ 8 bits + 0 * 2^61 [/ 2^61]
  convert 256 to a premix.
  logify the premix giving a binary logarithm.
  stash the test result given the binary logarithm.

to test (bigints - logify 3125 units):
  convert 11 bits and "1405735226113842044" into a binary logarithm.
  make a fuzzy test about "bigints" and "logify 3125 units"
    and targeting the binary logarithm with tolerance 30.
  convert 3125 to a premix.
  logify the premix giving another binary logarithm.
  stash the fuzzy test given the other binary logarithm.

to test (bigints - logify 3732480000 to mantissa):
  make a fuzzy test about "bigints"
    and "logify 3732480000 to mantissa"
    and targeting "1838880709047483316" with tolerance 18.
  convert 2 into a premix.
  logify the premix as a bigint giving a mantissa.
  stash the fuzzy test given the mantissa as a bigint.

to test (bigints - logify square root of 2 units):
  convert 0 bits and "1152921505056615797" into a binary logarithm.
  make a fuzzy test about "bigints"
    and "logify square root of 2 units"
    and targeting the binary logarithm with tolerance 1. \ 0 bits + ~ 0.5 * 2^61 [/ 2^61]
  convert "2639261919" to a bigint.
  put the bigint in a premix as a bigint.
  logify the premix giving another binary logarithm.
  stash the fuzzy test given the other binary logarithm.

to test (bigints - logify unit):
  create a test result about "bigints" and "logify unit"
    and expecting "0".
  logify the unit premix giving a binary logarithm.
  stash the test result given the binary logarithm.

to test (bigints - multiply 0 by ten):
  create a test result about "bigints"
    and "multiply 0 by ten" and expecting "0".
  put 0 in a bigint.
  multiply the bigint by ten.
  stash the test result given the bigint.

to test (bigints - multiply 12 by ten):
  create a test result about "bigints"
    and "multiply 12 by ten" and expecting "120".
  put 12 in a bigint.
  multiply the bigint by ten.
  stash the test result given the bigint.

to test (bigints - multiply 123 by ten):
  create a test result about "bigints"
    and "multiply 123 by ten" and expecting "1230".
  put 123 in a bigint.
  multiply the bigint by ten.
  stash the test result given the bigint.

to test (bigints - multiply 123456789 by ten):
  create a test result about "bigints"
    and "multiply 123456789 by ten" and expecting "1234567890".
  put 123456789 in a bigint.
  multiply the bigint by ten.
  stash the test result given the bigint.

to test (bigints - multiply 1234567890 by ten):
  create a test result about "bigints"
    and "multiply 1234567890 by ten" and expecting "12345678900".
  put 1234567890 in a bigint.
  multiply the bigint by ten.
  stash the test result given the bigint.

to test (bigints - multiply mantissa by itself):
  make a fuzzy test about "bigints" and "multiply mantissa by itself"
    and targeting "11321402898891336" with tolerance 1.
  convert "161571587009907888" to a bigint.
  put the bigint in a mantissa as a bigint.
  put the mantissa in another mantissa.
  multiply the mantissa by the other mantissa.
  stash the fuzzy test given the mantissa as a bigint.

to test (bigints - multiply negative by positive):
  create a test result about "bigints" and "multiply negative by positive"
    and expecting "-4267640714596567801".
  convert "-345678901" to a bigint.
  convert "12345678901" to another bigint.
  multiply the bigint by the other bigint.
  stash the test result given the bigint.

to test (bigints - multiply negatives):
  create a test result about "bigints" and "multiply negatives"
    and expecting "42676134430744704".
  convert "-345678901234" to a bigint.
  multiply the bigint by -123456.
  stash the test result given the bigint.

to test (bigints - multiply positive by negative):
  create a test result about "bigints" and "multiply positive by negative"
    and expecting "-4267640716720024680". \ -(2^61 + ...) Has bit #62 set.
  convert "3456789012" to a bigint.       \  (2^31 + ...) Has bit #32 set.
  multiply the bigint by -1234567890.     \ -(2^30 + ...) Has bit #31 set.
  stash the test result given the bigint.

to test (bigints - multiply positives):
  create a test result about "bigints" and "multiply positives"
    and expecting "42676134430744704".
  convert "345678901234" to a bigint.
  multiply the bigint by 123456.
  stash the test result given the bigint.

to test (bigints - multiply too negative):
  create a test result about "bigints" and "multiply too negative"
    and expecting "-9223372036854775808".
  convert "-9876543210" to a bigint.
  convert "1234567890" to another bigint.
  multiply the bigint by the other bigint.
  stash the test result given the bigint.

to test (bigints - multiply too positive):
  create a test result about "bigints" and "multiply too positive"
    and expecting "9223372036854775807".
  convert "9876543210" to a bigint.
  convert "1234567890" to another bigint.
  multiply the bigint by the other bigint.
  stash the test result given the bigint.

to test (bigints - negate bigint):
  create a test result about "bigints" and "negate 5"
    and expecting "-5".
  put 5 in a bigint.
  negate the bigint.
  stash the test result given the bigint.

to test (bigints - negate negative bigint):
  create a test result about "bigints" and "negate -5"
    and expecting "5".
  put -5 in a bigint.
  negate the bigint.
  stash the test result given the bigint.

to test (bigints - shift left 0 bits):
  create a test result about "bigints"
    and "shift left 0 bits"
    and expecting "4959178141426871841".
  convert "4959178141426871841" to a bigint.
  shift the bigint left 0 bits.
  stash the test result given the bigint.

to test (bigints - shift left 13 bits):
  create a test result about "bigints"
    and "shift left 13 bits"
    and expecting "8796093030400".  \ 2^43 + 2^13
  convert "1073741825" to a bigint. \ 2^30 + 1
  shift the bigint left 13 bits.
  stash the test result given the bigint.

to test (bigints - shift left 32 bits):
  create a test result about "bigints"
    and "shift left 32 bits"
    and expecting "4611686022722355200". \ 2^62 + 2^32
  convert "1073741825" to a bigint.      \ 2^30 + 1
  shift the bigint left 32 bits.
  stash the test result given the bigint.

to test (bigints - shift left 33 bits):
  create a test result about "bigints"
    and "shift left 33 bits"
    and expecting "2969359149424443392".
  convert "345678901" to a bigint.
  shift the bigint left 33 bits.
  stash the test result given the bigint.

to test (bigints - shift right 0 bits):
  create a test result about "bigints"
    and "shift left 0 bits"
    and expecting "4959178141426871841".
  convert "4959178141426871841" to a bigint.
  shift the bigint left 0 bits.
  stash the test result given the bigint.

to test (bigints - shift right 13 bits):
  create a test result about "bigints"
    and "shift right 13 bits" and expecting "1073741825". \ 2^30 + 1
  convert "8796093030400" to a bigint.                    \ 2^43 + 2^13
  shift the bigint right 13 bits.
  stash the test result given the bigint.

to test (bigints - shift right 32 bits):
  create a test result about "bigints"
    and "shift right 32 bits" and expecting "1073741825". \ 2^30 + 1
  convert "4611686022722355200" to a bigint.              \ 2^62 + 2^32
  shift the bigint right 32 bits.
  stash the test result given the bigint.

to test (bigints - shift right 33 bits):
  create a test result about "bigints"
    and "shift right 33 bits"
    and expecting "345678901".
  convert "2969359149424443392" to a bigint.
  shift the bigint right 33 bits.
  stash the test result given the bigint.

to test (bigints - smallest bigint plus one):
  create a test result about "bigints" and "smallest bigint plus one"
    and expecting "-9223372036854775807".
  put the smallest bigint in a bigint.
  increment the bigint.
  stash the test result given the bigint.

to test (bigints - smallest bigint):
  create a test result about "bigints" and "smallest bigint"
    and expecting "-9223372036854775808".
  stash the test result given the smallest bigint.

to test (bigints - stringify 2305843008139952128):
  create a test result about "bigints"
    and "stringify 2305843008139952128"
    and expecting "2305843008139952128".
  convert "2305843008139952128" to a bigint.
  stash the test result given the bigint.

to test (bigints - stringify 7516192768):
  create a test result about "bigints"
    and "stringify 7516192768"
    and expecting "7516192768".
  convert "7516192768" to a bigint.
  stash the test result given the bigint.

to test (bigints - subtract binary logarithms):
  create a test result about "bigints"
    and "subtract binary logarithms"
    and expecting "2017612633174424409 right shifted 61 bits". \ 0 bits + ~ 0.5 * 2^61 [/ 2^61]
  convert "171489801222601287" to a binary logarithm's mantissa as a bigint.
  put 31 in the binary logarithm's bits.
  convert "459720177261870830" to another binary logarithm's mantissa as a bigint.
  put 30 in the other binary logarithm's bits.
  subtract the other binary logarithm from the binary logarithm.
  stash the test result given the binary logarithm.

to test (bigints - subtract large positive bigints):
  create a test result about "bigints"
    and "subtract large positive bigints"
    and expecting "5000000000000000000".
  convert "6005004003002001000" to a bigint.
  convert "1005004003002001000" to another bigint.
  subtract the other bigint from the bigint.
  stash the test result given the bigint.

to test (bigints - subtract positive bigints):
  create a test result about "bigints"
    and "subtract positive bigints"
    and expecting "2305843008139952128".           \ 2^61 - 2^30
  convert "4611686019501129728" to a bigint.       \ 2^62 + 2^30
  convert "2305843011361177600" to another bigint. \ 2^61 + 2^31
  subtract the other bigint from the bigint.
  stash the test result given the bigint.

to test (bigints - subtract small bigints):
  create a test result about "bigints" and "10 minus 3" and expecting "7".
  put 10 in a bigint.
  put 3 in another bigint.
  subtract the other bigint from the bigint.
  stash the test result given the bigint.

to test (bigints - unlogify -8):
  create a test result about "bigints" and "unlogify -8"
    and expecting "7290000".
  put -8 in a binary logarithm's bits.
  unlogify the binary logarithm giving a premix.
  stash the test result given the premix as a bigint.

to test (bigints - unlogify 0):
  create a test result about "bigints" and "unlogify 0"
    and expecting "1866240000".
  clear a binary logarithm.
  unlogify the binary logarithm giving a premix.
  stash the test result given the premix as a bigint.

to test (bigints - unlogify 8):
  create a test result about "bigints" and "unlogify 8"
    and expecting "477757440000".
  put 8 in a binary logarithm's bits.
  unlogify the binary logarithm giving a premix.
  stash the test result given the premix as a bigint.

to test (bigints - unlogify high bit):
  make a fuzzy test about "bigints" and "unlogify high bit"
    and targeting "3260954456333195553" with tolerance 0.
  convert "1152921504606846976" to a mantissa as a bigint.
  unlogify the mantissa giving a result mantissa (high bits).
  stash the fuzzy test given the result mantissa as a bigint.

to test (bigints - unlogify mantissa of 1152921504606846976):
  make a fuzzy test about "bigints"
    and "unlogify mantissa of 1152921504606846976"
    and targeting "3260954456333195553" with tolerance 0.
  convert "1152921504606846976" to a mantissa as a bigint. \ 102/128 * 2^61
  unlogify the mantissa giving a result mantissa.
  stash the fuzzy test given the result mantissa as a bigint.

to test (bigints - unlogify mantissa of 1837468647967162368):
  make a fuzzy test about "bigints"
    and "unlogify mantissa of 1837468647967162368"
    and targeting "4006019078736290886" with tolerance 0.
  convert "1837468647967162368" to a mantissa as a bigint. \ 102/128 * 2^61
  unlogify the mantissa giving a result mantissa.
  stash the fuzzy test given the result mantissa as a bigint.

to test (bigints - unlogify mantissa of 1838880709047483326):
  make a fuzzy test about "bigints"
    and "unlogify mantissa of 1838880709047483326"
    and targeting "4007719883243520012" with tolerance 14.
  convert "1838880709047483326" to a mantissa as a bigint.
  unlogify the mantissa giving a result mantissa.
  stash the fuzzy test given the result mantissa as a bigint.

to test (bigints - unstringify -8765432109876543210):
  create a test result about "bigints"
    and "unstringify -8765432109876543210"
    and   expecting "-8765432109876543210".
  convert "-8765432109876543210" to a bigint.
  stash the test result given the bigint.

to test (bigints - unstringify largest bigint):
  create a test result about "bigints"
    and "unstringify largest bigint"
    and   expecting "9223372036854775807".
  append the largest bigint to a string.
  convert the string to a bigint.
  stash the test result given the bigint.

to test (bigints - unstringify smallest bigint):
  create a test result about "bigints"
    and "unstringify smallest bigint"
    and   expecting "-9223372036854775808".
  convert the smallest bigint in a string.
  convert the string to a bigint.
  stash the test result given the bigint.

to test (bigints - zero):
  create a test result about "bigints" and "zero"
    and expecting "0".
  put 0 in a bigint.
  stash the test result given the bigint.

to test (bigints):
  test (bigints - largest bigint).
  test (bigints - smallest bigint).
  test (bigints - smallest bigint plus one).
  test (bigints - zero).
  test (bigints - copy bigint).
  test (bigints - negate bigint).
  test (bigints - negate negative bigint).
  test (bigints - add small bigints).
  test (bigints - subtract small bigints).
  test (bigints - multiply 0 by ten).
  test (bigints - multiply 12 by ten).
  test (bigints - multiply 123 by ten).
  test (bigints - multiply 123456789 by ten).
  test (bigints - multiply 1234567890 by ten).
  test (bigints - unstringify -8765432109876543210).
  test (bigints - unstringify largest bigint).
  test (bigints - unstringify smallest bigint).
  test (bigints - add large positive bigints).
  test (bigints - subtract large positive bigints).
  test (bigints - stringify 7516192768).
  test (bigints - stringify 2305843008139952128).
  test (bigints - subtract positive bigints).
  test (bigints - add large negative bigints).
  test (bigints - convert largest bigint to largest number).
  test (bigints - convert too big to largest number).
  test (bigints - convert 123456789 to number).
  test (bigints - convert 0 to number).
  test (bigints - convert -1 to number).
  test (bigints - convert -123456789 to number).
  test (bigints - convert too small to smallest number).
  test (bigints - convert smallest bigint to smallest number).
  test (bigints - shift left 0 bits).
  test (bigints - shift left 13 bits).
  test (bigints - shift left 32 bits).
  test (bigints - shift left 33 bits).
  test (bigints - shift right 0 bits).
  test (bigints - shift right 13 bits).
  test (bigints - shift right 32 bits).
  test (bigints - shift right 33 bits).
  test (bigints - multiply too negative).
  test (bigints - multiply too positive).
  test (bigints - multiply positives).
  test (bigints - multiply negatives).
  test (bigints - multiply positive by negative).
  test (bigints - multiply negative by positive).
  test (bigints - multiply mantissa by itself).
  test (bigints - divide by large number).
  test (bigints - divide by three).
  test (bigints - divide negatives).
  test (bigints - divide positive by negative).
  test (bigints - divide negative by positive).
  test (bigints - divide with shift).
  test (bigints - divide 5 bit binary logarithm by 5).
  test (bigints - convert 19/40 to a binary logarithm).
  test (bigints - convert 799/40 to a binary logarithm).
  test (bigints - 799/40 as a natural logarithm).
  test (logify).
  test (unlogify).

to test (logify):
  test (bigints - logify unit).
  test (bigints - half natural logify 2329962779071883937).
  test (bigints - half natural logify 2306821983129182773).
  test (bigints - logify 3732480000 to mantissa).
  test (bigints - logify 2 units).
  test (bigints - subtract binary logarithms).
  test (bigints - logify square root of 2 units).
  test (bigints - logify 1/2 unit).
  test (bigints - logify 256 units).
  test (bigints - logify 1/256 units).
  test (bigints - logify 3125 units).
  test (bigints - logify 1/5 unit).

to test (unlogify):
  test (bigints - unlogify high bit).
  test (bigints - unlogify mantissa of 1152921504606846976).
  test (bigints - unlogify mantissa of 1837468647967162368).
  test (bigints - unlogify mantissa of 1838880709047483326).
  test (bigints - unlogify 0).
  test (bigints - unlogify 8).
  test (bigints - unlogify -8).

the threshold mantissa is a mantissa.

the unit mantissa is a mantissa.  \ initialized to 2^61.

the unit premix is a premix. \ initialized to the trifle denominator.
                             \ (43,200*43,200).

to unlogify an arg mantissa giving a result mantissa:
  \ assumes that 0 <= arg mantissa < 2^61.
  if the arg mantissa as a bigint is not positive,
    put the unit mantissa in the result mantissa;
    exit.
  privatize the arg mantissa.
  unlogify the arg mantissa giving the result mantissa (high bits).
  multiply the arg mantissa by the antiscale mantissa. \ multiply by ln(2).
  natural unlogify the arg mantissa giving a temp mantissa (other bits).
  multiply the result mantissa by the temp mantissa.

to unlogify an arg mantissa giving a result mantissa (high bits):
  \ assumes that 0 <= arg mantissa < 2^61.
  put the unit mantissa in the result mantissa.
  put the unit mantissa's high number in a place number.
  put 62 in some bits. \ 2^61's place.
  loop.
    right shift the place number by 1 bit.
    subtract 1 from the bits.
    if the arg mantissa's high number is at least the place number,
      unlogify the bits [from within the arg mantissa] giving a temp mantissa;
      multiply the result mantissa by the temp mantissa;
      subtract the place number from the arg mantissa's high number.
    if the bits are less than 56, exit. 
  repeat.

to unlogify a binary logarithm giving a premix:
  privatize the binary logarithm.
  add the denomlog to the binary logarithm.
  normalize the binary logarithm.
  if the binary logarithm's bits are at least 63,
    put the largest bigint into the premix as a bigint; exit.
  if the binary logarithm's bits are negative,
    clear the premix; exit.
  \ the mantissa is now in 0 <= mantissa < 2^62.
  unlogify the binary logarithm's mantissa giving a mantissa.
  subtract 61 from the binary logarithm's bits.
  if the binary logarithm's bits are positive,
    left shift the mantissa as a bigint by the binary logarithm's bits;
    put the mantissa as a bigint in the premix as a bigint;
    exit.
  if the binary logarithm's bits are 0,
    put the mantissa as a bigint in the premix as a bigint;
    exit.
  negate the binary logarithm's bits.
  right shift the mantissa as a bigint by the binary logarithm's bits.
  put the mantissa as a bigint in the premix as a bigint.

to unlogify a binary logarithm giving a ratio:
  unlogify the binary logarithm giving a premix.
  convert the premix to a mixio.
  convert the mixio to the ratio.

to unlogify some bits and some other bits [from within a mantissa] giving a mantissa:
  if the bits are 61 and the other bits are 60, \ 2^61.75   ~ 3877950241171266237
    put   902905650 in the mantissa's high number;
    put -1247323459 in the mantissa's low number;
    exit.
  if the bits are 59 and the other bits are 58, \ 2^(61+3/16) ~ 2625867812425724110
    put   611382492 in the mantissa's high number;
    put  -356224818 in the mantissa's low number;
    exit.
  if the bits are 57 and the other bits are 56, \ 2^(61+3/64) ~ 2381993195634921490
    put   554601008 in the mantissa's high number;
    put  -348680174 in the mantissa's low number;
    exit.
  put the unit mantissa in the mantissa. \ 2^61

to unlogify some bits [from within a mantissa] giving a mantissa:
  if the bits are 61, \ 2^61.5      ~ 3260954456333195553 
    put  759250124 in the mantissa's high number;
    put  -25716447 in the mantissa's low number;
    exit.
  if the bits are 60, \ 2^61.25     ~ 2742124912636209756 
    put  638450708 in the mantissa's high number;
    put 1668164188 in the mantissa's low number;
    exit.
  if the bits are 59, \ 2^61.125    ~ 2514539631859660218
    put  585461880 in the mantissa's high number;
    put  -89983558 in the mantissa's low number;
    exit.
  if the bits are 58, \ 2^(61+1/16) ~ 2407931400915394245
    put  560640217 in the mantissa's high number;
    put -216916283 in the mantissa's low number;
    exit.
  if the bits are 57, \ 2^(61+1/32) ~ 2356334396359501942
    put  548626854 in the mantissa's high number;
    put  722135158 in the mantissa's low number;
    exit.
  if the bits are 56, \ 2^(61+1/64) ~ 2330951993331335645
    put  542717052 in the mantissa's high number;
    put -285163043 in the mantissa's low number;
    exit.
  if the bits are 55, \ 2^(61+1/128)~ 2318363508735371995
    put  539786067 in the mantissa's high number;
    put -161060133 in the mantissa's low number;
    exit.
  if the bits are less than 55,
    put the unit mantissa in the mantissa; \ 2^61
    exit.
  if the bits are 62, \ 2^62
    put the halfmax bigint in the mantissa as a bigint.
  put the largest bigint in the mantissa as a bigint. \ 2^63 - 1

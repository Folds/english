\ The portions of this file that are from CAL-3040
\ are copyright 2006 by the Osmosian Order.
\ The portions of this file that are from CAL-4700
\ are copyright 2017 by the Osmosian Order.
\ The remainder is copyright 2014, 2017 by Jasper Paulsen.

\ Texts (and their events, rows, carets, anchors, positions,
\ and selections) are defined and manipulated in 'text'.
\
\ The colors are defined and manipulated in 'colors'.
\ The bytes and the keys are defined and manipulated in 'characters'
\ (but 'characters' does not handle events.)

an abc is a record with
  a number called abca,
  a number called abcb,
  a number called abcc.

an abc pointer is a pointer to an abc.

an abca is a number.

an abcc is a number.

to add a number and another number to a pair:
  add the number to the pair's x.
  add the other number to the pair's y.

to add a number to a pair:
  add the number to the pair's x.
  add the number to the pair's y.

to add a number to a pointer;
to add a number to another number:
  intel $8B8508000000. \ mov eax,[ebp+8] \ the number
  intel $8B00. \ mov eax,[eax]
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the other number
  intel $0103. \ add [ebx],eax

to add a number to a ratio:
  add the number / 1 to the ratio.

to add one to a number:
  put the number plus 1 in the number.

to add a pair to another pair:
  add the pair's x to the other pair's x.
  add the pair's y to the other pair's y.

to add a pdf object given a kind:
  create the pdf object given the kind.
  append the pdf object to the pdf state's objects.
  add 1 to the pdf state's object number.
  put the pdf state's object number into the pdf object's number.

to add a ratio to another ratio:
  privatize the ratio.
  normalize the ratio and the other ratio.
  add the ratio's numerator to the other ratio's numerator.
  reduce the other ratio.

to add a string to some string things:
  create a string thing given the string.
  append the string thing to the string things.

an addrinfo is a record with
  a number called ai_flags,
  a number called ai_family,
  a number called ai_sockettype,
  a number called ai_protocol,
  a number called ai_addrlen,
  a pchar called ai_canonname,
  a sockaddrptr called ai_addr,
  a addrinfoptr called ai_next.

some addrinfo routines is a record with
  a getaddrinfo pointer,
  a freeaddrinfo pointer.

an addrinfoptr is a pointer to an addrinfo.

to adjust a box given a number and another number and a third number and a fourth number:
  add the number to the box's left.
  add the other number to the box's top.
  add the third number to the box's right.
  add the fourth number to the box's bottom.

to adjust an item:
  put the item's win32finddata's dwfileattributes into a number.
  bitwise and the number with 16 [file_attribute_directory].
  if the number is 0, put "file" into the item's kind.
  if the number is not 0, put "directory" into the item's kind.
  put the item's win32finddata's cfilename's whereabouts into a pchar.
  convert the pchar to the item's designator.
  if the item's kind is "directory", append "\" to the item's designator.
  put the item's directory then the item's designator into the item's path.
  extract the item's extension from the item's designator as a path.
  put the item's win32finddata's nfilesizelow into the item's size.
  if the item's designator's first's target is not the period byte, exit.
  get the item (not first time).

to adjust a line with a number and another number and a third number and a fourth number:
  add the number to the line's start's x.
  add the other number to the line's start's y.
  add the third number to the line's end's x.
  add the fourth number to the line's end's y.

to adjust a picture (extract boxes from gpbitmap):
  if the picture is nil, exit.
  put 0 into the picture's box's left.
  put 0 into the picture's box's top.
  put the picture's gpbitmap's width minus 1 times the tpp
    into the picture's box's right.
  put the picture's gpbitmap's height minus 1 times the tpp
    into the picture's box's bottom.
  put the picture's box into the picture's uncropped box.

to adjust spacing given a string:
  if the current canvas is not the printer canvas, exit.
  call "gdi32.dll" "SetTextCharacterExtra" with the printer canvas and 0.
  call "gdi32.dll" "GetCurrentObject" with the printer canvas and 6 [obj_font]
    returning a handle.
  call "gdi32.dll" "SelectObject" with the memory canvas and the handle.
  get a width given the string and the memory canvas.
  call "gdi32.dll" "SelectObject" with the memory canvas and the null hfont.
  get another width given the string and the printer canvas.
  put the width minus the other width divided by the string's length into a number.
  call "gdi32.dll" "SetTextCharacterExtra" with the printer canvas and the number.

an alignment is a string [center, left, or right].

an alleged drive byte is a byte.

an amount is a number.

an and-mask is a mask.

an angle is a number [0 through 3599].

to append a buffer to a file:
  clear the i/o error.
  call "kernel32.dll" "SetFilePointer" with the file
    and 0 and 0 and 2 [file_end] returning a result number.
  if the result number is -1,
    put "Error positioning file pointer." into the i/o error; exit.
  call "kernel32.dll" "WriteFile" with the file
    and the buffer's first and the buffer's length
    and a number's whereabouts and 0 returning the result number.
  if the result number is 0, put "Error writing file." into the i/o error; exit.

to append a byte to a string:
  put the string's length into a saved length.
  reassign the string's first given the string's length plus 1.
  put the string's first plus the saved length into the string's last.
  put the byte into the string's last's target.

to append a byte to a string given a count:
  privatize the count.
  loop.
    if the count is less than 1, exit.
    append the byte to the string.
    subtract 1 from the count.
  repeat.

to append a flag to a string:
  convert the flag to another string.
  append the other string to the string.

to append a number to some number things:
  create a number thing given the number.
  append the number thing to the number things.

to append a number to a string:
  convert the number to another string.
  append the other string to the string.

to append a pointer to a string:
  convert the pointer to another string.
  append the other string to the string.

to append a ratio to a string:
  convert the ratio to another string.
  append the other string to the string.

to append a spot to a polygon:
  if the polygon is nil, exit.
  create a vertex given the spot.
  append the vertex to the polygon's vertices.

to append a string to another string:
  if the string is blank, exit.
  put the string's length into a combined length.
  put the other string's length into a saved length.
  add the saved length to the combined length.
  reassign the other string's first given the combined length.
  put the other string's first plus the saved length into a pointer.
  copy bytes from the string's first to the pointer for the string's length.
  put the other string's first plus the combined length minus 1
    into the other string's last.

to append a string to another string (handling email transparency):
  if the string is blank, exit.
  slap a rider on the string.
  loop.
    move the rider (text file rules).
    if the rider's token is blank, exit.
    if the rider's token starts with ".", append "." to the other string.
    append the rider's token to the other string.
  repeat.

to append a string to another string given a count:
  privatize the count.
  loop.
    if the count is less than 1, exit.
    append the string to the other string.
    subtract 1 from the count.
  repeat.

to append a string to a pdf object: \ this guys adds CRLF
  append the string to the pdf object's data.
  append the crlf string to the pdf object's data.

to append a string to a pdf object without advancing:
  append the string to the pdf object's data.

to append some things to some other things:
  put the things' first into a thing.
  if the thing is nil, exit.
  remove the thing from the things.
  append the thing to the other things.
  repeat.

to append a timer to a string:
  convert the timer to another string.
  append the other string to the string.

to append a vertex to a polygon:
  if the polygon is nil, exit.
  append the vertex to the polygon's vertices.

to append an x coord and a y coord to a polygon:
  if the polygon is nil, exit.
  create a vertex given the x and the y.
  append the vertex to the polygon's vertices.

to append zeros to a string until its length is a number:
  if the string's length is greater than or equal to the number, exit.
  append "0" to the string.
  repeat.

the arrow cursor is a cursor.

to assign a pointer given a byte count:
  if the byte count is 0, void the pointer; exit.
  privatize the byte count.
  round the byte count up to the nearest power of two.
  call "kernel32.dll" "HeapAlloc" with the heap pointer
    and 8 [heap_zero_memory] and the byte count returning the pointer.
  if the pointer is not nil, add 1 to the heap count; exit.

a baseline is a number.

to beep:
  \ MessageBeep() is asynchronous.
  \ The program continues immediately, 
  \ and Windows may or may not beep when it feels like it.
  \ MessageBeep() can be disbled by muting the sound card,
  \ or by muting Windows' sound scheme.
  call "user32.dll" "MessageBeep" with 0.

to begin a landscape sheet:
  make the landscape sheet 11 inches by 8-1/2 inches.
  begin a sheet with the landscape sheet.

to begin a landscape sheet given a title string:
  if the pdf document flag is not set, clear the landscape sheet; exit.
  make the landscape sheet 11 inches by 8-1/2 inches.
  begin the sheet given the box and the title (pdf style).

to begin a portrait sheet:
  make the portrait sheet 8-1/2 inches by 11 inches.
  begin a sheet with the portrait sheet.

to begin a portrait sheet given a title string:
  if the pdf document flag is not set, clear the portrait sheet; exit.
  make the portrait sheet 8-1/2 inches by 11 inches.
  begin the sheet given the box and the title (pdf style).

to begin printing:
  initialize the printer canvas.
  put a docinfo's magnitude into the docinfo's cbsize.
  put the module's name's first into the docinfo's lpszdocname.
  call "gdi32.dll" "StartDocA" with the printer canvas
    and the docinfo's whereabouts.

to begin printing a pdf:
  set the pdf state's document flag.
  put 0 into the pdf state's object number.
  create the pdf state's font index given 113.
  begin printing the pdf (start the root).
  begin printing the pdf (start the parent).

to begin printing a pdf (start the parent):
  add a parent pdf object given "parent".
  put the parent into the pdf state's parent.
  append the parent's number then " 0 obj" to the parent.
  append "<<" to the parent.
  append "/Type /Pages" to the parent.

to begin printing a pdf (start the root):
  add a root pdf object given "root".
  put the root into the pdf state's root.
  append the root's number then " 0 obj" to the root.
  append "<<" to the root.
  append "/Type /Catalog" to the root.

to begin a sheet:
  begin the sheet as a portrait sheet.

to begin a sheet given a box:
  if the pdf state's document flag is set,
    begin the sheet given the box (pdf style); exit.
  call "kernel32.dll" "GlobalLock" with the printer device mode handle
    returning a pdevmode.
  if the pdevmode is nil, exit.
  bitwise or the pdevmode's dmfields with 1 [dm_orientation].
  put 1 [dmorient_portrait] into the pdevmode's dmorientation.
  if the box's width is greater than the box's height,
    put 2 [dmorient_landscape] into the pdevmode's dmorientation.
  call "gdi32.dll" "ResetDCA" with the printer canvas and the pdevmode.
  call "kernel32.dll" "GlobalUnlock" with the printer device mode handle.
  call "gdi32.dll" "SetGraphicsMode"
    with the printer canvas and 2 [gm_advanced].
  call "gdi32.dll" "SetBkMode" with the printer canvas and 1 [transparent].
  call "gdi32.dll" "SetMapMode" with the printer canvas and 8 [mm_anisotropic].
  call "gdi32.dll" "GetDeviceCaps" with the printer canvas
    and 112 [physicaloffsetx] returning a pair's x.
  call "gdi32.dll" "GetDeviceCaps" with the printer canvas
    and 113 [physicaloffsety] returning the pair's y.
  negate the pair.
  call "gdi32.dll" "SetViewportOrgEx" with the printer canvas
    and the pair's x and the pair's y and nil.
  call "gdi32.dll" "GetDeviceCaps" with the printer canvas
    and 88 [logpixelsx] returning the pair's x.
  call "gdi32.dll" "GetDeviceCaps" with the printer canvas
    and 90 [logpixelsy] returning the pair's y.
  call "gdi32.dll" "SetViewportExtEx" with the printer canvas
    and the pair's x and the pair's y and nil.
  call "gdi32.dll" "SetWindowOrgEx" with the printer canvas and 0 and 0 and nil.
  call "gdi32.dll" "SetWindowExtEx" with the printer canvas
    and the tpi and the tpi and nil.
  call "gdi32.dll" "StartPage" with the printer canvas.
  put the printer canvas into the current canvas.
  call "gdi32.dll" "GetDeviceCaps" with the printer canvas
    and 88 [logpixelsx] returning a number.
  put the tpp into the saved tpp.
  put the tpi divided by the number into the tpp.

to begin a sheet given a box (pdf style):
  begin the sheet given the box and "" (pdf style).

to begin a sheet given a box and a title string:
  begin the sheet given the box and the title (pdf style).

to begin a sheet given a box and a title string (pdf style - start the current page):
  add the pdf state's current page given "page".
  append the pdf state's current page's number then " 0 obj" to the pdf state's current page.
  append "<<" to the pdf state's current page. 
  append "/Type /Page" to the pdf state's current page.
  append "/Parent " then the pdf state's parent's number then " 0 R" to the pdf state's current page.
  put the box's width minus the tpp times 72 / the tpi into a width.
  put the box's height minus the tpp times 72 / the tpi into a height.
  append "/MediaBox [0 0 " then the width then " " then the height then "]" to the pdf state's current page.
  put the box's height minus the tpp into the pdf state's current height.
  add the pdf state's current contents given "contents".
  append "/Contents " then the pdf state's current contents' number then " 0 R" to the pdf state's current page.
  append "0.05 0 0 0.05 1 1 cm" to the pdf state's current contents. \ set matrix to scale 72/1440
  append "13 w 0 J 0 j 0 i" to the pdf state's current contents. \ penwidth, linecap, linejoin, flatness \ 15 w on penwidth comes out to wide

to begin a sheet given a box and a title string (pdf style):
  set the pdf state's page flag.
  put the clear color into the pdf state's current border.
  put the clear color into the pdf state's current fill.
  begin the sheet given the box and the title (pdf style - start the current page).
  if the title is blank, exit.
  create a pdf outline entry given the title and the pdf state's current height and the pdf state's current page's number.
  append the pdf outline entry to the pdf state's outline entries.

to begin a sheet given a title string:
  begin a portrait sheet given the title.

a big-endian unsigned wyrd is a record with 2 bytes.

a billion is 1000 millions.

a binary string is a string.

a bit is a unit.

a bitmapdata is a record with
  a width,
  a height,
  a number called stride,
  a number called pixelformat,
  a pointer called scan0,
  a number called reserved.

to bitwise and a number with another number:
  intel $8B850C000000. \ mov eax,[ebp+12] \ the other number
  intel $8B00.         \ mov eax,[eax]
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the number
  intel $2103.         \ and [ebx],eax

to bitwise or a number with another number:
  intel $8B850C000000. \ mov eax,[ebp+12] \ the other number
  intel $8B00.         \ mov eax,[eax]
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the number
  intel $0903.         \ or [ebx],eax

to bitwise xor a byte with another byte:
  intel $8B850C000000. \ mov eax,[ebp+12] \ the other byte
  intel $8A00.         \ mov al,[eax]
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the byte
  intel $3003.         \ xor [ebx],al

to bitwise xor a byte with a number:
  intel $8B850C000000. \ mov eax,[ebp+12] \ the number
  intel $8B00.         \ mov eax,[eax]
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the byte
  intel $3003.         \ or [ebx],al

to bitwise xor a number with another number:
  intel $8B850C000000. \ mov eax,[ebp+12] \ the other number
  intel $8B00.         \ mov eax,[eax]
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the number
  intel $3103.         \ xor [ebx],eax

a box has
  a left coord, a top coord, a right coord, a bottom coord,
  a left-top spot at the left, a right-bottom spot at the right,
  a top-left spot at the left, and a bottom-right spot at the right.

a bucket count is a count.

a bucket is a pointer to a bucket record.

a bucket record has some refers.

a bucket# is a number.

a buffer is a string.

to bump a number:
  add 1 to the number.

to bump a number limiting it to another number and a third number:
  add 1 to the number.
  if the number is greater than the third number,
    put the other number into the number.

to bump a rider:
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the rider
  intel $FF8314000000. \ inc [ebx+20] \ the rider's token's last
  intel $FF8308000000. \ inc [ebx+8] \ the rider's source's first

to bump a rider by a number:
  add the number to the rider's token's last.
  add the number to the rider's source's first. 

to buzz:
  \ Ever since Windows XP, many Windows versions
  \ have not included Beep() in kernel32.dll.
  \ Even before then, many hardware vendors did not support it.
  \ Beep() was synchronous, so the program would wait
  \ until the beep had completed.  Beep() could not be
  \ turned off by simply muting the sound card.
  put "kernel32.dll" in a library.
  put "Beep" in a library procedure.
  if can find the library procedure in the library,
    call "kernel32.dll" "Beep"
      with 220 [hertz] and 200 [milliseconds]; exit.
  \
  play the cluck sound and wait.

to cache the early primes through a number:
  if the cached early primes are empty,
    create a number thing given 2;
    append the number thing to the cached early primes.
  put the cached early primes' last's number in another number.
  loop.
    add 1 to the other number.
    if the other number is more than the number, exit.
    if the other number is prime,
      append the other number to the cached early primes.
  Repeat.

to cache failure finding a library:
  uncache the library.
  put the library then ";*" in a string.
  create a string thing given the string.
  append the string thing to the cached missing library procedures.

to cache failure finding a library procedure in a library:
  uncache the library procedure in the library.
  put the library then ";" then the library procedure in a string.
  create a string thing given the string.
  append the string thing to the cached missing library procedures.

to cache success finding a library procedure in a library:
  uncache the library procedure in the library.
  put the library then ";" then the library procedure in a string.
  create a string thing given the string.
  append the string thing to the cached found library procedures.

the cached early primes are some number things.
\ An ordered, doubly-linked list of prime numbers
\ between 2 and at most 46,337, inclusive.
\ Populated lazily based on whether each item
\ is less than the square root of the largest number
\ for which primality has been tested so far.
\ All primes less than the largest number in the list
\ will also be in the list.
\ Useful for performing the Sieve of Eratosthenes.

the cached found library procedures are some string things.

the cached late primes are some number things.
\ A ordered, doubly-linked list of prime numbers
\ between 46,349 and 2,147,483,647, inclusive.
\ Populated lazily based on whether each item's primality
\ has been tested so far.
\ Useful for caching primality of particular large numbers.

the cached missing library procedures are some string things.

a canvas is an hdc.

to center a box at the bottom of another box:
  center the box in the other box (horizontally).
  put the box's height into a height.
  put the other box's bottom into the box's bottom.
  put the box's bottom minus the height into the box's top.

to center a box in another box (horizontally):
  put the other box's center's x minus the box's center's x into a number.
  round the number to the nearest multiple of the tpp.
  move the box given the number and 0.

to center a box in another box (vertically):
  put the other box's center's y minus the box's center's y into a number.
  round the number to the nearest multiple of the tpp.
  move the box given 0 and the number.

to center an ellipse in a box (horizontally):
  center the ellipse's box in the box (horizontally).

to center an ellipse in a box (vertically):
  center the ellipse's box in the box (vertically).

to center a line in a box (horizontally):
  put the box's center's x minus the line's center's x into a number.
  round the number to the nearest multiple of the tpp.
  move the line given the number and 0.

to center a line in a box (vertically):
  put the box's center's y minus the line's center's y into a number.
  round the number to the nearest multiple of the tpp.
  move the line given 0 and the number.

to center a picture in a box (horizontally):
  if the picture is nil, exit.
  put the box's center's x minus the picture's box's center's x into a number.
  round the number to the nearest multiple of the tpp.
  move the picture given the number and 0.

to center a picture in a box (vertically):
  if the picture is nil, exit.
  put the box's center's y minus the picture's box's center's y into a number.
  round the number to the nearest multiple of the tpp.
  move the picture given 0 and the number.

to center a polygon in a box (horizontally):
  if the polygon is nil, exit.
  put the box's center's x minus the polygon's box's center's x into a number.
  round the number to the nearest multiple of the tpp.
  move the polygon given the number and 0.

to center a polygon in a box (vertically):
  if the polygon is nil, exit.
  put the box's center's y minus the polygon's box's center's y into a number.
  round the number to the nearest multiple of the tpp.
  move the polygon given 0 and the number.

to center a spot in a box (horizontally):
  put the box's center's x minus the spot's x into a number.
  round the number to the nearest multiple of the tpp.
  move the spot given the number and 0.

to center a spot in a box (vertically):
  put the box's center's y minus the spot's y into a number.
  round the number to the nearest multiple of the tpp.
  move the spot given 0 and the number.

to change a roundy box given a radius:
  put the radius into the roundy box's radius.

to clear a box:
  \ writer depends on this routine.
  put 0 into the box's left.
  put 0 into the box's top.
  put 0 into the box's right.
  put 0 into the box's bottom.

to clear an ellipse:
  clear the ellipse's box.

to clear a font:
  put "" and 0 into the font.

to clear an ip address:
  clear the ip address' number.
  clear the ip address' string.

to clear a line:
  clear the line's start.
  clear the line's end.

to clear a number:
  put 0 into the number.

to clear a pair:
  put 0 and 0 into the pair.

to clear a ratio:
  put 0 and 1 into the ratio.

to clear a rider:
  clear the rider's original.
  clear the rider's source.
  clear the rider's token.

to clear a string:
  unassign the string's first.
  void the string's last.

to clear a substring:
  void the substring's first.
  void the substring's last.

to clear some things:
  void the things' first.
  void the things' last.

to clear a wyrd:
  put 0 into the wyrd.

to close a file:
  call "kernel32.dll" "CloseHandle" with the file.

a clsid is a uuid.

to cluck:
  play the cluck sound.

the cluck sound is a wave equal to $524946463A02000057415645666D74201200000001000100401F0000401F000001000800000066616374040000000702000064617461070200007F7F807F7F807F7F808080807F807F7F80817F81817E7E827E7D847C79877D5F6D99B2A25D608269A5979869667F7D8D738C7D8C5E7E878F767A75868D84797278829A7D7E857A73929271657492907D7E7D787E8B887C758388827E817F7C7B89897C7A7E84838183827E7A8488877D7E8181808484817C7F84838181807E7F8283807E8081808182807F7F81818081807F7F8081818080807F7F808180807F80808080807F8080807F8080808080807F7F7F7F7F8080807F7F7F7C7B8182817C7B7D7E8082807D7D7C7F8281807F7C7D808082807E7E7E7D7E807D7B7C7B7D7D7B7A7979797875727269797A490F4571FFF4FF0C001297FBF492525BB0F5B26A001C69BEE5BA76476F9EBD953C3757BAC9BB705C7F9AA883645D7897AA9B806977959588696976999B83766F828C907F7375828E91877B757D868B837A757C858D8880787B8187847B7A7D8788807B79808486817D7C7F8384817D7C7F8484817B7B7D83847F7C7B7E8182827D7C7C8082817D7C7D7F81807F7D7D7F82817F7B7B7E8081807E7D7D7F80807E7D7D7E80807E7D7D7E7F807F7D7D7E7F807F7E7D7E7E80807F7E7D7E80807F7E7E7E7F7F7E7E7E7F7F7F7F7E7E7F7F807F7F7E7E7E7F8080807E7E7E80807F7E7E7F8081807F7F7E7F7F80807F7E7F8081807F7E7E7E80808080807F807F7F7F7F7F7F7F80808080807F7F7F808080807F80808180807F80808100.

a command line is a string.

to compare a string to another string given a length and another length (equal only):
  intel $8BB508000000. \ mov esi,[ebp+8]  \ the string
  intel $8B36.         \ mov esi,[esi]    \ the string's first
  intel $8BBD0C000000. \ mov edi,[ebp+12] \ the other string
  intel $8B3F.         \ mov edi,[edi]    \ the other string's first
  intel $8B8510000000. \ mov eax,[ebp+16] \ the string's length
  intel $8B00.         \ mov eax,[eax]
  intel $8B9514000000. \ mov edx,[ebp+20] \ the other string's length
  intel $8B12.         \ mov edx,[edx]
  intel $3BD0.         \ cmp eax,edx      \ if the length's differ, say no
  intel $0F8548000000. \ jne sayno
  intel $8BC8.         \ mov ecx,eax      \ put length into ecx
  \L3: \ loop:
  intel $85C9.         \ test ecx,ecx
  intel $0F8449000000. \ jz say yes
  \ uppercase current byte in the string
  intel $8A1E.         \ mov bl,[esi]
  intel $80FB61.       \ cmp bl,'a'
  intel $0F820C000000. \ jb L4
  intel $80FB7A.       \ cmp bl,'z'
  intel $0F8703000000. \ ja L4
  intel $80EB20.       \ sub bl,$20
  \L4: \ uppercase current byte in the other string
  intel $8A3F.         \ mov bh,[edi]
  intel $80FF61.       \ cmp bh,'a'
  intel $0F820C000000. \ jb L5
  intel $80FF7A.       \ cmp bh,'z'
  intel $0F8703000000. \ ja L5
  intel $80EF20.       \ sub bh,$20
  \L5: \ compare the two uppercased bytes
  intel $3ADF.         \ cmp bl,bh
  intel $0F8508000000. \ jne say no
  intel $46.           \ inc esi
  intel $47.           \ inc edi
  intel $49.           \ dec ecx
  intel $E9BAFFFFFF.   \ jmp L3
  \SAY NO:
  intel $C7C000000000. \ mov eax,0
  intel $E906000000. \ jmp end
  \SAY YES:
  intel $C7C001000000. \ mov eax,1

to compare a string to another string given a length and another length returning a number:
  intel $8BB508000000. \ mov esi,[ebp+8]  \ the string
  intel $8B36.         \ mov esi,[esi]    \ the string's first
  intel $8BBD0C000000. \ mov edi,[ebp+12] \ the other string
  intel $8B3F.         \ mov edi,[edi]    \ the other string's first
  intel $8B8510000000. \ mov eax,[ebp+16] \ the string's length
  intel $8B00.         \ mov eax,[eax]
  intel $8B9514000000. \ mov edx,[ebp+20] \ the other string's length
  intel $8B12.         \ mov edx,[edx]
  \ get the minimum length
  intel $8BC8.         \ mov ecx,eax
  intel $3BCA.         \ cmp ecx,edx
  intel $0F8602000000. \ jbe L2
  intel $8BCA.         \ mov ecx,edx
  \L3: \ loop:
  intel $85C9.         \ test ecx,ecx
  intel $0F8444000000. \ jz L6
  \ uppercase current byte in the string
  intel $8A1E.         \ mov bl,[esi]
  intel $80FB61.       \ cmp bl,'a'
  intel $0F820C000000. \ jb L4
  intel $80FB7A.       \ cmp bl,'z'
  intel $0F8703000000. \ ja L4
  intel $80EB20.       \ sub bl,$20
  \L4: \ uppercase current byte in the other string
  intel $8A3F.         \ mov bh,[edi]
  intel $80FF61.       \ cmp bh,'a'
  intel $0F820C000000. \ jb L5
  intel $80FF7A.       \ cmp bh,'z'
  intel $0F8703000000. \ ja L5
  intel $80EF20.       \ sub bh,$20
  \L5: \ compare the two uppercased bytes
  intel $3ADF.         \ cmp bl,bh
  intel $0F8508000000. \ jne L5a
  intel $46.           \ inc esi
  intel $47.           \ inc edi
  intel $49.           \ dec ecx
  intel $E9BAFFFFFF.   \ jmp L3
  \L5a: \ load bytes into eax and edx for final compare
  intel $0FB6C3.       \ movzx eax,bl
  intel $0FB6D7.       \ movzx edx,bh
  \L6: \ subtract either the lengths or the last two bytes to set the eax to <0, =0, >0
  intel $2BC2.         \ sub eax,edx
  intel $8B9D18000000. \ mov ebx,[ebp+24] \ the number
  intel $8903.         \ mov [ebx],eax

to compatibly handle any message with a window a message number a w-param and an l-param:
  if the message is 006, handle any wm-activate with the w-param; put 0 into eax; exit.
  if the message is 258, handle any wm-char with the w-param and the l-param; put 0 into eax; exit.
  if the message is 001, handle any wm-create with the window; put 0 into eax; exit.
  if the message is 002, handle any wm-destroy; put 0 into eax; exit.
  if the message is 256, handle any wm-keydown with the w-param and the l-param; put 0 into eax; exit.
  if the message is 513, handle any wm-lbuttondown with the l-param; put 0 into eax; exit.
  if the message is 515, handle any wm-lbuttondblclk with the l-param; put 0 into eax; exit.
  if the message is 015, handle any wm-paint with the window; put 0 into eax; exit.
  if the message is 516, handle any wm-rbuttondown with the l-param; put 0 into eax; exit.
  if the message is 518, handle any wm-rbuttondblclk with the l-param; put 0 into eax; exit.
  if the message is 522, handle any wm-mousewheel  with the w-param; put 0 into eax; exit.
  if the message is 526, handle any wm-mousehwheel with the w-param; put 1 into eax; exit.
  if the message is 032, handle any wm-setcursor; put 1 into eax; exit.
  if the message is 260, handle any wm-syskeydown with the w-param and the l-param; put 0 into eax; exit.
  if the message is 026, handle any wm-settingchange; put 0 into eax; exit.
  call "user32.dll" "DefWindowProcA" with the window and the message and the w-param and the l-param.
\
\The wm- message numbers are listed at:
\http://www.pinvoke.net/default.aspx/Constants.WM

to compatibly wait for a process pointer:
  call "kernel32.dll" "WaitForSingleObject" with the process pointer's target and -1 [infinite].
  call "kernel32.dll" "CloseHandle" with the process pointer's target.
  put 0 into the process pointer's target.
  call "user32.dll" "GetForegroundWindow" returning a window.
  if the window is the main window, put 0 into eax; exit.
  call "user32.dll" "ShowWindow" with the main window and 6 [sw_minimize].
  call "user32.dll" "ShowWindow" with the main window and 9 [sw_restore].
  put 0 into eax. \ set return value of thread

a control font is a font.

to convert a binary string into a number:
  put 0 into the number.
  put 1 into a value number.
  loop.
    if the binary string is blank, exit.
    get a character from the binary string (backwards). \ was backwards
    if the character is "1", add the value to the number.
    double the value.
  repeat.

to convert a box to a string:
  clear the string.
  append the box's left to the string.
  append " " to the string.
  append the box's top to the string.
  append " " to the string.
  append the box's right to the string.
  append " " to the string.
  append the box's bottom to the string.

to convert a byte into a string:
  put 1 into a length.
  reassign the string's first given the length.
  put the byte into the string's first's target.
  put the string's first into the string's last.

to convert a byte into a wyrd:
  intel $8B8508000000. \ mov eax,[ebp+8] \ the byte
  intel $660FB600.     \ movzx eax,byte ptr [eax]
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the wyrd
  intel $668903.       \ mov [ebx],ah

to convert a byte to a nibble:
  put the byte into the nibble as a byte.
  uppercase the nibble.
  if the nibble is greater than the nine byte, subtract 7 from the nibble.
  subtract 48 from the nibble.

to convert a byte to a nibble string:
  split the byte into a nibble and another nibble.
  convert the nibble to the nibble string.
  convert the other nibble to another nibble string.
  append the other nibble string to the nibble string.

to convert a byte to a query byte:
  if the byte is between 48 and  57, convert the byte into the query byte as a string; exit. \ 0-9
  if the byte is between 65 and  90, convert the byte into the query byte as a string; exit. \ A-Z
  if the byte is between 97 and 122, convert the byte into the query byte as a string; exit. \ a-z
  if the byte is 32, put "+" into the query byte; exit. \ space
  convert the byte to a nibble string.
  put "%" then the nibble string into the query byte.

to convert a flag to a hex string:
  reassign the hex string's first given the flag's magnitude.
  copy bytes from the flag's whereabouts to the hex string's first for the flag's magnitude.
  put the hex string's first plus the flag's magnitude minus 1 into the hex string's last.

to convert a flag to a string:
  if the flag is set, put "yes" into the string; exit.
  put "no" into the string.

to convert a font to an hfont:
  privatize the font.
  null terminate the font's name.
  \ Fix-me:
  \ The 3 divided by 4 assumes 96 pixels per inch.
  \ (3 / 4 = 72 points per inch / 96 pixels per inch.)
  call "gdi32.dll" "CreateFontA"
    with - the font's height times 3 divided by 4
    and 0 and 0 and 0 and 0 and 0 and 0 and 0 
    and 1 [default_charset] and 0 and 0
    and 5 [cleartype_quality] and 4 [truetype_fonttype]
    and the font's name's first returning the hfont.

to convert a font info to pdf em units:
  if the font info is nil, exit.
  convert the font info's internal leading to pdf em units given the font info's emsquare and the font info's font.
  convert the font info's ascent to pdf em units given the font info's emsquare and the font info's font.
  convert the font info's descent to pdf em units given the font info's emsquare and the font info's font.
  convert the font info's capheight to pdf em units given the font info's emsquare and the font info's font.
\  convert the font info's italicangle to pdf em units given the font info's emsquare and the font info's font.
  convert the font info's stemv to pdf em units given the font info's emsquare and the font info's font.
  convert the font info's font box's left to pdf em units given the font info's emsquare and the font info's font.
  convert the font info's font box's top to pdf em units given the font info's emsquare and the font info's font.
  convert the font info's font box's right to pdf em units given the font info's emsquare and the font info's font.
  convert the font info's font box's bottom to pdf em units given the font info's emsquare and the font info's font.
  swap the font info's font box's top with the font info's font box's bottom.
  convert the font info's font widths to pdf em units.

to convert some font widths to pdf em units:
  get an outlinetextmetric given the font widths' font.
  put the font widths' data into a number pointer.
  loop.
    if a counter is past the font widths' count, break.
    convert the number pointer's target to pdf em units given the outlinetextmetric's otmemsquare and the font widths' font.
    add a number's magnitude to the number pointer.
  repeat.

to convert a fraction to a ratio;
to convert a ratio to a fraction;
to put a ratio into a fraction;
to put a fraction into a ratio;
to put a fraction into another fraction;
to put a ratio into another ratio:
  put the ratio's numerator into the other ratio's numerator.
  put the ratio's denominator into the other ratio's denominator.

to convert a gpbitmap to a buffer (pdf style):
  clear the buffer.
  if the gpbitmap is nil, exit.
  lock the gpbitmap given a bitmapdata (24-bit rgb).
  put 1 into a row#.
  put 1 into a column#.
  loop.
    if the column# is greater than the bitmapdata's width, put 1 into the column#; add 1 to the row#.
    if the row# is greater than the bitmapdata's height, break.
    get a rgb pointer from the bitmapdata at the row# and the column#.
    append the rgb pointer's red byte to the buffer.
    append the rgb pointer's green byte to the buffer.
    append the rgb pointer's blue byte to the buffer.
    add 1 to the column#.
  repeat.
  unlock the gpbitmap given the bitmapdata.

to convert a hex string to a number:
  if the hex string's length is not the number's magnitude, clear the number; exit.
  copy bytes from the hex string's first to the number's whereabouts for the number's magnitude.

to convert a hex string to a ratio:
  if the hex string's length is not the ratio's magnitude, put 0 and 1 into the ratio; exit.
  copy bytes from the hex string's first to the ratio's whereabouts for the ratio's magnitude.

to convert an l-param to a key: \ assumes l-param from wm_char message
  put the l-param into the key.
  shift the key right 16 bits.
  bitwise and the key with 255.
  call "user32.dll" "MapVirtualKeyA" with the key and 1 returning the key.
  if the numlock key was not toggled, exit.
  if the key is the insert key, put the numpad-zero key into the key; exit.
  if the key is the delete key, put the numpad-period key into the key; exit.
  if the key is the home key, put the numpad-seven key into the key; exit.
  if the key is the end key, put the numpad-one key into the key; exit.
  if the key is the page-up key, put the numpad-nine key into the key; exit.
  if the key is the page-down key, put the numpad-three key into the key; exit.
  if the key is the left-arrow key, put the numpad-four key into the key; exit.
  if the key is the up-arrow key, put the numpad-eight key into the key; exit.
  if the key is the right-arrow key, put the numpad-six key into the key; exit.
  if the key is the down-arrow key, put the numpad-two key into the key; exit.
  if the key is the clear key, put the numpad-five key into the key; exit.

to convert an l-param to a spot:
  split the l-param into a wyrd and another wyrd.
  put the wyrd into the spot's y.
  put the other wyrd into the spot's x.
  multiply the spot by the tpp.

to convert a mixed to a ratio:
  put the mixed's ratio into the ratio.
  add the mixed's whole number times the ratio's denominator to the ratio's numerator.

to convert a nibble to a nibble string:
  privatize the nibble.
  if the nibble is greater than 9, add 7 to the nibble.
  add 48 to the nibble.
  convert the nibble as a byte into the nibble string as a string.

to convert a nibble string to a hex string:
  privatize the nibble string.
  clear the hex string.
  if the nibble string's length is odd, prepend the zero byte to the nibble string.
  slap a substring on the nibble string.
  loop.
    if the substring is blank, exit.
    convert the substring's first's target to a nibble.
    shift the nibble left 4 bits.
    add 1 to the substring's first.
    convert the substring's first's target to another nibble.
    bitwise or the nibble with the other nibble.
    append the nibble to the hex string.
    add 1 to the substring's first.
  repeat.

to convert a number to a byte;
to put a number into a byte:
  intel $8B8508000000. \ mov eax,[ebp+8] \ the number
  intel $8B00.         \ mov eax,[eax]
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the byte
  intel $8803.         \ mov [ebx],al

to convert a number to pdf em units given an emsquare number and a font:
  multiply the number by the emsquare / the font's adjusted height.
  multiply the number by 1000 / the emsquare.

to convert a number to a string:
  clear the string.
  privatize the number.
  de-sign the number.
  loop.
    divide the number by 10 giving a quotient and a remainder.
    add 48 to the remainder.
    put the remainder into a byte.
    prepend the byte to the string.
    if the quotient is 0, break.
    put the quotient into the number.
  repeat.
  if the original number is less than 0, prepend the dash byte to the string.

to convert a pchar to a string:
  clear the string.
  if the pchar is nil, exit.
  privatize the pchar.
  loop.
    if the pchar's target is the null byte, exit.
    append the pchar's target to the string.
    add 1 to the pchar.
  repeat.

to convert a pointer and a length to a string:
  clear the string.
  if the pointer is nil, exit.
  if the length is 0, exit.
  reassign the string's first given the length.
  copy bytes from the pointer to the string's first for the length.
  put the string's first plus the length minus 1 into the string's last.

to convert a pointer to a hex string;
to convert a number to a hex string:
  reassign the hex string's first given the number's magnitude.
  copy bytes from the number's whereabouts to the hex string's first for the number's magnitude.
  put the hex string's first plus the number's magnitude minus 1 into the hex string's last.

to convert a pointer to a nibble string;
to convert a number to a nibble string:
  split the number into a wyrd and another wyrd.
  convert the wyrd to the nibble string.
  convert the other wyrd to another nibble string.
  append the other nibble string to the nibble string.

to convert a pointer to a string:
  convert the pointer to the string as a nibble string.

to convert a query string to a string:
  clear the string.
  if the query string is blank, exit.
  slap a substring on the query string.
  loop.
    if the substring is blank, exit.
    if the substring's first's target is the cross byte,
      append " " to the string; add 1 to the substring's first; repeat.
    if the substring's first's target is not the percent-sign byte,
      append the substring's first's target to the string;
      add 1 to the substring's first; repeat.
    if the substring's length is less than 3, exit.
    add 1 to the substring's first.
    convert the substring's first's target to a nibble.
    shift the nibble left 4 bits.
    add 1 to the substring's first.
    convert the substring's first's target to another nibble.
    bitwise or the nibble with the other nibble.
    add 1 to the substring's first.
    append the nibble to the string.
  repeat.

to convert a ratio to a hex string:
  reassign the hex string's first given the ratio's magnitude.
  copy bytes from the ratio's whereabouts
    to the hex string's first for the ratio's magnitude.
  put the hex string's first plus the ratio's magnitude minus 1
    into the hex string's last.

to convert a ratio to a mixed:
  if the ratio's denominator is 0,
    put 0 into the mixed's whole number; put 0 into the mixed's ratio; exit.
  divide the ratio's numerator by the ratio's denominator
    giving the mixed's whole number and a remainder.
  put the remainder and the ratio's denominator into the mixed's ratio.

to convert a ratio to a string:
  clear the string.
  privatize the ratio.
  if the ratio is negative, put "-" into the string; de-sign the ratio.
  reduce the ratio.
  convert the ratio to a mixed.
  if the mixed is 0, append "0" to the string; exit.
  if the mixed's whole number is not 0,
    append the mixed's whole number to the string.
  if the mixed's ratio is 0, exit.
  if the mixed's whole number is not 0,
    append the dash byte to the string.
  append the mixed's numerator then "/" then the mixed's denominator
    to the string.

to convert a ratio to a string given a number:
  \ converts to a decimal representation with "the number" of places
  clear the string.
  if the number is less than 1, exit.
  put 10 into a value number.
  raise the value to the number.
  privatize the ratio.
  if the ratio is negative, set a flag; de-sign the ratio.
  multiply the value by the ratio.
  zero fill the value given the number and append it to the string.
  put the string's length minus the number plus 1 into a byte#.
  insert "." into the string before the byte#.
  if the string's first's target is the period byte, prepend "0" to the string.
  if the flag is set, prepend "-" to the string.

to convert a string and an actual font info and an original font info into a buffer for pdf output:
  clear the buffer.
  put 0 into a current byte#.
  slap a substring on the first byte of the string.
  loop.
    if the substring's first is greater than the string's last, break.
    if the substring's last is the string's last, break.
    get a current width given the current byte#
      and the actual font info's font widths.
    get an original width given the substring's last's target
      and the original font info's font widths.
    put the original width minus the current width into an offset.
    if the offset is 0,
      add 1 to the substring's last; add 1 to the current byte#; repeat.
    convert the substring to a pdf string.
    append the pdf string then " " then the offset then " " to the buffer.
    put the substring's last plus 1 into the substring's last.
    put the substring's last into the substring's first.
    add 1 to the current byte#.
  repeat.
  if the substring's first is greater than the string's last, exit.
  convert the substring to another pdf string.
  append the other pdf string to the buffer.

to convert a string to a flag:
  if the string is "y", set the flag; exit.
  if the string is "yes", set the flag; exit.
  clear the flag.

to convert a string into a letter:
  put the string's first's target into the letter.

to convert a string to a nibble string:
  clear the nibble string.
  slap a substring on the string.
  loop.
    if the substring is blank, exit.
    convert the substring's first's target to another nibble string.
    append the other nibble string to the nibble string.
    add 1 to the substring's first.
  repeat.

to convert a string to a number:
  put 0 into the number.
  slap a substring on the string.
  if the substring is blank, exit.
  if the substring's first's target is any sign, add 1 to the substring's first.
  loop.
    if the substring is blank, break.
    multiply the number by 10.
    put the substring's first's target into another number.
    subtract 48 from the other number.
    add the other number to the number.
    add 1 to the substring's first.
  repeat.
  if the string's first's target is the dash byte, negate the number.

to convert a string to a number between another number and a third number:
  convert the string to the number.
  limit the number to the other number and the third number.

to convert a string to a pdf string:
  put "(" into the pdf string.
  slap a substring on the string.
  subtract 1 from the substring's first.
  loop.
    add 1 to the substring's first.
    if the substring is blank, break.
    if the substring's first's target is the left-paren byte,
      append "\(" to the pdf string; repeat.
    if the substring's first's target is the right-paren byte,
      append "\)" to the pdf string; repeat.
    if the substring's first's target is the backslash byte,
      append "\\" to the pdf string; repeat.
    append the substring's first's target to the pdf string.
  repeat.
  append ")" to the pdf string.

to convert a string to a pointer: \ assumes pointer is in nibble format
  convert the string as a nibble string to a hex string.
  void the pointer.
  slap a substring on the hex string.
  put 24 into a shift count.
  loop.
    if the substring is blank, exit.
    if the shift count is less than 0, exit.
    put the substring's first's target into a number.
    shift the number left the shift count.
    bitwise or the pointer as a number with the number.
    add 1 to the substring's first.
    subtract 8 from the shift count.
  repeat.

to convert a string to a query string:
  clear the query string.
  slap a substring on the string.
  loop.
    if the substring is blank, break.
    convert the substring's first's target to a query byte.
    append the query byte to the query string.
    add 1 to the substring's first.
  repeat.

to convert a string to a ratio:
  clear the ratio.
  if the string is blank, exit.
  if the string is any integer,
    convert the string to the ratio's numerator; exit.
  slap a substring on the string.
  if the substring's first's target is any sign,
    add 1 to the substring's first.
  if the substring is blank, exit.
  split the substring into an integer substring
    and a ratio substring given the dash byte.
  if the integer substring is blank,
    put the substring into the ratio substring.
  split the ratio substring into a numerator substring
    and a denominator substring given the slash byte.
  convert the integer substring to a whole number.
  convert the numerator substring to a numerator number.
  convert the denominator substring to a denominator number.
  if the whole number is negative, exit.
  if the numerator number is negative, exit.
  if the denominator number is negative, exit.
  if the denominator number is 0, exit.
  if the whole number is not 0,
    add the denominator number times the whole number to the numerator number.
  put the numerator number into the ratio's numerator.
  put the denominator number into the ratio's denominator.
  if the string's first's target is the dash byte, negate the ratio.

to convert a string to a uuid:
  convert the string to a wide string and null terminate.
  call "ole32.dll" "CLSIDFromString"
    with the wide string's first and the uuid's whereabouts.

to convert a string to a wide string:
  clear the wide string.
  slap a substring on the string.
  loop.
    if the substring is blank, exit.
    append the substring's first's target to the wide string.
    append the null byte to the wide string.
    add 1 to the substring's first.
  repeat.

to convert a string to a wide string and null terminate:
  convert the string to the wide string.
  null terminate the wide string.

to convert a timer to a string:
  convert the timer's ticks to the string.

to convert a url to a url record:
  privatize the url.
  null terminate the url.
  put a urlcomponents' magnitude into the urlcomponents' dwstructsize.
  put 1 into the urlcomponents' dwschemelength.
  put 1 into the urlcomponents' dwhostnamelength.
  put 1 into the urlcomponents' dwurlpathlength.
  put 1 into the urlcomponents' dwextrainfolength.
  call "wininet.dll" "InternetCrackUrlA" with the url's first and 0 and 0 and the urlcomponents' whereabouts returning a number.
  convert the urlcomponents' lpszscheme and the urlcomponents' dwschemelength to the url record's scheme.
  convert the urlcomponents' lpszhostname and the urlcomponents' dwhostnamelength to the url record's host name.
  convert the urlcomponents' lpszurlpath and the urlcomponents' dwurlpathlength to the url record's path.
  convert the urlcomponents' lpszextrainfo and the urlcomponents' dwextrainfolength to the url record's extra.
  put the urlcomponents' nport into the url record's port number.

to convert a wyrd to a nibble string:
  split the wyrd into a byte and another byte.
  convert the byte to the nibble string.
  convert the other byte to another nibble string.
  append the other nibble string to the nibble string.

a coord is some twips.

to copy bytes from a pointer to another pointer for a byte count: \ copy handling overlap with 1 byte moves
  intel $8BB508000000. \ mov esi,[ebp+8] \ the pointer
  intel $8B36.         \ mov esi,[esi]
  intel $8BBD0C000000. \ mov edi,[ebp+12] \ the other pointer
  intel $8B3F.         \ mov edi,[edi]
  intel $8B8D10000000. \ mov ecx,[ebp+16] \ the number
  intel $8B09.         \ mov ecx,[ecx]
  \ check for something to copy
  intel $81F900000000. \ cmp ecx,0
  intel $0F8E39000000. \ jle end
  \ check for no overlap
  intel $3BF7.         \ cmp esi,edi
  intel $0F8D24000000. \ jge forward
  intel $8BC6.         \ mov eax,esi
  intel $03C1.         \ add eax,ecx
  intel $3BC7.         \ cmp eax,edi
  intel $0F8E18000000. \ jle forward
  \ copy backward
  intel $03F1.         \ add esi,ecx
  intel $4E.           \ dec esi
  intel $03F9.         \ add edi,ecx
  intel $4F.           \ dec esi
  \ backward
  intel $8A16.         \ mov dl,[esi]
  intel $8817.         \ mov [edi],dl
  intel $4E.           \ dec esi
  intel $4F.           \ dec edi
  intel $49.           \ dec ecx
  intel $0F85F3FFFFFF. \ jnz backward
  intel $E90D000000.   \ jmp end
  \ forward: copy forward
  intel $8A16.         \ mov dl,[esi]
  intel $8817.         \ mov [edi],dl
  intel $46.           \ inc esi
  intel $47.           \ inc edi
  intel $49.           \ dec ecx
  intel $0F85F3FFFFFF. \ jnz forward

to copy an event into another event:
  if the event is nil, void the other event; exit.
  create the other event.
  put the event's kind into the other event's kind.
  put the event's shift flag into the other event's shift flag.
  put the event's ctrl flag into the other event's ctrl flag.
  put the event's alt flag into the other event's alt flag.
  put the event's spot into the other event's spot.
  put the event's key into the other event's key.
  put the event's byte into the other event's byte.

to copy a gpbitmap into another gpbitmap:
  if the gpbitmap is nil, void the other gpbitmap; exit.
  call "gdiplus.dll" "GdipCloneBitmapAreaI" with 0 and 0
    and the gpbitmap's width and the gpbitmap's height
    and 0 [pixelformatdontcare] and the gpbitmap
    and the other gpbitmap's whereabouts.

a copy is a number.

to copy a picture into another picture:
  if the picture is nil, void the other picture; exit.
  allocate memory for the other picture.
  put the picture's box into the other picture's box.
  put the picture's uncropped box into the other picture's uncropped box.
  put the picture's grayscale flag into the other picture's grayscale flag.
  put the picture's mirror flag into the other picture's mirror flag.
  put the picture's rotate angle into the other picture's rotate angle.
  put the picture's data into the other picture's data.
  copy the picture's gpbitmap into the other picture's gpbitmap.

to copy a polygon into another polygon:
  if the polygon is nil, void the other polygon; exit.
  allocate memory for the other polygon.
  copy the polygon's vertices into the other polygon's vertices.

to copy some string things into some string things called duplicates:
  \ to-do:  validate all uses of this routine.
  destroy the duplicates.
  loop.
    get a string thing from the string things.
    if the string thing is nil, exit.
    create a string thing called duplicate.
    put the string thing's string into the duplicate's string.
    append the duplicate to the duplicates.
  repeat.

to copy a vertex into another vertex:
  if the vertex is nil, void the other vertex; exit.
  allocate memory for the other vertex.
  put the vertex's x into the other vertex's x.
  put the vertex's y into the other vertex's y.

to copy some vertices into some other vertices:
  destroy the other vertices.
  loop.
    get a vertex from the vertices.
    if the vertex is nil, exit.
    copy the vertex into another vertex.
    append the other vertex to the other vertices.
  repeat.

to count from a byte pointer to a byte returning a length:
  put 0 in the length.
  if the byte pointer is nil, exit.
  privatize the byte pointer.
  loop.
    put the length plus 1 in the length.
    if the byte pointer's target is the byte, exit.
    put the byte pointer plus 1 in the byte pointer.
  repeat.

a count is a number.

to count some things returning a number:
  put 0 in the number.
  if the things are empty, exit.
  loop.
    get a thing from the things.
    if the thing is nil, exit.
    add 1 to the number.
  repeat.

a counter is an number.

to create the connect handle of a winhttp request using a url record:
  if the winhttp request is nil, exit.
  convert the url record's host name
    into a wide string called wide host name and null terminate.
  call "winhttp.dll" "WinHttpConnect"
    with the winhttp request's session
    and the wide host name's first
    and the url record's port
    and 0
    returning the winhttp request's connection.
  if the winhttp request's connection is 0,
    put "Could not connect." into the i/o error; exit.

to create a crypt session with a passphrase string: \ sets i/o error if failure
  clear the i/o error.
  allocate memory for the crypt session.
  \ acquire context
  call "advapi32.dll" "CryptAcquireContextA"
    with the crypt session's hcryptprov's whereabouts and 0
    and "Microsoft Enhanced Cryptographic Provider v1.0"'s first 
    and 1 [prov_rsa_full] and -268435456 [crypt_verifycontext]
    returning a result number.
  if the result is 0,
    put "Could not acquire context." into the i/o error;
    destroy the crypt session; exit.
  \ create hash
  call "advapi32.dll" "CryptCreateHash"
    with the crypt session's hcryptprov and 32771 [calg_md5] and 0 and 0 
    and the crypt session's hcrypthash's whereabouts
    returning the result number.
  if the result is 0,
    put "Could not create hash." into the i/o error;
    destroy the crypt session; exit.
  \ hash passphrase
  call "advapi32.dll" "CryptHashData" with the crypt session's hcrypthash
    and the passphrase's first and the passphrase's length and 0
    returning the result number.
  if the result is 0,
    put "Could not hash password." into the i/o error;
    destroy the crypt session; exit.
  \ derive session key
  call "advapi32.dll" "CryptDeriveKey" with the crypt session's hcryptprov
    and 26625 [calg_rc4 stream cipher] and the crypt session's hcrypthash 
    and 8388608 [128 bit] and the crypt session's hcryptkey's whereabouts
    returning the result number.
  if the result is 0,
    put "Could not derive session key." into the i/o error;
    destroy the crypt session; exit.

to create a dyad:
  allocate memory for the dyad.

to create an event:
  allocate memory for the event.

to create a font info given a font:
  create the font info given the font (basic data).
  create the font info's font widths given the font.

to create a font info given a font (basic data):
  allocate memory for the font info.
  put the font into the font info's font.
  get an outlinetextmetric given the font.
  put 32 into the font info's flags. \ could be updated with a more information
  put the outlinetextmetric's otmtextmetrics' tminternalleading
    into the font info's internal leading.
  put the outlinetextmetric's otmemsquare into the font info's emsquare.
  put the outlinetextmetric's otmtextmetrics' tmascent into the font info's ascent.
  put - the outlinetextmetric's otmtextmetrics' tmdescent into the font info's descent.
  put the outlinetextmetric's otmscapemheight into the font info's capheight.
  put the outlinetextmetric's otmitalicangle into the font info's italicangle.
  put 0 into the font info's stemv. \ don't know where to get this from
  put the outlinetextmetric's otmrcfontbox into the font info's font box.

to create a font info given a font and a string: \ creates widths based on characters in string
  create the font info given the font (basic data).
  create the font info's font widths given the font and the string.

to create some font widths given a font:
  allocate memory for the font widths.
  put the font into the font widths' font.
  put 256 into the font widths' count.
  assign the font widths' data given the font widths' count times a number's magnitude.
  create the hfont of the memory canvas given the font.
  assign an original abc pointer given 256 times an abc's magnitude.
  call "gdi32.dll" "GetCharABCWidthsA" with the memory canvas
    and 0 and 255 and the original abc pointer.
  destroy the hfont of the memory canvas.
  put the original abc pointer into an abc pointer.
  put the font widths' data into a number pointer.
  loop.
    if a counter is past 256, break.
    put the abc pointer's abca into the number pointer's target.
    add the abc pointer's abcb to the number pointer's target.
    add the abc pointer's abcc to the number pointer's target.
    add the abc's magnitude to the abc pointer.
    add the number's magnitude to the number pointer.
  repeat.
  unassign the original abc pointer.

to create some font widths given a font and a string:
  allocate memory for the font widths.
  put the font into the font widths' font.
  put the string's length into the font widths' count.
  if the string is blank, exit.
  put a gcpresults' magnitude into the gcpresults' lstructsize.
  put the string's length into the gcpresults' nglyphs.
  assign the gcpresults' lpdx given the string's length times a number's magnitude.
  create the hfont of the memory canvas given the font.
  call "gdi32.dll" "GetCharacterPlacementA" with the memory canvas and the string's first
    and the string's length and 0 and the gcpresults' whereabouts and 0.
  destroy the hfont of the memory canvas.
  put the gcpresults' lpdx into the font widths' data.

to create a gpbitmap given a buffer:
  clear the i/o error.
  call "kernel32.dll" "GlobalAlloc" with 2 [gmem_moveable] and the buffer's length returning a handle.
  call "kernel32.dll" "GlobalLock" with the handle returning a pointer.
  copy bytes from the buffer's first to the pointer for the buffer's length.
  call "kernel32.dll" "GlobalUnlock" with the handle.
  call "ole32.dll" "CreateStreamOnHGlobal" with the handle and 1 [true] and an istream's whereabouts.
  call "gdiplus.dll" "GdipCreateBitmapFromStream" with the istream and the gpbitmap's whereabouts returning a number.
  if the number is not 0, put "I don't know how to process this kind of picture." into the i/o error; void the gpbitmap.
  call the istream's vtable's release with the istream.

to create a gpimageattributes (grayscale):
  call "gdiplus.dll" "GdipCreateImageAttributes" with the gpimageattributes' whereabouts.
  call "gdiplus.dll" "GdipSetImageAttributesColorMatrix" with the gpimageattributes and 0 [coloradjusttypedefault] and 1 
    and the grayscale color matrix's first and 0 and 0 [colormatrixflagsdefault].

to create the hbrush of a canvas given a color:
  convert the color to a colorref.
  if the color is clear, put the null hbrush into an hbrush.
  if the color is not clear, call "gdi32.dll" "CreateSolidBrush" with the colorref returning the hbrush.
  call "gdi32.dll" "SelectObject" with the canvas and the hbrush.

to create the hfont of a canvas given a font:
  convert the font to an hfont.
  call "gdi32.dll" "SelectObject" with the canvas and the hfont.

to create the hpen of a canvas given a color:
  convert the color to a colorref.
  if the color is clear, put the null hpen into an hpen.
  \ put the tpp into a number. \ one pixel on screen always
  if the pen size is at most 0, put 1 into the pen size.
  put the tpp times the pen size into a number.
  \ if the canvas is the printer canvas,
  \   put 1/96 inch into the number.
  if the canvas is the printer canvas,
    put 1/96 inch times the pen size into the number.
  if the color is not clear,
    call "gdi32.dll" "CreatePen" with 0 [ps_solid] and the number and the colorref returning the hpen.
  call "gdi32.dll" "SelectObject" with the canvas and the hpen.

to create an hrgn given a box:
  privatize the box.
  add the tpp to the box's right-bottom.
  call "gdi32.dll" "BeginPath" with the current canvas.
  call "gdi32.dll" "Rectangle" with the current canvas and the box's left and the box's top and the box's right and the box's bottom.
  call "gdi32.dll" "EndPath" with the current canvas.
  call "gdi32.dll" "PathToRegion" with the current canvas returning the hrgn.

to create an hrgn given an ellipse:
  put the ellipse's box into a box.
  call "gdi32.dll" "BeginPath" with the current canvas.
  call "gdi32.dll" "Ellipse" with the current canvas and the box's left and the box's top and the box's right and the box's bottom.
  call "gdi32.dll" "EndPath" with the current canvas.
  call "gdi32.dll" "PathToRegion" with the current canvas returning the hrgn.

to create an hrgn given a polygon:
  if the polygon is nil, put 0 into the hrgn; exit.
  create a vertex array given the polygon's vertices.
  call "gdi32.dll" "LPtoDP" with the current canvas and the vertex array's spot pointer and the vertex array's count.
  call "gdi32.dll" "CreatePolygonRgn" with the vertex array's spot pointer and the vertex array's count and 2 [winding] returning the hrgn.
  destroy the vertex array.

to create an hrgn given a roundy box:
  if the roundy box's radius is 0, create the hrgn given the roundy box as a box; exit.
  put the roundy box into a box.
  put the roundy box's radius times 2 into a diameter number.
  call "gdi32.dll" "BeginPath" with the current canvas.
  call "gdi32.dll" "RoundRect" with the current canvas and the box's left and the box's top and the box's right and the box's bottom and the diameter and the diameter.
  call "gdi32.dll" "EndPath" with the current canvas.
  call "gdi32.dll" "PathToRegion" with the current canvas returning the hrgn.

to create an index given a bucket count:
  allocate memory for the index.
  put the bucket count into the index's bucket count.
  put a bucket record's magnitude into a width.
  put the index's bucket count times the width into a number.
  assign the index's first bucket given the number.
  put the index's first bucket plus the number minus the width into the index's last bucket.

to create the lexicon:
  allocate memory for the lexicon.
  create the lexicon's index given 4027.

to create a number thing:
  allocate memory for the number thing.

to create a number thing given a number:
  allocate memory for the number thing.
  put the number into the number thing's number.

to create the open handle of a winhttp request:
  if the winhttp request is nil, exit.
  convert the module's name to a wide string called wide module name and null terminate.
  call "winhttp.dll" "WinHttpOpen"
    with the wide module name's first
    and 0 [winhttp_access_type_default_proxy] 
    and 0 [winhttp_no_proxy_name] 
    and 0 [winhttp_no_proxy_bypass] 
    and 0 
    returning the winhttp request's session.
  if the winhttp request's session is 0, put "Could not open connection." into the i/o error; exit.

to create a path in the file system:
  if the path is directory-format, create the path in the file system (directory); exit.
  if the path is file-format, create the path in the file system (file); exit.

to create a path in the file system (directory):
  privatize the path.
  remove any trailing backslash from the path.
  null terminate the path.
  call "kernel32.dll" "CreateDirectoryA" with the path's first and 0 returning a number.
  clear the i/o error.
  if the number is not 0, exit.
  put "Error creating directory '" then the path then "'." into the i/o error.

to create a path in the file system (file):
  privatize the path.
  null terminate the path.
  call "kernel32.dll" "CreateFileA" with the path's first and 1073741824 [generic_write] and 0 and 0 and 1 [create_new] and 128 [file_attribute_normal] and 0 returning a handle.
  call "kernel32.dll" "CloseHandle" with the handle.
  clear the i/o error.
  if the handle is not -1 [invalid_handle_value], exit.
  put "Error creating file '" then the path then "'." into the i/o error.

to create a pdf object given a kind:
  allocate memory for the pdf object.
  put the kind into the pdf object's kind.

to create a pdf outline entry given a title string and a page height and a destination number:
  allocate memory for the pdf outline entry.
  put the title string into the pdf outline entry's title.
  put the page height into the pdf outline entry's page height.
  put the destination into the pdf outline entry's destination.

to create a picture:
  allocate memory for the picture.

to create a picture given a buffer:
  create a gpbitmap given the buffer.
  if the gpbitmap is nil, void the picture; exit.
  allocate memory for the picture.
  put the buffer into the picture's data.
  put the gpbitmap into the picture's gpbitmap.
  adjust the picture (extract boxes from gpbitmap).

to create a picture given a gpbitmap:
  if the gpbitmap is nil, void the picture; exit.
  allocate memory for the picture.
  put the gpbitmap into the picture's gpbitmap.
  adjust the picture (extract boxes from gpbitmap).

to create a picture given a url:
  read the url into a buffer.
  create the picture given the buffer.

to create a polygon:
  allocate memory for the polygon.

to create a refer:
  allocate memory for the refer.

to create the request handle of a winhttp request using a url record:
  if the winhttp request is nil, exit.
  convert the url record's path into a wide string called wide path and null terminate.
  convert "POST" to a wide string called wide post string and null terminate.
  if the url record's scheme is "https", put 8388608 [winhttp_flag_secure] into a secure number.
  call "winhttp.dll" "WinHttpOpenRequest"
    with the winhttp request's connection
    and the wide post string's first
    and the wide path's first
    and 0 [L"HTTP/1.1"] 
    and 0 [winhttp_no_referer]
    and 0 [winhttp_default_accept_types]
    and the secure number
    returning the winhttp request's request.
  if the winhttp request's request is 0, put "Could not open request." into the i/o error; exit.

to create a socket given a host string and a port number: \ this guy creates and connects, sets i/o error if there is a problem
  clear the i/o error.
  \ get sockaddr
  get a sockaddr given the host.
  if the i/o error is not blank, exit.
  put 2 [af_inet] into the sockaddr's sin_family.
  put the port into the sockaddr's sin_port.
  \ create socket  
  call "ws2_32.dll" "socket" with 2 [af_inet] and 1 [sock_stream] and 0 [ipproto_ip] returning the socket.
  if the socket is -1, put "Could not create socket." into the i/o error; exit.
  \ connect socket
  call "ws2_32.dll" "connect" with the socket and the sockaddr's whereabouts and the sockaddr's magnitude returning a result number.
  if the result is not 0, put "Could not connect to socket." into the i/o error; exit.
  \ set send timeout 30 seconds
  call "ws2_32.dll" "setsockopt" with the socket and 65535 and 4101 [so_sndtimo] and 30 seconds' whereabouts and 4 returning the result number.
  if the result is not 0, put "Could not set receive timeout." into the i/o error; exit.
  \ set receive timeout 30 seconds
  call "ws2_32.dll" "setsockopt" with the socket and 65535 and 4102 [so_rcvtimeo] and 30 seconds' whereabouts and 4 returning the result number.
  if the result is not 0, put "Could not set receive timeout." into the i/o error; exit.

to create a string thing:
  \ to-do:  validate uses of this routine.
  allocate memory for the string thing.

to create a string thing given a string:
  allocate memory for the string thing.
  put the string into the string thing's string.

to create a vertex:
  allocate memory for the vertex.

to create a vertex array given a count:
  privatize the count.
  allocate memory for the vertex array.
  put the count into the vertex array's count.
  multiply the count by a spot's magnitude.
  assign the vertex array's spot pointer given the count.

to create a vertex array given some vertices:
  create the vertex array given the vertices' count.
  put the vertex array's spot pointer into a spot pointer.
  loop.
    get a vertex from the vertices.
    if the vertex is nil, exit.
    put the vertex's spot into the spot pointer's target.
    add the vertex's spot's magnitude to the spot pointer.
  repeat.

to create a vertex given a spot:
  allocate memory for the vertex.
  put the spot into the vertex's spot.

to create a vertex given an x coord and a y coord:
  allocate memory for the vertex.
  put the x into the vertex's x.
  put the y into the vertex's y.

to create a winhttp request for posting to a url:
  allocate memory for the winhttp request.
  convert the url to a url record.
  create the open handle of the winhttp request.
  if the i/o error is not blank, destroy the winhttp request; exit.
  create the connect handle of the winhttp request using the url record.
  if the i/o error is not blank, destroy the winhttp request; exit.
  create the request handle of the winhttp request using the url record.
  if the i/o error is not blank, destroy the winhttp request; exit.

a crypt session is a thing with
  an hcryptprov pointer,
  an hcrypthash pointer,
  an hcryptkey pointer.

the current canvas is a canvas.

the current event is an event.

the current font is a font.

a cursor is a handle.

to cut a number in half:
  divide the number by 2.

a date/time has
  a year number,
  a month number,
  a week day number,
  a day number,
  an hour number,
  a minute number,
  a second number,
  a millisecond number.

to de-sign a number:
  if the number is the smallest number, put the largest number into the number; exit.
  if the number is less than 0, negate the number.

to de-sign a pair:
  de-sign the pair's x.
  de-sign the pair's y.

to de-sign a ratio:
  de-sign the ratio's numerator.
  de-sign the ratio's denominator.

to de-sign a string:
  if the string is blank, exit.
  if the string's first's target is any sign, remove the first byte from the string.

to debug a box:
  clear a string.
  append "left=" to the string.
  append the box's left to the string.
  append ", top=" to the string.
  append the box's top to the string.
  append ", right=" to the string.
  append the box's right to the string.
  append ", bottom=" to the string.
  append the box's bottom to the string.
  debug the string.

to debug an event:
  put the event's kind then " event is " in a string.
  if the event's ctrl flag is set,
    append "Ctrl-" to the string.
  if the event's alt flag is set,
    append "Alt-" to the string.
  if the event's shift flag is set,
    append "Shift-" to the string.
  append " key = " then the event's key
    then "; byte = " then the event's byte
    then "; at x = " then the event's spot's x
    then ", y = " then the event's spot's y to the string.
  debug the string.

to debug a flag:
  convert the flag to a string.
  debug the string.

to debug a font:
  clear a string.
  append "name='" to the string then "'".
  append the font's name to the string.
  append ", height=" to the string.
  append the font's height to the string.
  debug the string.

to debug a line:
  clear a string.
  append "start=" to the string.
  append the line's start's x to the string.
  append "," to the string.
  append the line's start's y to the string.
  append " end=" to the string.
  append the line's end's x to the string.
  append "," to the string.
  append the line's end's y to the string.
  debug the string.

to debug a number:
  convert the number to a string.
  debug the string.

to debug a number and another number:
  debug the number then ", " then the other number.

to debug a pair:
  clear a string.
  append "x=" to the string.
  append the pair's x to the string.
  append ", y=" to the string.
  append the pair's y to the string.
  debug the string.

to debug a pointer:
  convert the pointer to a nibble string.
  debug "$" then the nibble string.

to debug a ratio:
  clear a string.
  append "numerator=" to the string.
  append the ratio's numerator to the string.
  append ", denominator=" to the string.
  append the ratio's denominator to the string.
  debug the string.

to debug a rgb:
  clear a string.
  append "red=" to the string.
  put the rgb's red byte into a number.
  append the number to the string.
  append ", green=" to the string.
  put the rgb's green byte into the number.
  append the number to the string.
  append ", blue=" to the string.
  put the rgb's blue byte into the number.
  append the number to the string.
  debug the string.

to debug a string:
  privatize the string.
  null terminate the string.
  call "user32.dll" "MessageBoxA" with 0
    and the string's first and "debug"'s first and 0.

to debug a string (quoted):
  privatize the string.
  prepend the double-quote byte to the string.
  append the double-quote byte to the string.
  debug the string.

to debug a timer:
\  put "count = " then the timer's count then "; "
\    then the timer's start ticks then " start ticks; "
\    then the timer's total ticks then " total ticks"
\    in a string.
\  debug the string.
  debug the timer's string then " ms.".

to debug a window:
  initialize a window placement.
  call "User32.dll" "GetWindowPlacement"
    with the window and the window placement's whereabouts.
  put the window placement's boxWhenRestored in a box.
  clear a string.
  append "window=" then the window then the crlf string to the string.
  append "flags=" then the window placement's flags to the string.
  append ", showCmd=" then the window placement's showCmd to the string.
  append the crlf string to the string.
  append "when minimized: " to the string.
  append "x=" then the window placement's upperLeftCornerWhenMinimized's x to the string.
  append ", y=" then the window placement's upperLeftCornerWhenMinimized's y to the string.
  append the crlf string to the string.
  append "when maximized: " to the string.
  append "x=" then the window placement's upperLeftCornerWhenMaximized's x to the string.
  append ", y=" then the window placement's upperLeftCornerWhenMaximized's y to the string.
  append the crlf string to the string.
  append "currently: " to the string.
  append "left=" then the box's left to the string.
  append ", top=" then the box's top to the string.
  append ", right=" then the box's right to the string.
  append ", bottom=" then the box's bottom to the string.
  append the crlf string to the string.
  debug the string.

to debug a wyrd:
  put the wyrd into a number.
  convert the number to a string.
  debug the string.

to decide if an alleged drive byte is any valid drive:
  convert the alleged drive byte into a path.
  append ":\" to the path.
  get a drive kind for the path.
  if the drive kind is "", say no.
  say yes.

to decide if at least one of some string things starts with a string:
  loop.
    get a string thing from the string things.
    if the string thing is nil, say no.
    if the string thing's string starts with the string,
      say yes.
  repeat.

to decide if a box is another box:
  if the box's left is not the other box's left, say no.
  if the box's top is not the other box's top, say no.
  if the box's right is not the other box's right, say no.
  if the box's bottom is not the other box's bottom, say no.
  say yes.

to decide if a box is still in another box;
to decide if a box is in another box;
to decide if a box is inside another box:
  if the box's left is less than the other box's left, say no.
  if the box's top is less than the other box's top, say no.
  if the box's right is greater than the other box's right, say no.
  if the box's bottom is greater than the other box's bottom, say no.
  say yes.

to decide if a box is touching another box:
  if the other box's right is less than the box's left, say no.
  if the other box's bottom is less than the box's top, say no.
  if the other box's left is greater than the box's right, say no.
  if the other box's top is greater than the box's bottom, say no.
  say yes.

to decide if a buffer does contain a string;
to decide if a string does contain another string:
  if the other string is in the string, say yes.
  say no.

to decide if a byte is in a string:
  privatize the byte.
  lowercase the byte.
  slap a substring on the string.
  loop.
    if the substring is blank, say no.
    put the substring's first's target into another byte.
    lowercase the other byte.
    if the other byte is the byte, say yes.
    add 1 to the substring's first.
  repeat.

to decide if a byte is a string:
  if the string's length is not 1, say no.
  privatize the byte.
  lowercase the byte.
  put the string's first's target into another byte.
  lowercase the other byte.
  if the byte is the other byte, say yes.
  say no.

to decide if can find a library procedure in a library:
  \ When "GetProcAddress" is run on 64-bit hardware,
  \ it sometimes crashes the process.
  \ The crashes occur at ntdll.dll!RtlInitString+0x1b
  \ and have exception code C0000005
  \ ("Access Violation - Failed to access <address's> memory").
  \
  \ It is possible that Windows' Wow64 emulator
  \ (which runs 32-bit .exes on 64-bit hardware)
  \ has a bug in how it sets up the stack frame.
  \
  \ This routine therefore minimizes the number of calls
  \ to "GetProcAddress" by caching this routine's result.
  \ Most library procedures have the same availability
  \ throughout a run of a program.
  \ If the library's availability might change,
  \ the caller should uncache the library, either before
  \ or after calling this routine (at the caller's option).
  \ If a library procedure's availability might change,
  \ the caller should uncache the library procedure
  \ in the library, either before or after calling
  \ this routine (at the caller's option).
  \
  if cannot find the library procedure in the library (failure cache),
    say no.
  if can find the library procedure in the library (success cache),
    say yes.
  if the library is not loadable,
    cache failure finding the library;
    say no.
  call "kernel32.dll" "LoadLibraryA"
    with the library's first returning a handle.
  if the handle is 0, 
    call "kernel32.dll" "GetLastError" returning a number;
    cache failure finding the library;
    say no.
  call "kernel32.dll" "GetProcAddress" with the handle
    and the library procedure's first returning a pointer.
  if the pointer is nil,
    cache failure finding the library procedure in the library;
    say no.
  cache success finding the library procedure in the library.
  say yes.

to decide if can find a library procedure in a library (failure cache):
  put the library then ";*" in a string.
  if the string is in the cached missing library procedures, say no.
  put the library then ";" then the library procedure in the string.
  if the string is in the cached missing library procedures, say no.
  say yes.

to decide if can find a library procedure in a library (success cache):
  put the library then ";" then the library procedure in a string.
  if the string is in the cached found library procedures, say yes.
  say no.

to decide if compile or list was requested:
  if list was requested, say yes.
  if compile was requested, say yes.
  say no.

to decide if compile was requested:
  if list was requested, say no.
  get a string (command line).
  if "/compile" is important in the string, say yes.
  say no.

to decide if a counter is past a number:
  add 1 to the counter.
  if the counter is greater than the number, say yes.
  say no.

to decide if ctrl is implied by a mouse wyrd:
  put the mouse wyrd in a number.
  if 8 [mk_control] is bitwise included in the number, say yes.
  say no.

to decide if a difference is within a grid:
  privatize the difference.
  de-sign the difference.
  if the difference's x is greater than or equal to the grid's x, say no.
  if the difference's y is greater than or equal to the grid's y, say no.
  say yes.

to decide if an event is modified:
  if the event's ctrl flag is set, say yes.
  if the event's alt flag is set, say yes.
  say no.

to decide if extra button one is implied by a mouse wyrd:
  put the mouse wyrd in a number.
  if 32 [mk_xbutton1] is bitwise included in the number, say yes.
  say no.

to decide if extra button two is implied by a mouse wyrd:
  put the mouse wyrd in a number.
  if 64 [mk_xbutton2] is bitwise included in the number, say yes.
  say no.

to decide if a finger is past the end of a string:
  if the finger is nil, say yes.
  if the finger is greater than the string's last, say yes.
  say no.

to decide if a flag is another flag;
to decide if a pointer is a number;
to decide if a pointer is another pointer;
to decide if a number is another number:
  intel $C7C001000000. \ mov eax,1        \ assume true
  intel $8B9D08000000. \ mov ebx,[ebp+8]  \ the number
  intel $8B1B.         \ mov ebx,[ebx]
  intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the other number
  intel $3B19.         \ cmp ebx,[ecx]
  intel $0F8406000000. \ je over the next 1 statement
  intel $C7C000000000. \ mov eax,0        \ now it's false

to decide if a flag is clear:
  if the flag is yes, say no.
  say yes.

to decide if a flag is on;
to decide if a flag is set:
  if the flag is yes, say yes.
  say no.

to decide if a font is another font:
  if the font's name is not the other font's name, say no.
  if the font's height is the other font's height, say yes.
  say no.

to decide if full [screen] was requested:
  get a string (command line).
  put the string in a command line.
  if full [screen] was requested in the command line, say yes.
  say no.

to decide if full [screen] was requested in a command line:
  if "/full" is important in the command line, say yes.
  say no.

to decide if an index is empty:
\  if the index is nil, say yes. \ to make compiler faster
\  loop.
    get a bucket given the index.
    if the bucket is nil, say yes.
    if the bucket's refers are not empty, say no.
  repeat.

to decide if an input is from windows telling us to refresh the cursor;
to decide if an input is from windows telling us to set the cursor:
  if the input is nil, say no.
  if the input's kind is "set cursor", say yes.
  say no.

to decide if an input is from windows telling us to show all our stuff;
to decide if an input is from windows telling us to show all of our stuff;
to decide if an input is from windows telling us to redraw all our stuff;
to decide if an input is from windows telling us to redraw all of our stuff:
  if the input is nil, say no.
  if the input's kind is "refresh", say yes.
  say no.

to decide if an input is from windows telling us we're done;
to decide if an input is from windows telling us that we're done;
to decide if an input is from windows telling us the user has quit:
  if the input is nil, say yes.

to decide if an input is a left click:
  void the left click.
  if the input's kind is not "left click", say no.
  put the input into the left click.

to decide if an item is found:
  if the item's kind is not blank, say yes.
  say no.

to decide if a key is any wm-char key:
  if the key is not any printable key, say no.
  if the alt key was down, say no.
  if the ctrl key was down, say no.
  say yes.

to decide if a key is down:
  call "user32.dll" "GetAsyncKeyState" with the key returning a wyrd.
  put the wyrd into a number.
  if the number is less than 0, say yes.
  say no.

to decide if a key is up:
  if the key is down, say no.
  say yes.

to decide if a key was down:
  call "user32.dll" "GetKeyState" with the key returning a wyrd.
  put the wyrd into a number.
  if the number is less than 0, say yes.
  say no.

to decide if a key was toggled:
  call "user32.dll" "GetKeyState" with the key returning a wyrd.
  put the wyrd into a number.
  bitwise and the number with 1.
  if the number is 1, say yes.
  say no.

to decide if a key was up:
  if the key was down, say no.
  say yes.

to decide if a key with an l-param is any repeated escape or modifier key:
  put the l-param into a number.
  bitwise and the number with 1073741824 [$40000000].
  if the number is 0, say no.
  if the key is the escape key, say yes.
  if the key is any modifier key, say yes.
  say no.

to decide if left is implied by a mouse wyrd:
  put the mouse wyrd in a number.
  if 1 [mk_left] is bitwise included in the number, say yes.
  say no.

to decide if the left mouse button is down:
  if the mouse's left button is down, say yes.
  say no.

to decide if left [half screen] was requested:
  get a string (command line).
  if left [half screen] was requested in the command line, say yes.
  say no.

to decide if left [half screen] was requested in a command line:
  if right [half screen] was requested in the command line, say no.
  if full [screen] was requested in the command line, say no.
  say yes.

to decide if a library is loadable:
  call "kernel32.dll" "LoadLibraryA"
    with the library's first returning a handle.
  if the handle is 0, say no.
  say yes.

to decide if a line is above a box:
  if the line's start's y is greater than or equal to the box's top, say no.
  if the line's end's y is greater than or equal to the box's top, say no.
  say yes.

to decide if a line is above a coord:
  if the line's start's y is greater than or equal to the coord, say no.
  if the line's end's y is greater than or equal to the coord, say no.
  say yes.

to decide if a line is another line:
  if the line's start spot is not the other line's start spot,
    say no.
  if the line's end spot is not the other line's end spot,
    say no.
  say yes.

to decide if a line is below a box:
  if the line's start's y is less than or equal to the box's bottom, say no.
  if the line's end's y is less than or equal to the box's bottom, say no.
  say yes.

to decide if a line is below a coord:
  if the line's start's y is less than or equal to the coord, say no.
  if the line's end's y is less than or equal to the coord, say no.
  say yes.

to decide if a line is still in a box;
to decide if a line is in a box:
  if the line's start is not in the box, say no.
  if the line's end is not in the box, say no.
  say yes.

to decide if list or compile or test was requested:
  if list was requested, say yes.
  if compile was requested, say yes.
  if test was requested, say yes.
  say no.

to decide if list was requested:
  get a string (command line).
  if "/list" is important in the string, say yes.
  say no.

to decide if middle is implied by a mouse wyrd:
  put the mouse wyrd in a number.
  if 16 [mk_mbutton] is bitwise included in the number, say yes.
  say no.

to decide if a mixed is a number:
  convert the mixed to a ratio.
  if the ratio is the number, say yes.
  say no.

to decide if the mouse has been dragged from a spot given a grid:
  if the mouse's left button is up, say no.
  put the mouse's spot into another spot.
  get a difference between the other spot and the spot.
  if the difference is within the grid, repeat.
  say yes.

to decide if the mouse is in a box:
  if the mouse's spot is in the box, say yes.
  say no.

to decide if none of some string things starts with a string:
  if at least one of the string things starts with the string, say no.
  say yes.

to decide if a number and another number are similarly signed:
  get the sign of the number returning a number called first sign.
  get the sign of the other number returning a number called other sign.
  if the first sign is the other sign, say yes.
  say no.

to decide if a number is another number and a string is another string:
  if the number is not the other number, say no.
  if the string is not the other string, say no.
  say yes.

to decide if a number is any cached late prime:
  if the number is at most the largest square root, say no.
  if the cached late primes are empty, say no.
  loop.
    get a number thing from the cached late primes.
    if the number thing is nil, say no.
    if the number thing's number is the number, say yes.
    if the number thing's number is greater than the number, say no.
  repeat.

to decide if a number is any of the early primes:
  if the cached early primes are empty, say no.
  loop.
    get a number thing from the cached early primes.
    if the number thing is nil, say no.
    if the number is the number thing's number, say yes.
  repeat.

to decide if a number is between another number and a third number:
  if the number is less than the other number, say no.
  if the number is greater than the third number, say no.
  say yes.

to decide if a number is bitwise included in another number:
  privatize the other number.
  bitwise and the other number with the number.
  if the number is the other number, say yes.
  say no.

to decide if a number is even:
  if the number is odd, say no.
  say yes.

to decide if a number is evenly divisible by another number:
  privatize the number.
  divide the number by the other number giving a quotient and a remainder.
  if the remainder is 0, say yes.
  say no.

to decide if a number is evenly divisible by any of the early primes:
  if the cached early primes are empty, say no.
  loop.
    get a number thing from the cached early primes.
    if the number thing is nil, say no.
    if the number is evenly divisible by the number thing's number, say yes.
  repeat.

to decide if a number is more than another number:
  if the number is greater than the other number, say yes.
  say no.

to decide if a number is a multiple of another number:
  if the number is evenly divisible by the other number, say yes.
  say no.

to decide if a number is negative:
  if the number is less than 0, say yes.
  say no.

to decide if a number is odd:
  privatize the number.
  bitwise and the number with 1.
  if the number is 0, say no.
  say yes.

to decide if a number is positive:
  if the number is greater than 0, say yes.
  say no.

to decide if a number is prime:
  if the number is at most 1, say no.
  if the number is any cached late prime, say yes.
  put the square root of the number in another number.
  add 1 to the other number.
  cache the early primes through the other number.
  if the number is any of the early primes, say yes.
  if the number is evenly divisible by any of the early primes, say no.
  if the number is greater than the largest square root,
    insert the number in the cached late primes.
  say yes.

to decide if the osmosian font is loaded:
  if the osmosian font resource is 0, say no.
  say yes.

to decide if a pair is another pair:
  if the pair's x is not the other pair's x, say no.
  if the pair's y is not the other pair's y, say no.
  say yes.

to decide if a pair is a number:
  if the pair's x is not the number, say no.
  if the pair's y is not the number, say no.
  say yes.

to decide if a pair is a number and another number:
  if the pair's x is not the number, say no.
  if the pair's y is not the other number, say no.
  say yes.

to decide if a path is absolute:
  extract a drive from the path.
  if the drive is "", say no.
  say yes.

to decide if a path is directory-format:
  if the path is blank, say no.
  if the path's last's target is the backslash byte, say yes.
  say no.

to decide if a path is drive-format:
  if the path starts with "\\", say yes.
  if the path's length is not 3, say no.
  if the path ends with ":\", say yes.
  say no.

to decide if a path is empty in the file system:
  if the path is not in the file system, say yes.
  get a count of items in the path in the file system.
  if the count is 0, say yes.
  say no.

to decide if a path is file-format:
  if the path is blank, say no.
  if the path's last's target is the colon byte, say no.
  if the path's last's target is the backslash byte, say no.
  say yes.

to decide if a path is in the file system:
  privatize the path.
  null terminate the path.
  call "kernel32.dll" "GetFileAttributesA" with the path's first returning a number.
  if the number is less than 0, say no.
  say yes.

to decide if a path is read-only:
  privatize the path.
  null terminate the path.
  call "kernel32.dll" "GetFileAttributesA" with the path's first returning a number.
  bitwise and the number with 1 [file_attribute_readonly].
  if the number is not 0, say yes.
  say no.

to decide if a pointer can be found;
to decide if a pointer is coming;
to decide if a pointer is found;
to decide if a pointer was found;
to decide if a pointer is there;
to decide if a pointer does exist:
if the pointer is nil, say no.
  say yes.

to decide if a pointer is at least another pointer:
  if the pointer is greater than or equal to the other pointer, say yes.
  say no.

to decide if a pointer is greater than another pointer;
to decide if a number is greater than another number:
  intel $C7C001000000. \ mov eax,1 \ assume true
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the number
  intel $8B1B.         \ mov ebx,[ebx]
  intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the other number
  intel $3B19.         \ cmp ebx,[ecx]
  intel $0F8F06000000. \ jg over the next 1 statement
  intel $C7C000000000. \ mov eax,0 \ now it's false

to decide if a pointer is greater than or equal to another pointer;
to decide if a number is another number or more;
to decide if a number is at least another number;
to decide if a number is greater than or equal to another number:
  intel $C7C001000000. \ mov eax,1 \ assume true
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the number
  intel $8B1B.         \ mov ebx,[ebx]
  intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the other number
  intel $3B19.         \ cmp ebx,[ecx]
  intel $0F8D06000000. \ jge over the next 1 statement
  intel $C7C000000000. \ mov eax,0 \ now it's false

to decide if a pointer is less than another pointer;
to decide if a number is less than another number:
  intel $C7C001000000. \ mov eax,1 \ assume true
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the number
  intel $8B1B.         \ mov ebx,[ebx]
  intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the other number
  intel $3B19.         \ cmp ebx,[ecx]
  intel $0F8C06000000. \ jl over the next 1 statement
  intel $C7C000000000. \ mov eax,0 \ now it's false

to decide if a pointer is less than or equal to another pointer;
to decide if a number is at most another number;
to decide if a number is another number or less;
to decide if a number is another number or fewer;
to decide if a number is less than or equal to another number:
  intel $C7C001000000. \ mov eax,1 \ assume true
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the number
  intel $8B1B.         \ mov ebx,[ebx]
  intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the other number
  intel $3B19.         \ cmp ebx,[ecx]
  intel $0F8E06000000. \ jle over the next 1 statement
  intel $C7C000000000. \ mov eax,0 \ now it's false

to decide if a pointer is missing;
to decide if a pointer is null and void:
  if the pointer is nil, say yes.
  say no.

to decide if a polygon is closed:
  if the polygon is nil, say no.
  if the polygon's vertices' count is less than 3, say no.
  if the polygon's first vertex's spot is the polygon's last vertex's spot, say yes.
  say no.

to decide if a ratio is another ratio:
  privatize the ratio.
  privatize the other ratio.
  normalize the ratio and the other ratio.
  if the ratio's numerator is the other ratio's numerator, say yes.
  say no.

to decide if a ratio is at least another ratio;
to decide if a ratio is greater than or equal to another ratio:
  privatize the ratio.
  privatize the other ratio.
  normalize the ratio and the other ratio.
  if the ratio's numerator is greater than or equal to the other ratio's numerator, say yes.
  say no.

to decide if a ratio is at most another ratio;
to decide if a ratio is less than or equal to another ratio:
  privatize the ratio.
  privatize the other ratio.
  normalize the ratio and the other ratio.
  if the ratio's numerator is less than or equal to the other ratio's numerator, say yes.
  say no.

to decide if a ratio is greater than another ratio:
  privatize the ratio.
  privatize the other ratio.
  normalize the ratio and the other ratio.
  if the ratio's numerator is greater than the other ratio's numerator, say yes.
  say no.

to decide if a ratio is less than another ratio:
  privatize the ratio.
  privatize the other ratio.
  normalize the ratio and the other ratio.
  if the ratio's numerator is less than the other ratio's numerator, say yes.
  say no.

to decide if a ratio is negative:
  if the ratio's numerator is less than 0, reverse a flag.
  if the ratio's denominator is less than 0, reverse the flag.
  say the flag.

to decide if a ratio is a number:
  if the ratio is the number / 1, say yes.
  say no.

to decide if a ratio is positive:
  privatize the ratio.
  de-sign the ratio.
  if the ratio's denominator is 0, say no.
  if the ratio's numerator is positive, say yes.
  say no.

to decide if a rider is stashable:
  if the rider's source is not blank, say no.
  if the rider's token is stashable given yes, say yes.
  say no.

to decide if right is implied by a mouse wyrd:
  put the mouse wyrd in a number.
  if 2 [mk_right] is bitwise included in the number, say yes.
  say no.

to decide if right [half screen] was requested:
  get a string (command line).
  put the string in a command line.
  if right [half screen] was requested in the command line, say yes.
  say no.

to decide if right [half screen] was requested in a command line:
  if "/right" is important in the command line, say yes.
  say no.

to decide if running on wine:
  \ http://www.winehq.org/pipermail/wine-devel/2008-September/069387.html
  put "ntdll.dll" in a library.
  put "wine_get_version" in a library procedure.
  if can find the library procedure in the library, say yes.
  say no.

to decide if a screen is maximized:
  if the screen's pixel width is less than
    the screen's maximum pixel width, say no.
  if the screen's pixel height is less than
    the screen's maximum pixel height, say no.
  say yes.

to decide if a screen is maximized given a window:
  if the window is minimized, say no.
  if the screen is maximized, say yes.
  say no.

to decide if a screen is restored given a window:
  if the window is minimized, say no.
  if the screen is maximized, say no.
  say yes.

to decide if shift is implied by a mouse wyrd:
  put the mouse wyrd in a number.
  if 4 [mk_shift] is bitwise included in the number, say yes.
  say no.

to decide if a spot is above a box:
  if the spot's y is less than the box's top, say yes.
  say no.

to decide if a spot is above a horizontal line:
  if the spot's y is less than the horizontal line's start's y, say yes.
  say no.

to decide if a spot is above or below a box:
  if the spot is above the box, say yes.
  if the spot is below the box, say yes.
  say no.

to decide if a spot is below a box:
  if the spot's y is greater than the box's bottom, say yes.
  say no.

to decide if a spot is below a horizontal line:
  if the spot's y is greater than the horizontal line's start's y, say yes.
  say no.

to decide if a spot is in an ellipse:
  create an hrgn given the ellipse.
  privatize the spot.
  divide the spot by the tpp.
  call "gdi32.dll" "PtInRegion" with the hrgn and the spot's x and the spot's y
    returning a number.
  destroy the hrgn.
  if the number is 0, say no.
  say yes.

to decide if a spot is in a picture:
  if the picture is nil, say no.
  if the spot is in the picture's box, say yes.
  say no.

to decide if a spot is in a polygon:
  if the polygon is nil, say no.
  create a vertex array given the polygon's vertices.
  call "gdi32.dll" "CreatePolygonRgn" with the vertex array's spot pointer and the vertex array's count and 2 [winding] returning an hrgn.
  call "gdi32.dll" "PtInRegion" with the hrgn and the spot's x and the spot's y returning a number.
  call "gdi32.dll" "DeleteObject" with the hrgn.
  destroy the vertex array.
  if the number is 0, say no.
  say yes.

to decide if a spot is in some polygons:
  get a polygon from the polygons.
  if the polygon is nil, say no.
  if the spot is in the polygon, say yes.
  repeat.

to decide if a spot is in a roundy box:
  privatize the roundy box.
  add the tpp to the roundy box's right-bottom.
  put the roundy box's radius times 2 into a diameter number.
  call "gdi32.dll" "CreateRoundRectRgn"
    with the roundy box's left and the roundy box's top
    and the roundy box's right and the roundy box's bottom 
    and the diameter and the diameter returning an hrgn.
  call "gdi32.dll" "PtInRegion" with the hrgn
    and the spot's x and the spot's y returning a number.
  call "gdi32.dll" "DeleteObject" with the hrgn.
  if the number is 0, say no.
  say yes.

to decide if a spot is inside a box;
to decide if a spot is within a box;
to decide if a spot is in a box:
  if the spot's x is less than the box's left, say no.
  if the spot's y is less than the box's top, say no.
  if the spot's x is greater than the box's right, say no.
  if the spot's y is greater than the box's bottom, say no.
  say yes.

to decide if a spot is to the left of a box:
  if the spot's x is less than the box's left, say yes.
  say no.

to decide if a spot is left or right of a box:
  if the spot is to the left of the box, say yes.
  if the spot is to the right of the box, say yes.
  say no.

to decide if a spot is on a box:
  put the box into another box.
  put 2 times the tpp into a number.
  outdent the other box given the number.
  if the spot is not in the other box, say no.
  put the box into a third box.
  put 3 times the tpp into another number.
  indent the third box given the other number.
  if the spot is in the third box, say no.
  say yes.

to decide if a spot is on an ellipse:
  put the ellipse into another ellipse.
  put 2 times the tpp into a number.
  outdent the other ellipse's box given the number.
  if the spot is not in the other ellipse, say no.
  put the ellipse into a third ellipse.
  put 3 times the tpp into another number.
  indent the third ellipse's box given the other number.
  if the spot is in the third ellipse, say no.
  say yes.

to decide if a spot is on a line:
  privatize the line.
  put 3 times the tpp into a number.
  loop.
    get a distance between the spot and the line's center (chessboard).
    if the distance is less than or equal to the number, say yes.
    get the distance between the line's start and the line's end (chessboard).
    if the distance is less than or equal to the tpp, say no.
    split the line into the line and another line.
    get the distance between the spot and the line's center (chessboard).
    get another distance between the spot and the other line's center (chessboard).
    if the distance is greater than the other distance,
      put the other line into the line.
  repeat.

to decide if a spot is on a picture:
  if the picture is nil, say no.
  if the spot is on the picture's box, say yes.
  say no.

to decide if a spot is on a polygon:
  if the polygon is nil, say no.
  loop.
    get a vertex from the polygon's vertices.
    if the vertex is nil, say no.
    if the vertex's next is nil, say no.
    put the vertex's spot and the vertex's next's spot into a line.
    if the spot is on the line, say yes.
  repeat.

to decide if a spot is on a roundy box:
  put the roundy box into another roundy box.
  put 2 times the tpp into a number.
  outdent the other roundy box given the number.
  if the spot is not in the other roundy box, say no.
  put the roundy box into a third roundy box.
  put 3 times the tpp into another number.
  indent the third roundy box given the other number.
  if the spot is in the third roundy box, say no.
  say yes.

to decide if a spot is outside a box:
  if the spot is inside the box, say no.
  say yes.

to decide if a spot is to the right of a box:
  if the spot's x is greater than the box's right, say yes.
  say no.

to decide if a spot is touching a box:
  if the spot is in the box, say yes.
  say no.

to decide if a spot is within a grid of another spot:
  get a difference between the other spot and the spot.
  if the difference is within the grid, say yes.
  say no.

to decide if a spot is within some twips of another spot:
  put the twips and the twips into a grid.
  if the spot is within the grid of the other spot, say yes.
  say no.

to decide if a spot is within some twips of a box:
  privatize the box.
  outdent the box given the twips.
  if the spot is within the box, say yes.
  say no.

to decide if a string does end with another string;
to decide if a string ends with another string:
  if the other string's length is greater than the string's length, say no.
  slap a substring on the string.
  put the substring's last minus the other string's length plus 1 into the substring's first.
  if the substring is the other string, say yes.
  say no.

to decide if a string does start with another string;
to decide if a string starts with another string:
  if the other string's length is greater than the string's length, say no.
  slap a substring on the string.
  put the substring's first plus the other string's length minus 1 into the substring's last.
  if the substring is the other string, say yes.
  say no.

to decide if a string does start with a byte;
to decide if a string starts with a byte:
  if the string is blank, say no.
  if the string's first's target is the byte, say yes.
  say no.

to decide if a string is another string:
  compare the string to the other string given the string's length and the other string's length (equal only).

to decide if a string is another string or a third string:
  if the string is the other string, say yes.
  if the string is the third string, say yes.
  say no.

to decide if a string is any integer:
  slap a substring on the string.
  if the substring is blank, say no.
  if the substring's first's target is any sign, add 1 to the substring's first.
  if the substring is blank, say no.
  loop.
    if the substring's first's target is not any digit, say no.
    add 1 to the substring's first.
    if the substring is blank, say yes.
  repeat.

to decide if a string is any integer literal:
  slap a substring on the string.
  if the substring is blank, say no.
  if the substring's first's target is any sign, add 1 to the substring's first.
  if the substring is blank, say no.
  loop.
    if the substring's first's target is not any digit, say no.
    add 1 to the substring's first.
    if the substring is blank, say yes.
  repeat.

to decide if a string is any mixed literal:
  slap a substring on the string.
  if the substring is blank, say no.
  if the substring's first's target is not any numeric starter, say no.
  if the substring's first's target is any sign, add 1 to the substring's first.
  split the substring into an integer substring and a ratio substring given the dash byte.
  if the integer substring is not any integer literal, say no.
  if the ratio substring is not any ratio literal, say no.
  say yes.

to decide if a string is any numeric literal:
  if the string is blank, say no.
  if the string's first's target is not any numeric starter, say no.
  if the string is any integer literal, say yes.
  if the string is any ratio literal, say yes.
  if the string is any mixed literal, say yes.
  say no.

to decide if a string is any ratio literal:
  slap a substring on the string.
  if the substring is blank, say no.
  if the substring's first's target is not any numeric starter, say no.
  if the substring's first's target is any sign, add 1 to the substring's first.
  split the substring into a numerator substring and a denominator substring given the slash byte.
  if the numerator substring is not any integer literal, say no.
  if the denominator substring is not any integer literal, say no.
  say yes.

to decide if a string is any sign:
  if the string's length is not 1, say no.
  if the string's first's target is any sign, say yes.
  say no.

to decide if a string is any word:
  if the string's length is less than 2, say no.
  slap a substring on the string.
  subtract 1 from the substring's first.
  loop.
    add 1 to the substring's first.
    if the substring is blank, say yes.
    if the substring's first's target is any letter, repeat.
    if the substring's first's target is the single-quote byte, repeat.
  say no.

to decide if a string is blank:
  \ assume true
  intel $B801000000.   \ mov eax,1
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the string
  \ if first is 0, exit
  intel $833B00.       \ cmp [ebx],0
  intel $0F8410000000. \ je end
  \ if last is less than first, exit
  intel $8B5304.       \ mov edx,[ebx+4] \ last pointer
  intel $3B13.         \ cmp edx,[ebx]
  intel $0F8C05000000. \ jl end
  \ SAY NO:
  intel $B800000000.   \ mov eax,0
  \ END:

to decide if a string is a byte:
  if the string's length is not 1, say no.
  if the string's first's target is the byte, say yes.
  say no.

to decide if a string is dos-compatible:
  if the string is blank, say no.
  if the string's first's target is the period byte, say no.
  slap a substring on the string.
  loop.
    if the substring is blank, say yes.
    if the substring's first's target is the slash byte, say no.
    if the substring's first's target is the backslash byte, say no.
    if the substring's first's target is the colon byte, say no.
    if the substring's first's target is the asterisk byte, say no.
    if the substring's first's target is the question-mark byte, say no.
    if the substring's first's target is the double-quote byte, say no.
    if the substring's first's target is the left-alligator byte, say no.
    if the substring's first's target is the right-alligator byte, say no.
    if the substring's first's target is the bar byte, say no.
    add 1 to the substring's first.
  repeat.

to decide if a string is greater than another string:
  compare the string to the other string
    given the string's length and the other string's length returning a number.
  if the number is greater than 0, say yes.
  say no.

to decide if a string is greater than or equal to another string:
  compare the string to the other string given the string's length and the other string's length returning a number.
  if the number is greater than or equal to 0, say yes.
  say no.

to decide if a string is important [is a parameter name] in a command line:
  parse the command line returning some string things.
  if the string is in the string things,
    destroy the string things; say yes.
  put the string then "=" in another string.
  if at least one of the string things starts with the other string,
    destroy the string things; say yes.
  destroy the string things.
  say no.

to decide if a string is in another string:
  slap a substring on the other string.
  put the substring's first plus the string's length minus 1 into the substring's last.
  loop.
    if the substring's last is greater than the other string's last, say no.
    if the substring is the string, say yes.
    move the substring given 1.
  repeat.

to decide if a string is in an index:
\  if the index is nil, say no. \ to make compiler faster
  if the string is blank, say no.
  find a refer given the string and the index.
  if the refer is nil, say no.
  say yes.

to decide if a string is in some string things:
  loop.
    get a string thing from the string things.
    if the string thing is nil, say no.
    if the string is the string thing's string, say yes.
  repeat.

to decide if a string is less than another string:
  compare the string to the other string
    given the string's length and the other string's length returning a number.
  if the number is less than 0, say yes.
  say no.

to decide if a string is less than or equal to another string:
  compare the string to the other string
    given the string's length and the other string's length returning a number.
  if the number is less than or equal to 0, say yes.
  say no.

to decide if a string is misspelled:
  if the lexicon is nil, say no.
  if the string is not any word, say no.
  privatize the string.
  if the string ends with "'s", remove the last two bytes from the string.
  if the string is in the lexicon's index, say no.
  say yes.

to decide if a string is stashable given a flag:
  if the flag is no, say no.
  if the string is blank, say no.
  if the string's last is greater than the string's first, say yes.
  if the string's first's target is noise, say no.
  say yes.

to decide if a string is wider than a box: \ assumes font is selected on memory canvas
  get an abca and an abcc given the string and the memory canvas.
  get a width given the string and the memory canvas.
  subtract the abca from the width.
  subtract the abcc from the width.
  if the width is greater than the box's width, say yes.
  say no.

to decide if a string is wrapped in double-quotes:
  privatize the string.
  if the string's first's target is not the double-quote byte, say no.
  if the string's  last's target is not the double-quote byte, say no.
  say yes.

to decide if a substring is on any contraction:
  put the substring's first plus 1 into a byte pointer.
  if the byte pointer is greater than the substring's last, say no.
  if the substring's first's target is not the single-quote byte, say no.
  if the byte pointer's target is not any letter, say no.
  say yes.

to decide if test was requested:
  if compile or list was requested, say no.
  get a string (command line).
  if "/test" is important in the string, say yes.
  say no.

to decide if there is text on the windows clipboard:
  call "user32.dll" "IsClipboardFormatAvailable" with 1 [cf_text] returning a number.
  if the number is 0, say no.
  say yes.

to decide if some things are empty:
  if the things' first is nil, say yes.
  say no.

to decide if verbose test was requested:
  if test was not requested, say no.
  get a string (command line).
  get another string from the string given "/test".
  if the other string is "verbose", say yes.
  say no.

to decide if we could find a pointer;
to decide if we did find a pointer:
  if the pointer is nil, say no.
  say yes.

to decide if a window is minimized:
  initialize a window placement.
  call "User32.dll" "GetWindowPlacement"
    with the window and the window placement's whereabouts.
  if the window placement's showCmd is 6 [sw_minimize],
    say yes.
  say no.

to decrement a number:
  subtract 1 from the number.

to decrypt a buffer given a passphrase string: \ sets i/o error if failure
  clear the i/o error.
  create a crypt session given the passphrase.
  if the crypt session is nil, exit.
  convert the buffer as a nibble string to a hex string.
  put the hex string's length into a length.
  call "advapi32.dll" "CryptDecrypt"
    with the crypt session's hcryptkey and 0 and 1 and 0 and the hex string's first
    and the length's whereabouts returning a result number.
  if the result number is 0,
    put "Error decrypting data." into the i/o error;
    destroy the crypt session; exit.
  destroy the crypt session.
  put the hex string into the buffer.

to deduplicate some string things:
  \ assumes the string things are already sorted.
  \ to-do:  verify.
  if the string things' first is the string things' last, exit.
  get a string thing from the string things.
  if the string thing is nil, exit.
  put the string thing's next into a thing called next thing.
  put the string thing's string in a string called current string.
  put the current string in a string called previous string.
  loop.
    put the next thing into the string thing.
    if the string thing is nil, exit.
    put the string thing's next into the next thing.
    put the string thing's string in the current string.
    if the current string is the previous string,
      remove the string thing from the string things;
      destroy the string thing.
    put the current string in the previous string.
  repeat.

the default font is a font.

the default smtp server is "localhost".

a depth is some twips.

a description is a string.

a designator is a string.
  \ rightmost directory with backslash = folder2\
  \ OR after the last backslash to end of path = file.ext

to destroy a crypt session:
  if the crypt session is nil, exit.
  call "advapi32.dll" "CryptDestroyKey" with the crypt session's hcryptkey.
  call "advapi32.dll" "CryptDestroyHash" with the crypt session's hcrypthash.
  call "advapi32.dll" "CryptReleaseContext" with the crypt session's hcryptprov and 0.
  deallocate the crypt session.

to destroy a gpimage:
  if the gpimage is nil, exit.
  call "gdiplus.dll" "GdipDisposeImage" with the gpimage.
  void the gpimage.

to destroy a gpimageattributes:
  if the gpimageattributes is nil, exit.
  call "gdiplus.dll" "GdipDisposeImageAttributes" with the gpimageattributes.
  void the gpimageattributes.

to destroy the hbrush of a canvas:
  call "gdi32.dll" "SelectObject" with the canvas and the null hbrush returning an hbrush.
  call "gdi32.dll" "DeleteObject" with the hbrush.

to destroy the hfont of a canvas:
  call "gdi32.dll" "SelectObject" with the canvas and the null hfont returning an hfont.
  call "gdi32.dll" "DeleteObject" with the hfont.

to destroy the hpen of a canvas:
  call "gdi32.dll" "SelectObject" with the canvas and the null hpen returning an hpen.
  call "gdi32.dll" "DeleteObject" with the hpen.

to destroy an hrgn:
    call "gdi32.dll" "DeleteObject" with the hrgn.

to destroy an index:
  if the index is nil, exit.
  loop.
    get a bucket given the index.
    if the bucket is nil, break.
    destroy the bucket's refers.
  repeat.
  unassign the index's first bucket.
  deallocate the index.

to destroy a path in the file system:
  set the path to read-write mode.
  if the path is directory-format, destroy the path in the file system (directory).
  if the path is file-format, destroy the path in the file system (file).

to destroy a path in the file system (directory):
  loop.
    get an item from the path.
    if the item is not found, break.
    put the path into another path.
    append the item's designator to the other path.
    destroy the other path in the file system.
    if the i/o error is not blank, exit.
  repeat.
  privatize the path.
  null terminate the path.
  call "kernel32.dll" "RemoveDirectoryA" with the path's first returning a number.
  clear the i/o error.
  if the number is not 0, exit.
  put "Error deleting directory '" then the path then "'." into the i/o error.

to destroy a path in the file system (file):
  privatize the path.
  null terminate the path.
  call "kernel32.dll" "DeleteFileA" with the path's first returning a number.
  clear the i/o error.
  if the number is not 0, exit.
  put "Error deleting file '" then the path then "'." into the i/o error.

to destroy a picture:
  if the picture is nil, exit.
  destroy the picture's gpbitmap.
  deallocate the picture.

to destroy a socket:
  call "ws2_32.dll" "closesocket" with the socket.

to destroy a vertex given a polygon:
  if the vertex is nil, exit.
  if the polygon is nil, exit.
  privatize the vertex.
  remove the vertex from the polygon's vertices.
  destroy the vertex.

to destroy a winhttp request:
  if the winhttp request is nil, exit.
  call "winhttp.dll" "WinHttpCloseHandle" with the winhttp request's request.
  call "winhttp.dll" "WinHttpCloseHandle" with the winhttp request's connection.
  call "winhttp.dll" "WinHttpCloseHandle" with the winhttp request's session.
  deallocate the winhttp request.

a devmode is a record with
  32 bytes called dmdevicename,
  a wyrd called dmspecversion,
  a wyrd called dmdriverversion,
  a wyrd called dmsize,
  a wyrd called dmdriverextra,
  a number called dmfields,
  a wyrd called dmorientation,
  a wyrd called dmpapersize,
  a wyrd called paperlength,
  a wyrd called paperwidth,
  a wyrd called dmscale,
  a wyrd called dmcopies,
  a wyrd called dmdefaultsource,
  a wyrd called dmprintquality,
  a wyrd called dmcolor,
  a wyrd called dmduplex,
  a wyrd called ydmresolution,
  a wyrd called dmttoption,
  a wyrd called dmcollate,
  32 bytes called dmformname,
  a wyrd called dmlogpixels,
  a number called dmbitsperpel,
  a number called dmpelswidth,
  a number called dmpelsheight,
  a number called dmdisplayflags,
  a number called dmdisplayfrequency,
  a number called dmicmmethod,
  a number called dmicmintent,
  a number called dmmediatype,
  a number called dmdithertype,
  a number called dmreserved1,
  a number called dmreserved2.

a difference is a pair.

a directory is a path.
  \ start of path to last backslash inclusive = c:\folder1\folder2\

a directory name is a string. \ rightmost directory with backslash = folder2\

a directory name w/o backslash is a string.
  \ rightmost directory without backslash = folder2

a distance is a number.

to divide a number by another number returning a ratio:
  put the number and the other number into the ratio.
  reduce the ratio.

to divide a number by a ratio:
  privatize the ratio.
  flip the ratio.
  multiply the number by the ratio.

to divide a pair by another pair:
  divide the pair's x by the other pair's x.
  divide the pair's y by the other pair's y.

to divide a pair by a number:
  divide the pair's x by the number.
  divide the pair's y by the number.

to divide a pair by a number and another number:
  divide the pair's x by the number.
  divide the pair's y by the other number.

to divide a pointer by a number;
to divide a number by another number:
  if the other number is 0, put the largest number into the number; exit.
  intel $8B8508000000. \ mov eax,[ebp+8]  \ the number
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the other number
  intel $8B00.         \ mov eax,[eax]
  intel $99.           \ cdq
  intel $F73B.         \ div [ebx]        \ means div eax,[ebx] but is weird form
  intel $8B9D08000000. \ mov ebx,[ebp+8]  \ the number
  intel $8903.         \ mov [ebx],eax

to divide a pointer by a number giving a quotient and a remainder;
to divide a number by another number giving a quotient and a remainder:
  if the other number is 0,
    put the largest number into the number; put 0 into the remainder; exit.
  intel $8B8508000000. \ mov eax,[ebp+8]  \ the number
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the other number
  intel $8B00.         \ mov eax,[eax]
  intel $99.           \ cdq
  intel $F73B.         \ idiv [ebx]       \ means idiv eax,[ebx] but is weird form
  intel $8B9D10000000. \ mov ebx,[ebp+16] \ the quotient
  intel $8903.         \ mov [ebx],eax
  intel $8B9D14000000. \ mov ebx,[ebp+20] \ the remainder
  intel $8913.         \ mov [ebx],edx

to divide a ratio by another ratio:
  privatize the other ratio.
  flip the other ratio.
  multiply the ratio by the other ratio.

to divide a ratio by a number:
  multiply the ratio's denominator by the number.
  reduce the ratio.

a docinfo is a record with
  a number called cbsize,
  a pointer called lpszdocname,
  a pointer called lpszoutput,
  a pointer called lpszdatadtype,
  a number called fwtype.

a dot is an ellipse.

to double a number:
  add the number to the number.

to draw and fill a box with a color:
  draw the box with the color and the color.

to draw a box:
  draw the box with the black color and the clear color.

to draw a box (focus style):
  privatize the box.
  add the tpp to the box's right-bottom.
  call "gdi32.dll" "LPtoDP" with the current canvas and the box's whereabouts and 2.
  convert the white color to a colorref.
  call "gdi32.dll" "SetBkColor" with the current canvas and the colorref.
  convert the black color to another colorref.
  call "gdi32.dll" "SetTextColor" with the current canvas and the other colorref.
  call "gdi32.dll" "SetMapMode" with the current canvas and 1 [mm_text].
  call "user32.dll" "DrawFocusRect" with the current canvas and the box's whereabouts.
  normalize the current canvas.

to draw a box in a color;
to draw a box with a color:
  draw the box with the color and the clear color.

to draw a box with a border color and a fill color:
  if the pdf state's page flag is set,
    draw the box with the border and the fill (pdf style); exit.
  privatize the box.
  create the hpen of the current canvas given the border.
  create the hbrush of the current canvas given the fill.
  if the border is clear, add the tpp to the box's left-top.
  call "gdi32.dll" "Rectangle" with the current canvas
    and the box's left and the box's top
    and the box's right and the box's bottom.
  destroy the hbrush of the current canvas.
  destroy the hpen of the current canvas.

to draw a box with a border color and a fill color (pdf style):
  if the border and the fill are clear, exit.
  output setcolor given the border and the fill.
  output the box's left-bottom without advancing.
  output the box's x-extent without advancing.
  output the box's y-extent without advancing.
  output "re".
  output stroke and fill given the border and the fill.

to draw a dot some twips wide on a spot with a color:
  make the dot the twips wide.
  center the dot on the spot.
  draw the dot with the color.

to draw an ellipse:
  draw the ellipse with the black color and the clear color.

to draw an ellipse on a spot with a color:
  center the ellipse on the spot.
  draw the ellipse with the color and the clear color.

to draw an ellipse with a border color and a fill color:
  if the pdf state's page flag is set, draw the ellipse with the border and the fill (pdf style); exit.
  privatize the ellipse.
  create the hpen of the current canvas given the border.
  create the hbrush of the current canvas given the fill.
  if the border is clear, add the tpp to the ellipse's left-top.
  call "gdi32.dll" "Ellipse" with the current canvas and the ellipse's left and the ellipse's top and the ellipse's right and the ellipse's bottom.
  destroy the hbrush of the current canvas.
  destroy the hpen of the current canvas.

to draw an ellipse with a border color and a fill color (pdf style):
  if the border and the fill are clear, exit.
  output setcolor given the border and the fill.
  put the ellipse's left and the ellipse's top into a spot.
  add the ellipse's y-extent divided by 2 to the spot's y.
  output moveto given the spot.
  output the arc of the ellipse given "left-top".
  output the arc of the ellipse given "right-top".
  output the arc of the ellipse given "right-bottom".
  output the arc of the ellipse given "left-bottom".
  output stroke and fill given the border and the fill.

to draw an ellipse with a color:
  draw the ellipse with the color and the color.

to draw a gpbitmap at a spot (pdf style):
  if the gpbitmap is nil, exit.
  \ add xobject
  add an xobject pdf object given "image object".
  put "I" then the xobject's number into a name.
  \  add to image resources in current page
  put "/" then the name then " " then the xobject's number then " 0 R" into a string.
  create a new string thing given the string.
  append the new string thing to the pdf state's current page's image strings.
  \ finish setting up xobject
  append the xobject's number then " 0 obj" to the xobject.
  append "<<" to the xobject.
  append "/Type /XObject" to the xobject.
  append "/Subtype /Image" to the xobject.
  append "/ColorSpace /DeviceRGB" to the xobject.
  append "/Width " then the gpbitmap's width to the xobject.
  append "/Height " then the gpbitmap's height to the xobject.
  append "/BitsPerComponent 8" to the xobject.
  convert the gpbitmap to a buffer (pdf style).
  convert the buffer to a nibble string.
  append "/Filter /ASCIIHexDecode" to the xobject.
  append "/Length " then the nibble string's length to the xobject.
  append ">>" to the xobject.
  append "stream" to the xobject.
  append the nibble string to the xobject.
  append "endstream" to the xobject.
  append "endobj" to the xobject.
  \ draw the image in the current contents
  put the gpbitmap's width times the tpp into a width.
  put the gpbitmap's height times the tpp into a height.
  put the spot's x into an x number.
  put the pdf state's current height minus the spot's y minus the height into a y number.
  output "q".
  output the width then " 0 0 " then the height then " " then the x then " " then the y then " cm".
  output "/" then the name then " Do".
  output "Q".

to draw a line with a color:
  if the pdf state's page flag is set, draw the line with the color (pdf style); exit.
  create the hpen of the current canvas given the color.
  call "gdi32.dll" "MoveToEx" with the current canvas and the line's start's x and the line's start's y and nil.
  call "gdi32.dll" "LineTo" with the current canvas and the line's end's x and the line's end's y.
  convert the color to a colorref.
  call "gdi32.dll" "SetPixelV" with the current canvas and the line's end's x and the line's end's y and the colorref.
  destroy the hpen of the current canvas.

to draw a line with a color (pdf style):
  if the color is clear, exit.
  output setcolor given the color and the clear color.
  output moveto given the line's start.
  output lineto given the line's end.
  output stroke and fill given the color and the clear color.

to draw a number in a box with a color:
  put the number into a string.
  draw the string in the box with the color and "center".

to draw a picture:
  if the pdf state's page flag is set, draw the picture (pdf style); exit.
  if the picture is nil, exit.
  save the current canvas.
  mask outside the picture's box.
  call "gdiplus.dll" "GdipCreateFromHDC" with the current canvas and a gpgraphic's whereabouts.
  call "gdiplus.dll" "GdipSetPageUnit" with the gpgraphic and 2 [pixels].
  draw the picture on the gpgraphic at the picture's uncropped box's left and the picture's uncropped box's top.
  call "gdiplus.dll" "GdipDeleteGraphics" with the gpgraphic.
  restore the current canvas.

to draw a picture (pdf style):
  if the picture is nil, exit.
  put the picture's box's left minus the picture's uncropped box's left divided by the tpp into an x number.
  put the picture's box's top minus the picture's uncropped box's top divided by the tpp  into an y number.
  put the picture's box's width divided by the tpp into a width.
  put the picture's box's height divided by the tpp into a height.
  call "gdiplus.dll" "GdipCreateBitmapFromScan0" with the width and the height
    and 0 and 137224 [pixelformat24bpprgb] and 0 and a gpbitmap's whereabouts.
  call "gdiplus.dll" "GdipGetImageGraphicsContext" with the gpbitmap and a gpgraphic's whereabouts.
  if the picture's grayscale flag is set, create a gpimageattributes (grayscale).
  call "gdiplus.dll" "GdipDrawImageRectRectI" with the gpgraphic and the picture's gpbitmap
    and 0 and 0 and the width and the height
    and the x and the y and the width and the height
    and 2 [unitpixel] and the gpimageattributes and nil and 0.
  if the gpimageattributes is not nil, destroy the gpimageattributes.
  call "gdiplus.dll" "GdipDeleteGraphics" with the gpgraphic.
  draw the gpbitmap at the picture's box's left-top (pdf style).
  call "gdiplus.dll" "GdipDisposeImage" with the gpbitmap.

to draw a picture on a gpgraphic at an x coord and a y coord:
  if the picture is nil, exit.
  if the picture's grayscale flag is set, create a gpimageattributes (grayscale).
  call "gdiplus.dll" "GdipDrawImageRectRectI" with the gpgraphic and the picture's gpbitmap
    and the x and the y and the picture's uncropped box's width and the picture's uncropped box's height
    and 0 and 0 and the picture's gpbitmap's width and the picture's gpbitmap's height
    and 2 [unitpixel] and the gpimageattributes and nil and 0.
  if the gpimageattributes is not nil, destroy the gpimageattributes.

to draw a polygon:
  draw the polygon with the black color and the clear color.

to draw a polygon with a border color and a fill color:
  if the pdf state's page flag is set, draw the polygon with the border and the fill (pdf style); exit.
  if the polygon is nil, exit.
  draw the polygon with the fill (fill only).
  draw the polygon with the border (border only).

to draw a polygon with a border color and a fill color (pdf style):
  if the polygon is nil, exit.
  if the border and the fill are clear, exit.
  output setcolor given the border and the fill.
  get a vertex from the polygon's vertices.
  if the vertex is nil, exit.
  output moveto given the vertex's spot.
  loop.
    get the vertex from the polygon's vertices.
    if the vertex is nil, break.
    output lineto given the vertex's spot.
  repeat.
  output stroke and fill given the border and the fill.

to draw a polygon with a color:
  draw the polygon with the color and the color.

to draw a polygon with a color (border only):
  if the polygon is nil, exit.
  if the color is clear, exit.
  create the hpen of the current canvas given the color.
  get a vertex from the polygon's vertices.
  if the vertex is nil, exit.
  call "gdi32.dll" "MoveToEx" with the current canvas and the vertex's x and the vertex's y and nil.
  loop.
    get the vertex from the polygon's vertices.
    if the vertex is nil, break.
    call "gdi32.dll" "LineTo" with the current canvas and the vertex's x and the vertex's y.
  repeat.
  destroy the hpen of the current canvas.
  if the polygon's vertices' first's spot is the polygon's vertices' last's spot, exit.
  convert the color to a colorref.
  call "gdi32.dll" "SetPixelV" with the current canvas and the polygon's vertices' last's x and the polygon's vertices' last's y and the colorref.

to draw a polygon with a color (fill only):
  if the polygon is nil, exit.
  if the color is clear, exit.
  create the hpen of the current canvas given the clear color.
  create the hbrush of the current canvas given the color.
  call "gdi32.dll" "SetPolyFillMode" with the current canvas and 2 [winding].
  create a vertex array given the polygon's vertices.
  call "gdi32.dll" "Polygon" with the current canvas and the vertex array's spot pointer and the vertex array's count.
  destroy the vertex array.
  destroy the hbrush of the current canvas.
  destroy the hpen of the current canvas.

to draw a roundy box:
  draw the roundy box with the black color and the clear color.

to draw a roundy box with a border color and a fill color:
  if the pdf state's page flag is set, draw the roundy box with the border and the fill (pdf style); exit.
  privatize the roundy box.
  create the hpen of the current canvas given the border.
  create the hbrush of the current canvas given the fill.
  if the border is clear, add the tpp to the roundy box's left-top.
  put the roundy box's radius times 2 into a diameter number.
  call "gdi32.dll" "RoundRect" with the current canvas and the roundy box's left and the roundy box's top and the roundy box's right and the roundy box's bottom
    and the diameter and the diameter.
  destroy the hbrush of the current canvas.
  destroy the hpen of the current canvas.

to draw a roundy box with a border color and a fill color (pdf style):
  if the border and the fill are clear, exit.
  if the roundy box's radius is 0, draw the roundy box as a box with the border and the fill (pdf style); exit.
  put the roundy box's radius into a radius.
  put the radius times 2 into an offset.
  put the roundy box into a box.
  output setcolor given the border and the fill.
  \ initial moveto
  output moveto given the box's left and the box's top plus the radius.
  \ left-top
  put the box's left and the box's top and the box's left plus the offset and the box's top plus the offset into an ellipse.
  output the arc of the ellipse given "left-top".
  output lineto given the box's right minus the radius and the box's top.
  \ right-top
  put the box's right minus the offset and the box's top and the box's right and the box's top plus the offset into the ellipse.
  output the arc of the ellipse given "right-top".
  output lineto given the box's right and the box's bottom minus the radius.
  \ right-bottom
  put the box's right minus the offset and the box's bottom minus the offset and the box's right and the box's bottom into the ellipse.
  output the arc of the ellipse given "right-bottom".
  output lineto given the box's left plus the radius and the box's bottom.
  \ left-bottom
  put the box's left and the box's bottom minus the offset and the box's left plus the offset and the box's bottom into the ellipse.
  output the arc of the ellipse given "left-bottom".
  \ finish up
  output "h".
  output stroke and fill given the border and the fill.

to draw a roundy box with a color:
  draw the roundy box with the color and the color.

to draw a spot:
  draw the spot with the black color.

to draw a spot with a color:
  convert the color to a colorref.
  call "gdi32.dll" "SetPixelV" with the current canvas and the spot's x and the spot's y and the colorref.

to draw a string at the left of a box:
  draw the string at the left of the box with the black color and the default font.

to draw a string at the left of a box with a color:
  draw the string at the left of the box with the color and the default font.

to draw a string at the left of a box with a color and a font:
  draw the string in the box with the color and the font and "left".

to draw a string at the left of a box with a font:
  draw the string at the left of the box with the black color and the font.

to draw a string at the right of a box:
  draw the string at the right of the box with the black color and the default font.

to draw a string at the right of a box with a color:
  draw the string at the right of the box with the color and the default font.

to draw a string at the right of a box with a color and a font:
  draw the string in the box with the color and the font and "right".

to draw a string at the right of a box with a font:
  draw the string at the right of the box with the black color and the font.

to draw a string at a spot with a color:
  draw the string at the spot with the color and the default font.

to draw a string at a spot with a color and a font:
  if the pdf state's page flag is set,
    draw the string at the spot with the color and the font (pdf style); exit.
  set the colorref of the current canvas given the color.
  create the hfont of the current canvas given the font.
  adjust spacing given the string.
  put the string's first into a substring's first.
  put the substring's first plus the text cutoff minus 1
    into the substring's last.
  privatize the spot.
  loop.
    if the substring is blank, break.
    if the substring's last is greater than the string's last,
      put the string's last into the substring's last.
    call "gdi32.dll" "TextOutA" with the current canvas
      and the spot's x and the spot's y
      and the substring's first and the substring's length.
    get a width given the substring and the current canvas.
    add the width to the spot's x.
    move the substring given the text cutoff.
  repeat.
  destroy the hfont of the current canvas.

to draw a string at a spot with a color and a font (pdf style):
  if the string is blank, exit.
  privatize the spot. 
  include the font in the current pdf.
  include the font in the pdf state's current page.
  find a definition pdf object given the font's name and the pdf state's font index.
  if the definition is nil, exit. \ error
  create a font info given the font and the string.
  output the pdf border given the color.
  output the pdf fill given the color.
  output "BT".
  output "/" then the definition's font name then " " then the font's adjusted height then " Tf".
  add the font's adjusted height minus the font info's internal leading to the spot's y.
  output the spot without advancing.
  output "Td".
  output "[" without advancing.
  convert the font info to pdf em units.
  convert the string and the font info and the definition's font info into a buffer for pdf output.
  output the buffer without advancing.
  output "]" without advancing.
  output " TJ".
  output "ET".
  destroy the font info.

to draw a string in a box:
  draw the string in the box with the black color and the default font and "left".

to draw a string in a box over a number with a color and a font and an alignment:
  privatize the box.
  if the alignment is "left", add the number to the box's left.
  if the alignment is "right", subtract the number from the box's right.
  draw the string in the box with the color and the font and the alignment.

to draw a string in a box with an alignment:
  draw the string in the box with the black color and the default font and the alignment.

to draw a string in a box with a color:
  draw the string in the box with the color and the default font and "left".

to draw a string in a box with a color and an alignment:
  draw the string in the box with the color and the default font and the alignment.

to draw a string in a box with a color and a font and an alignment:
  get an offset pair given the string and the box and the font and the alignment.
  draw the string at the box's left-top plus the offset pair with the color and the font.

to draw a string in a box with a font and an alignment:
  draw the string in the box with the black color and the font and the alignment.

to draw a string in the center of a box:
  draw the string in the center of the box with the black color and the default font.

to draw a string in the center of a box with a color:
  draw the string in the center of the box with the color and the default font.

to draw a string in the center of a box with a color and a font:
  draw the string in the box with the color and the font and "center".

to draw a string in the center of a box with a font:
  draw the string in the center of the box with the black color and the font.

a drive is a string.
  \ start of path to first backslash = c:\
  \ OR start of path to fourth backslash = \\computer\share\

a drive kind is a string.

to duplicate a path to another path in the file system:
  if the path is directory-format,
    duplicate the path to the other path in the file system (directory).
  if the path is file-format,
    duplicate the path to the other path in the file system (file).

to duplicate a path to another path in the file system (directory):
  if the path is in the other path, put "Error duplicating directory '" then the path then "' - invalid recursion." into the i/o error; exit.
  if the path is not in the file system, put "Error duplicating directory '" then the path then "'." into the i/o error; exit.
  if the other path is not in the file system, create the other path in the file system.
  loop.
    get an item from the path.
    if the item is not found, exit.
    put the path into a third path.
    append the item's designator to the third path.
    put the other path into a fourth path.
    append the item's designator to the fourth path.
    duplicate the third path to the fourth path in the file system.
  repeat.

to duplicate a path to another path in the file system (file):
  privatize the path.
  null terminate the path.
  privatize the other path.
  null terminate the other path.
  call "kernel32.dll" "CopyFileA" with the path's first and the other path's first and 0 returning a number.
  clear the i/o error.
  if the number is not 0, set the path to read-write mode; exit.
  put "Error duplicating file '" then the path then "'." into the i/o error.

a dyad is a thing with
  a name,
  a value string.

an editor font is a font.

an ellipse has a box.

an email has
  a smtp server,
  a sender,
  a recipient,
  a subject,
  a message.

to encrypt a buffer given a passphrase string: \ sets i/o error if failure
  clear the i/o error.
  create a crypt session given the passphrase.
  if the crypt session is nil, exit.
  put the buffer into a temp buffer.
  put the temp buffer's length into a length.
  call "advapi32.dll" "CryptEncrypt" with the crypt session's hcryptkey
    and 0 and 1 and 0 and the temp buffer's first
    and the length's whereabouts and the length returning a result number.
  if the result number is 0,
    put "Error encrypting data." into the i/o error;
    destroy the crypt session; exit.
  destroy the crypt session.
  convert the temp buffer to a nibble string.
  put the nibble string into the buffer.

to end printing:
  if the pdf state's document flag is set, end printing (pdf style); exit.
  call "gdi32.dll" "EndDoc" with the printer canvas.
  finalize the printer canvas.

to end printing (pdf style):
  if the pdf state's document flag is not set, exit.
  end printing the pdf state's pdf pointer's target.

to end printing a pdf:
  end printing the pdf (finish the parent).
  end printing the pdf (append the outline).
  end printing the pdf (finish the root).
  clear the pdf.
  end printing the pdf (append header).
  end printing the pdf (offset and append objects).
  end printing the pdf (append xref table).
  end printing the pdf (append trailer).
  end printing the pdf (append footer).
  destroy the pdf state's font index.
  destroy the pdf state's outline entries.
  destroy the pdf state's objects.
  clear the pdf state's document flag.

to end printing a pdf (append footer):
  append "startxref" then the crlf string to the pdf.
  append the pdf state's xref offset then the crlf string to the pdf.
  append "%%EOF" to the pdf.

to end printing a pdf (append header):
  append "%PDF-1.3" then the crlf string to the pdf.
  append "%" then the crlf string to the pdf.
  append the crlf string to the pdf.

to end printing a pdf (append the outline entries - create the objects):
  get a pdf outline entry from the pdf state's outline entries.
  if the pdf outline entry is nil, exit.
  add an entry pdf object given "outline entry".
  put the entry into the pdf outline entry's pdf object.
  repeat.

to end printing a pdf (append the outline entries):
  if the pdf state's outline entries are empty, exit.
  end printing the pdf (append the outline entries - create the objects).
  loop.
    get a pdf outline entry from the pdf state's outline entries.
    if the pdf outline entry is nil, exit.
    put the pdf outline entry's pdf object into an object pdf object.
    append the object's number then " 0 obj" to the object.
    append "<<" to the object.
    convert the pdf outline entry's title to a pdf string.
    append "/Title " then the pdf string to the object.
    append "/Parent " then the pdf state's outline's number then " 0 R" to the object.
    if the pdf outline entry's next is not nil, append "/Next " then the pdf outline entry's next's pdf object's number then " 0 R" to the object.
    if the pdf outline entry's previous is not nil, append "/Prev " then the pdf outline entry's previous' pdf object's number then " 0 R" to the object.
    append "/Dest [" then the pdf outline entry's destination then " 0 R /XYZ null " then the pdf outline entry's  page height then " null]" to the object.
    append ">>" to the object.
    append "endobj" to the object.
  repeat.

to end printing a pdf (append the outline):
  void the pdf state's outline.
  if the pdf state's outline entries are empty, exit.
  add an outline pdf object given "outline".
  put the outline into the pdf state's outline.
  end printing the pdf (append the outline entries).
  append the outline's number then " 0 obj" to the outline.
  append "<<" to the outline.
  append "/Type /Outlines" to the outline.
  append "/First " then the pdf state's outline entries' first's pdf object's number then " 0 R" to the outline.
  append "/Last " then the pdf state's outline entries' last's pdf object's number then " 0 R" to the outline.
  append "/Count " then the pdf state's outline entries' count to the outline.
  append ">>" to the outline.
  append "endobj" to the outline.

to end printing a pdf (append trailer):
  append "trailer" then the crlf string to the pdf.
  append "<<" then the crlf string to the pdf.
  put the pdf state's objects' count plus 1 into a count.
  append "/Size " then the count then the crlf string to the pdf.
  append "/Root " then the pdf state's root's number then " 0 R"
    then the crlf string to the pdf.
  append ">>" then the crlf string to the pdf.
  append the crlf string to the pdf.

to end printing a pdf (append xref table):
  put the pdf's length into the pdf state's xref offset.
  append "xref" then the crlf string to the pdf.
  put the pdf state's objects' count plus 1 into a count.
  append "0 " then the count then the crlf string to the pdf.
  append "0000000000 65535 f" then the crlf string to the pdf.
  loop.
    get a pdf object from the pdf state's objects.
    if the pdf object is nil, break.
    zero fill the pdf object's offset given 10 and append it to the pdf.
    append " 00000 n" then the crlf string to the pdf.
  repeat.
  append the crlf string to the pdf.

to end printing a pdf (finish the parent):
  put the pdf state's parent into a parent pdf object.
  append "/Kids [" to the parent without advancing.
  loop.
    get a pdf object from the pdf state's objects.
    if the pdf object is nil, break.
    if the pdf object's kind is not "page", repeat.
    if a flag is set, append " " to the parent without advancing.
    append the pdf object's number then " 0 R" to the parent without advancing.
    set the flag.
    add 1 to a count.
    if the count is evenly divisible by 20,
      append the crlf string then "  " to the parent without advancing.
  repeat.
  append "]" to the parent.
  append "/Count " then the count to the parent.
  append ">>" to the parent.
  append "endobj" to the parent.

to end printing a pdf (finish the root):
  put the pdf state's root into a root pdf object.
  append "/Pages " then the pdf state's parent's number then " 0 R" to the root.
  find a pdf object given "page".
  append "/OpenAction [" then the pdf object's number
    then " 0 R /XYZ null null 1]" to the root.
  append "/PageMode /UseNone" to the root.
  if the pdf state's outline is not nil,
    append "/Outlines " then the pdf state's outline's number then " 0 R" to the root.
  append ">>" to the root.
  append "endobj" to the root.

to end printing a pdf (offset and append objects):
  get a pdf object from the pdf state's objects.
  if the pdf object is nil, break.
  put the pdf's length into the pdf object's offset.
  append the pdf object's data to the pdf.
  append the crlf string to the pdf.
  repeat.

to end a sheet:
  if the pdf state's document flag is set, end the sheet (pdf style); exit.
  call "gdi32.dll" "EndPage" with the printer canvas.
  put the memory canvas into the current canvas.
  put the saved tpp into the tpp.

to end a sheet (pdf style - finish the current contents):
  put the pdf state's current contents into a content pdf object.
  put the content's data into a buffer.
  clear the content's data.
  append the content's number then " 0 obj" to the content.
  append "<</Length " then the buffer's length then " >>" to the content.
  append "stream" to the content.
  append the buffer to the content's data.
  append "endstream" to the content.
  append "endobj" to the content.
  clear the pdf state's page flag.

to end a sheet (pdf style - finish the current page - font resources):
  put the pdf state's current page into a page pdf object.
  if the page's font strings are empty, exit.
  append "/Font <<" to the page without advancing.
  loop.
    get a string thing from the page's font strings.
    if the string thing is nil, break.
    if a flag is set, append " " to the page without advancing.
    append the string thing's string to the page without advancing.
    set the flag.
  repeat.
  append ">>" to the page.

to end a sheet (pdf style - finish the current page - image resources):
  put the pdf state's current page into a page pdf object.
  if the page's image strings are empty, exit.
  append "/XObject <<" to the page without advancing.
  loop.
    get a string thing from the page's image strings.
    if the string thing is nil, break.
    if a flag is set, append " " to the page without advancing.
    append the string thing's string to the page without advancing.
    set the flag.
  repeat.
  append ">>" to the page.

to end a sheet (pdf style - finish the current page):
  put the pdf state's current page into a page pdf object.
  append "/Resources" to the page.
  append "<<" to the page.
  append "/ProcSet [/PDF /Text /ImageC]" to the page.
  end the sheet (pdf style - finish the current page - font resources).
  end the sheet (pdf style - finish the current page - image resources).
  append ">>" to the page. \ end resources
  append ">>" to the page. \ end page
  append "endobj" to the page.

to end a sheet (pdf style):
  end the sheet (pdf style - finish the current page).
  end the sheet (pdf style - finish the current contents).

to enlarge a box by some twips:
  subtract the twips from the box's left-top.
  add the twips to the box's right-bottom.

to enlarge an ellipse by some twips:
  subtract the twips from the ellipse's left-top.
  add the twips to the ellipse's right-bottom.

to enque an event:
  append the event to the event queue.

an environment variable is a string.

an environment variable name is a string.

to erase the insides of a box;
to erase inside a box;
to clear inside a box:
  draw the box with the clear color and the black color.

an event is a thing with
  a kind,
  a shift flag,
  a ctrl flag,
  an alt flag,
  a spot,
  a key, a byte.

the event queue is an event queue.

an event queue is some events.

an expectation is a string.

to extend a box to include another box:
  if the other box's left is less than the box's left,
    put the other box's left into the box's left.
  if the other box's top is less than the box's top,
    put the other box's top into the box's top.
  if the other box's right is greater than the box's right,
    put the other box's right into the box's right.
  if the other box's bottom is greater than the box's bottom,
    put the other box's bottom into the box's bottom.

an extension is a string. \ last dot to end of path = .ext

to extract a designator from a path:
  clear the designator.
  extract a drive from the path.
  slap a path substring on the path.
  add the drive's length to the path substring's first.
  if the path substring is blank, put the drive into the designator; exit.
  slap a substring on the last byte of the path substring.
  if the substring's first's target is the backslash byte,
    subtract 1 from the substring's first.
  loop.
    if the substring's first is less than the path substring's first, break.
    if the substring's first's target is the backslash byte, break.
    subtract 1 from the substring's first.
  repeat.
  add 1 to the substring's first.
  put the substring into the designator.

to extract a directory from a path:
  clear the directory.
  extract a drive from the path.
  if the drive is blank, exit.
  slap a substring on the path.
  add the drive's length to the substring's first.
  if the substring is blank, exit.
  if the substring's last's target is the backslash byte,
    subtract 1 from the substring's last.
  loop.
    if the substring is blank, break.
    if the substring's last's target is the backslash byte, break.
    subtract 1 from the substring's last.
  repeat.
  put the drive then the substring into the directory.

to extract a directory name from a path:
  clear the directory name.
  if the path is not directory-format, exit.
  extract the directory name as a designator from the path.

to extract a directory name w/o backslash from a path:
  extract the directory name w/o backslash as a directory name from the path.
  if the directory name w/o backslash is blank, exit.
  remove the last byte from the directory name w/o backslash.

to extract a drive from a path:
  clear the drive.
  if the path's length is less than 3, exit.
  slap a substring on the first byte of the path.
  add 2 to the substring's last.
  if the substring ends with ":\", put the substring into the drive; exit.
  if the substring does not start with "\\", exit.
  slap the substring on the first byte of the path.
  loop.
    if the substring's last is greater than the path's last, exit.
    if the substring's last's target is the backslash byte, add 1 to a count.
    if the count is 4, break. \ "\\computer\share\"
    add 1 to the substring's last.
  repeat.
  put the substring into the drive.

to extract an extension from a path:
  clear the extension.
  if the path is blank, exit.
  slap a substring on the last byte of the path.
  loop.
    if the substring's first is less than the path's first, exit.
    if the substring's first's target is the colon byte, exit.
    if the substring's first's target is the backslash byte, exit.
    if the substring's first's target is the period byte, break.
    subtract 1 from the substring's first.
  repeat.
  put the substring into the extension.

to extract a file name from a path:
  clear the file name.
  if the path is not file-format, exit.
  extract the file name as a designator from the path.

to extract a file name w/o extension from a path:
  extract the file name w/o extension as a file name from the path.
  extract an extension from the path.
  remove trailing bytes from the file name w/o extension
    given the extension's length.

to extract a picture given a box:
  put the box's width divided by the tpp into a width.
  put the box's height divided by the tpp into a height.
  call "gdiplus.dll" "GdipCreateBitmapFromScan0" with the width and the height
    and 0 and 137224 [pixelformat24bpprgb] and 0 and a gpbitmap's whereabouts.
  call "gdiplus.dll" "GdipGetImageGraphicsContext"
    with the gpbitmap and a gpgraphic's whereabouts.
  call "gdiplus.dll" "GdipGetDC"
    with the gpgraphic and a bitmap canvas' whereabouts.
  normalize the bitmap canvas.
  call "gdi32.dll" "BitBlt" with the bitmap canvas
    and 0 and 0 and the box's width and the box's height
    and the current canvas and the box's left and the box's top
    and 13369376 [srccopy].
  call "gdiplus.dll" "GdipReleaseDC" with the gpgraphic and the bitmap canvas.
  call "gdiplus.dll" "GdipDeleteGraphics" with the gpgraphic.
  create the picture given the gpbitmap.
  put the box into the picture's box.
  put the box into the picture's uncropped box.

a file is a handle.

a file name is a string. \ after the last backslash to end of path = file.ext

a file name w/o extension is a string.
  \ after the last backslash to last dot or end of path = file

a filetime is a record with
  a number called dwlowdatetime,
  a number called dwhighdatetime.

to fill a box with a color:
  draw the box with the clear color and the color.

to fill bytes with a byte starting at a pointer for a byte count:
  intel $8BBD0C000000. \ mov edi,[ebp+12] \ the pointer
  intel $8B3F.         \ mov edi,[edi]
  intel $8B8D10000000. \ mov ecx,[ebp+16] \ the count
  intel $8B09.         \ mov ecx,[ecx]
  intel $8B8508000000. \ mov eax,[ebp+8] \ the byte
  intel $8A00.         \ mov al,[eax]
  intel $FC.           \ cld
  intel $F3AA.         \ rep stosb

to fill an ellipse on a spot with a color:
  center the ellipse on the spot.
  draw the ellipse with the clear color and the color.

to fill a string with a byte given a count:
  reassign the string's first given the count.
  fill bytes with the byte starting at the string's first for the count.
  put the string's first plus the count minus 1 into the string's last.

to finalize after run:
  destroy the cached early primes.
  destroy the cached late primes.
  destroy the cached missing library procedures.
  destroy the cached found library procedures.
  if the heap count is 0, exit.
  put the heap count into a count.
  if test was requested,
    put 1 into the return code; exit.
  if the count is 1,
    put the count then " drip." into a string.
  if the count is not 1,
    put the count then " drips." into the string.
  debug the string.

to finalize the canvases:
  finalize the memory canvas.
  finalize the screen canvas.

to finalize the cgi:
  call "kernel32.dll" "FreeConsole".

to finalize com:
  call "ole32.dll" "CoUninitialize".

to finalize the cursors:
  call "user32.dll" "DestroyCursor" with the i-beam cursor.
  call "user32.dll" "DestroyCursor" with the hand cursor.
  call "user32.dll" "DestroyCursor" with the arrow cursor.

to finalize the fonts:
  if the osmosian font is loaded, 
    call "gdi32.dll" "RemoveFontMemResourceEx" with the osmosian font resource.

to finalize gdi+:
  call "gdiplus.dll" "GdiplusShutdown" with the gptoken.

to finalize the memory canvas:
  call "gdi32.dll" "SelectObject" with the memory canvas
    and the saved memory hbitmap returning an hbitmap.
  call "gdi32.dll" "DeleteObject" with the hbitmap.
  call "gdi32.dll" "DeleteDC" with the memory canvas.

to finalize the module:

to finalize the mouse:

to finalize the printer canvas:
  call "kernel32.dll" "GlobalFree" with the printer device mode handle.
  put 0 into the printer canvas.

to finalize the screen:

to finalize the screen canvas:

to finalize a talker:
  if the talker is nil, exit.
  call the talker's vtable's release with the talker.
  put nil into the talker.

to finalize the window:
  call "user32.dll" "DestroyWindow" with the main window.
  loop.
    call "user32.dll" "GetMessageA" with an msg's whereabouts
      and 0 and 0 and 0 returning a number.
    if the number is less than 1, break.
    call "user32.dll" "TranslateMessage" with the msg's whereabouts.
    call "user32.dll" "DispatchMessageA" with the msg's whereabouts.
  repeat.
  flush the event queue.
  destroy the current event.

to finalize winsock:
  call "ws2_32.dll" "WSACleanup".

to find a dyad given some dyads and a name:
  void the dyad.
  loop.
    get the dyad from the dyads.
    if the dyad is nil, exit.
    if the dyad's name is the name, exit.
  repeat.

to find a pdf object given a kind:
  void the pdf object.
  loop.
    get the pdf object given the pdf state's objects.
    if the pdf object is nil, break.
    if the pdf object's kind is the kind, break.
  repeat.

to find a pointer given a string and an index:
  find a refer given the string and the index.
  if the refer is not nil, put the refer's pointer into the pointer; exit.
  void the pointer.

to find a refer given a string and an index:
\  if the index is nil, exit. \ to make compiler faster
  if the string is blank, void the refer; exit.
  get a bucket given the string and the index.
  find the refer given the string and the bucket's refers.

to find a refer given a string and some refers:
  void the refer.
  loop.
    get the refer from the refers.
    if the refer is nil, exit.
    if the string is the refer's string, exit.
  repeat.

to find a sector given a grid and a spot:
  put the spot's x divided by the grid's x times the grid's x into the sector's x.
  put the spot's y divided by the grid's y times the grid's y into the sector's y.

to find a square root of a distance:
  put the distance in a number.
  put the square root of the number in a number called result.
  put the result in the square root.

to find a string given some string things and a string#:
  clear the string.
  loop.
  get a string thing from the string things.
  if the string thing is nil, exit.
  add 1 to a count.
  if the count is not the string#, repeat.
  put the string thing's string into the string.

the find string is a string.

to find a string thing given a string and some string things:
  void the string thing.
  loop.
    get the string thing given the string things.
    if the string thing is nil, break.
    if the string thing's string is the string, break.
  repeat.

to find a substring in a string given another string:
  slap the substring on the string.
  loop.
    if the substring is blank, exit.
    if the substring starts with the other string, break.
    add 1 to the substring's first.
  repeat.
  put the substring's first plus the other string's length minus 1 into the substring's last.

to find a value string given some dyads and a name:
  find a dyad given the dyads and the name.
  if the dyad is nil, clear the value; exit.
  put the dyad's value into the value.

to find a value string given the environment variables and a name:
  privatize the name.
  null terminate the name.
  put 32767 into a length. \ max size for environment variable
  reassign the value's first given the length.
  call "kernel32.dll" "GetEnvironmentVariableA" with the name's first and the value's first and the length returning the length.
  put the value's first plus the length minus 1 into the value's last.

a finger is a byte pointer.

a flag has 4 bytes.

to flip the gpbitmap in a picture:
  if the picture is nil, exit.
  reverse the picture's mirror flag.
  add 1800 to the picture's rotate angle.
  normalize the picture's rotate angle.
  flip the picture's gpbitmap.

to flip a gpimage:
  call "gdiplus.dll" "GdipImageRotateFlip" with the gpimage and 6 [rotatenoneflipy aka rotate180flipx].

to flip a picture:
  if the picture is nil, exit.
  put the picture's box's center's y minus the picture's uncropped box's center's y into a pair's y.
  multiply the pair's y by 2.
  move the picture's uncropped box given the pair.
  flip the gpbitmap in the picture.

to flip a polygon:
  if the polygon is nil, exit.
  put the polygon's box into a box.
  loop.
    get a vertex from the polygon's vertices.
    if the vertex is nil, exit.
    subtract the box's top from the vertex's y.
    put the box's bottom minus the vertex's y into the vertex's y.
  repeat.

to flip a ratio:
  swap the ratio's numerator with the ratio's denominator.

to flush all input;
to flush all inputs;
to flush all events:
  flush any messages.
  flush the event queue.

to flush any messages:
  call "user32.dll" "PeekMessageA" with an msg's whereabouts and 0 and 0 and 0 and 1 [pm_remove] returning a number.
  if the number is 0, exit.
  if the msg's message is 15 [wm_paint], call "user32.dll" "ValidateRect" with the main window and 0.
  repeat.

to flush an event queue:
  get an event from the event queue.
  if the event is nil, exit.
  remove the event from the event queue.
  destroy the event.
  repeat.

a font has a name and a height.

a font height is some twips.
\indicates line height - the letters will fit nicely in a box of this height

a font info is a thing with \ used for pdf conversion
  a font,
  an emsquare number,
  an internal leading number,
  a flags number,
  an ascent number,
  a descent number,
  a capheight number,
  an italicangle number,
  a stemv number,
  a font box,
  some font widths.

a font resource is a handle.

a font source is a hex string.

some font widths is a thing with \ used for pdf conversion
  a font,
  a count,
  a number pointer called data.

a foot is 12 inches.

to format a number and a singular string or a plural string into a string:
  convert the number to the string.
  append the space byte to the string.
  if the number is 1, append the singular to the string.
  if the number is not 1, append the plural to the string.

a fraction is a ratio.

a gcd is a number. \ greatest common denominator.

a gcpresults is a record with
  a number called lstructsize,
  a pchar called lpoutstring,
  a number pointer called lporder,
  a number pointer called lpdx,
  a number pointer called lpcaretpos,
  a pointer called lpclass,
  a pointer called lpglyphs,
  a number called nglyphs,
  a number called maxfit.

a gdiplusstartupinput is a record with
  a number called gdiplusversion,
  a pointer called debugeventcallback,
  a number called suppressbackgroundthread,
  a number called suppressexternalcodecs.

to get an abca and an abcc given a string and a canvas:
  put 0 into the abca.
  put 0 into the abcc.
  if the string's length is less than 1, exit.
  call "gdi32.dll" "GetCharABCWidthsA" with the canvas
    and the string's first's target and the string's first's target and an abc's whereabouts.
  put the abc's abca into the abca.
  call "gdi32.dll" "GetCharABCWidthsA" with the canvas
    and the string's last's target and the string's last's target and another abc's whereabouts.
  put the other abc's abcc into the abcc.

to get an abca given a string and a canvas:
  put 0 into the abca.
  if the string's length is less than 1, exit.
  call "gdi32.dll" "GetCharABCWidthsA" with the canvas
    and the string's first's target and the string's first's target and an abc's whereabouts.
  put the abc's abca into the abca.

to get some addrinfo routines:
  clear the i/o error.
  call "kernel32.dll" "LoadLibraryA" with "ws2_32.dll"'s first returning a handle.
  if the handle is 0, put "Could not load ws2_32.dll" into the i/o error; exit.
  call "kernel32.dll" "GetProcAddress" with the handle and "getaddrinfo"'s first returning a pointer.
  if the pointer is nil, put "Sorry these routines only work on Windows XP and up." into the i/o error; exit.
  put the pointer into the addrinfo routines' getaddrinfo pointer.
  call "kernel32.dll" "GetProcAddress" with the handle and "freeaddrinfo"'s first returning the pointer.
  if the pointer is nil, put "Sorry these routines only work on Windows XP and up." into the i/o error; exit.
  put the pointer into the addrinfo routines' freeaddrinfo pointer.

to get a box for a line:
  put the line's start into the box's left-top.
  put the line's end into the box's right-bottom.
  normalize the box.

to get a bucket given a bucket# and an index:
\  if the index is nil, void the bucket; exit. \ to make compiler faster
  put the index's first bucket into the bucket.
  add the bucket# times a bucket record's magnitude to the bucket.

to get a bucket given an index:
\  if the index is nil, void the bucket; exit. \ to make compiler faster
  if the bucket is nil, put the index's first bucket into the bucket; exit.
  if the bucket is the index's last bucket, void the bucket; exit.
  add a bucket record's magnitude to the bucket.

to get a bucket given a string and an index:
\  if the index is nil, void the bucket; exit. \ to make compiler faster
  get a bucket# given the string and the index.
  get the bucket given the bucket# and the index.

to get a bucket# given a string and an index: \ based on the djb2 algorithm
\  if the index is nil, put 0 into the bucket#; exit. \ to make compiler faster
  put the string's length into the bucket#.
  if the bucket# is 0, exit.
  add 5381 to the bucket#.
  slap a substring on the string.
  loop.
    put the substring's first's target into a byte.
    lowercase the byte.
    put the bucket# into a number.
    shift the bucket# left 5 bits.
    add the number to the bucket#.
    add the byte to the bucket#.
    add 3 to the substring's first.
    if the substring is blank, break.
  repeat.
  bitwise and the bucket# with the largest number.
  divide the bucket# by the index's bucket count
    giving a quotient and the bucket#.

to get a byte from a string:
  if the string is blank, put the null byte into the byte; exit.
  put the string's first's target into the byte.
  remove the first byte from the string.

to get a byte from a string (backwards):
  if the string is blank, put the null byte into the byte; exit.
  put the string's last's target into the byte.
  remove the last byte from the string.

to get a center spot given a spot and another spot:
  put the spot and the other spot into a line.
  put the line's center into the center.

to get a color given a spot:
  call "gdi32.dll" "GetPixel" with the current canvas
    and the spot's x and the spot's y returning a colorref.
  convert the colorref to the color.

to get a control font given a command line:
  if "/controlfont" is not important in the command line, 
    get a font given the command line; 
    put the font in the control font; 
    exit.
  get a string from the command line given "/controlfont".
  unquote the string.
  trim the string.
  if the string is "", 
    get another font given the command line; 
    put the other font in the control font; 
    exit.
  put the string in the control font's name.
  if the string is "Osmosian", 
    make sure the osmosian font is loaded; 
    put 1/4 inch in the control font's height; 
    exit.
  put 2/9 inch in the control font's height.

to get a count of items in a path in the file system:
  put 0 into the count.
  loop.
    get an item from the path.
    if the item is not found, exit.
    add 1 to the count.
  repeat.

to get a difference between a pair and another pair:
  put the pair into the difference.
  subtract the other pair from the difference.

to get a difference between a pair and another pair given a grid pair:
  get the difference between the pair and the other pair.
  round the difference to the grid.

to get a distance between a spot and another spot (approximate):
  put the spot's x minus the other spot's x into a number.
  de-sign the number.
  put the spot's y minus the other spot's y into another number.
  de-sign the other number.
  put the number times the number into the distance.
  add the other number times the other number to the distance.
  find a square root of the distance.
  put the square root into the distance.
  if the d-key is down, debug the distance.

to get a distance between a spot and another spot (chessboard):
  put the spot's x minus the other spot's x into a number.
  de-sign the number.
  put the spot's y minus the other spot's y into another number.
  de-sign the other number.
  put the number into the distance.
  if the other number is greater than the number,
    put the other number into the distance.

to get a drive kind for a path:
  privatize the path.
  null terminate the path.
  call "kernel32.dll" "GetDriveTypeA" with the path's first returning a number.
  if the number is 2 [drive_removable], put "removable" into the drive kind; exit.
  if the number is 3 [drive_fixed], put "fixed" into the drive kind; exit.
  if the number is 4 [drive_remote], put "remote" into the drive kind; exit.
  if the number is 5 [drive_cdrom], put "cd-rom" into the drive kind; exit.
  if the number is 6 [drive_ramdisk], put "ram disk" into the drive kind; exit.
  put "" into the drive kind.

to get an editor font given a command line:
  put 2/9 inch in the editor font's height.
  \ if "/tt" is important in the command line, 
  put "Courier New" in the editor font's name.
  if "/edfont" is important in the command line, 
    get the editor font's name from the command line given "/edfont".
  unquote the editor font's name.
  trim the editor font's name.
  if the editor font's name is "", 
    get a font from the command line; 
    put the font in the editor font; 
    exit.
  if the editor font's name is "Osmosian", 
    make sure the osmosian font is loaded; 
    put 1/4 inch in the editor font's height.

to get an environment variable given an environment variable name:
  find a value string given the environment variables and the environment variable name.
  put the value string in the environment variable.

to get an environment variable given a string:
  put the string in an environment variable name.
  get the environment variable given the environment variable name.

to get a font given a command line:
  put 2/9 inch in the font's height.
  if "/font" is not important in the command line, 
    put "Arial" in the font's name; exit.
  get the font's name from the command line given "/font".
  unquote the font's name.
  trim the font's name.
  if the font's name is "", put "Arial" in the font's name.
  if the font's name is "Osmosian", 
    make sure the osmosian font is loaded; 
    put 1/4 inch in the font's height.

to get fresh random numbers;
to get new random numbers;
to seed the random number generator:
  put the system's tick count into the seed.

to get a gcd given a number and another number:
  put the number into a dividend number.
  put the other number into the gcd.
  de-sign the dividend number.
  de-sign the gcd.
  if the dividend is less than the gcd, swap the dividend with the gcd.
  if the gcd is 0, put 1 into the gcd; exit.
  loop.
    divide the dividend by the gcd giving a quotient and a remainder.
    if the remainder is 0, exit.
    put the gcd into the dividend.
    put the remainder into the gcd.
  repeat.

to get an ip address given a host string:
  clear the ip address.
  get a sockaddr given the host string.
  if the i/o error is not blank, exit.
  put the sockaddr's sin_addr's s_addr into the ip address' number.
  call "ws2_32.dll" "inet_ntoa" with the ip address' number returning a pchar.
  convert the pchar to the ip address' string.

to get an item (not first time):
  clear the i/o error.
  call "kernel32.dll" "FindNextFileA" with the item's handle
    and the item's win32finddata's whereabouts returning a number.
  if the number is not 0, adjust the item; exit.
  clear the item's kind.
  call "kernel32.dll" "FindClose" with the item's handle.

to get an item from a path:
  if the path is not directory-format, exit.
  put the path into the item's directory.
  if the item's kind is blank, get the item from the path (first time); exit.
  get the item (not first time).

to get an item from a path (first time):
  clear the i/o error.
  privatize the path.
  append "*.*" to the path.
  null terminate the path.
  clear the item's kind.
  call "kernel32.dll" "FindFirstFileA" with the path's first
    and the item's win32finddata's whereabouts returning the item's handle.
  if the item's handle is -1 [invalid_handle_value], exit.
  adjust the item.

to get an lcm given a number and another number:
  get a gcd given the number and the other number.
  call "kernel32.dll" "MulDiv" with the number and the other number
    and the gcd returning the lcm.

to get an offset pair given a string and a box and a font and an alignment:
  create the hfont of the memory canvas given the font.
  get the offset pair given the string and the box and the font and the alignment (fast).
  destroy the hfont of the memory canvas.

to get an offset pair given a string and a box and a font and an alignment (fast):
  if the alignment is "left",
    get the offset pair's x given the string and the box (fast - left).
  if the alignment is "right",
    get the offset pair's x given the string and the box (fast - right).
  if the alignment is "center",
    get the offset pair's x given the string and the box (fast - center).
  call "gdi32.dll" "GetTextMetricsA" with the memory canvas and a textmetric's whereabouts.
  add the box's height minus the textmetric's tmheight divided by 2 to the offset pair's y.

to get an outlinetextmetric given a font:
  create the hfont of the memory canvas given the font.
  call "gdi32.dll" "GetOutlineTextMetricsA" with the memory canvas
    and 0 and 0 returning a result number.
  assign a poutlinetextmetric given the result.
  call "gdi32.dll" "GetOutlineTextMetricsA" with the memory canvas
    and the result and the poutlinetextmetric.
  put the poutlinetextmetric's target into the outlinetextmetric.
  destroy the hfont of the current canvas.
  unassign the poutlinetextmetric.

to get requested leaf directory path given a command line returning a path:
  put "" in the path.
  if "/folder" is not important in the command line, exit.
  get a string called requested folder from the command line given "/folder".
  trim the requested folder.
  if the requested folder is wrapped in double-quotes,
    remove the first byte from the requested folder;
    remove the  last byte from the requested folder.   
  put the requested folder in the path.
  if the path is blank, exit.
  if the path is not directory-format,
    append the backslash byte to the path.
  extract a drive from the path.
  if the drive is not in the file system, put "" in the path; exit.
  loop.
    if the path is in the file system, exit.
    extract a designator from the path.
    trim the designator's length from the path.
    if the path is "", exit.
  repeat.
\
\to-do:  Replace repeated remove last byte
\and remove first byte code with remove first __ bytes
\and remove last __ bytes code.

to get a residue from a string after a prefix:
  put "" in the residue.
  if the prefix is "", exit.
  if the string does not start with the prefix, exit.
  if the prefix starts with the string, exit.
  slap a substring on the string.
  put the substring's first plus the prefix's length into the substring's first.
  put the substring into the residue.

to get a rgb pointer from a bitmapdata at a row# and a column#: \ 1 based
  put the bitmapdata's scan0 into the rgb pointer.
  add the row# minus 1 times the bitmapdata's stride to the rgb pointer.
  add the column# minus 1 times a rgb's magnitude to the rgb pointer.

to get the sign of a number returning another number:
  if the number is greater than 0, put  1 in the other number; exit.
  if the number is    less than 0, put -1 in the other number; exit.
  put 0 in the other number.

to get a size given a path in the file system:
  if the path is directory-format,
    get the size given the path in the file system (directory).
  if the path is file-format, get the size given the path in the file system (file).

to get a size given a path in the file system (directory):
  put 0 into the size.
  loop.
    get an item from the path.
    if the item is not found, exit.
    if the item's kind is "file", add the item's size to the size; repeat.
    put the path into another path.
    append the item's designator to the other path.
    get another size given the other path in the file system.
    add the other size to the size.
  repeat.

to get a size given a path in the file system (file):
  privatize the path.
  null terminate the path.
  call "kernel32.dll" "GetFileAttributesExA"
    with the path's first and 0 and a win32finddata's whereabouts.
  put the win32finddata's nfilesizelow into the size.

to get a sockaddr given a host string:
  clear the i/o error.
  \ prepare strings
  privatize the host string.
  null terminate the host string.
  \ get the function addresses
  get some addrinfo routines.
  if the i/o error is not blank, exit.
  \ get the sockaddr
  put 2 [af_inet] into a addrinfo's ai_family.
  put 1 [sock_stream] into the addrinfo's ai_sockettype.
  put 6 [ipproto_tcp] into the addrinfo's ai_protocol.
  call the addrinfo routines' getaddrinfo with the host string's first
    and 0 and the addrinfo's whereabouts and a addrinfoptr's whereabouts
    returning a result number.
  if the result number is not 0,
    put "Could not resolve host name '" then the host then "'." into the i/o error; exit.
  if the addrinfoptr is nil,
    put "Could not resolve host name '" then the host then "'." into the i/o error; exit.
  put the addrinfoptr's ai_addr's target into the sockaddr.
  call the addrinfo routines' freeaddrinfo with the addrinfoptr.

to get stderr returning a standard handle:
  \ std_input_handle = -10; std_output_handle = -11
  call "kernel32.dll" "GetStdHandle" 
    with -12 [std_error_handle]
    returning the standard handle.
  if the standard handle is -1 [invalid_handle_value],
    put "Error opening the standard error stream." into the i/o error; exit.

to get a string (command line):
  call "kernel32.dll" "GetCommandLineA" returning a byte pointer.
  if the byte pointer is nil, exit.
  count from the byte pointer to the null byte returning a length.
  convert the byte pointer and the length to the string.

to get a string from the windows clipboard:
  clear the string.
  call "user32.dll" "OpenClipboard" with the main window.
  call "user32.dll" "GetClipboardData" with 1 [cf_text] returning a handle.
  if the handle is 0, call "user32.dll" "CloseClipboard"; exit.
  call "kernel32.dll" "GlobalLock" with the handle returning a pchar.
  convert the pchar to the string.
  call "kernel32.dll" "GlobalUnlock" with the handle.
  call "user32.dll" "CloseClipboard".

to get a string [parameter value] from a command line given another string [parameter name]:
  clear the string.
  put the other string then "=" in a string called prefix.
  parse the command line returning some string things.
  if none of the string things starts with the prefix,
    destroy the string things; exit.
  reverse the string things. \later choices override earlier choices
  loop.
    get a string thing from the string things.
    if the string thing is nil, break.
    if the string thing's string starts with the prefix,
      get the string from the string thing's string after the prefix;
      break.
  repeat.
  destroy the string things.

to get a string [program name] from a command line:
  clear the string.
  parse the command line returning some string things.
  put the string things' first's string in the string.
  destroy the string things.
\
\ In Windows, the first item in the command line
\ is the program name used to call the program;
\ it is not necessarily the program's canonical name.

to get a thing from some things:
  if the things are empty, void the thing; exit.
  if the thing is nil, put the things' first into the thing; exit.
  put the thing's next into the thing.

to get a thing from some things (backwards):
  if the things are empty, void the thing; exit.
  if the thing is nil, put the things' last into the thing; exit.
  put the thing's previous into the thing.

to get a width given a byte and a canvas:
  call "gdi32.dll" "GetTextExtentPoint32A" with the canvas
    and the byte's whereabouts and 1 and a pair's whereabouts.
  put the pair's x into the width.

to get a width given a byte and some font widths:
  put the byte into a number.
  get the width given the number and the font widths.

to get a width given a number and some font widths: \ indexes are 0 based
  if the font widths are nil, clear the width; exit.
  put the font widths' data into a number pointer.
  add the number times the number's magnitude to the number pointer.
  put the number pointer's target into the width.

to get a width given a string and a canvas:
   \ assumes font is already selected in canvas
  call "gdi32.dll" "GetTextExtentPoint32A" with the canvas
    and the string's first and the string's length and a pair's whereabouts.
  put the pair's x into the width.

to get a width given a string and a canvas and a font:
  create the hfont of the canvas given the font.
  get the width given the string and the canvas.
  destroy the hfont of the canvas.

to get a width given a string and a font: \ assumes memory canvas
  get the width given the string and the memory canvas and the font.

to get an x coord given a string and a box (fast - center):
  get a width given the string and the memory canvas.
  get an abca and an abcc given the string and the memory canvas.
  put the width minus the abca minus the abcc into the width.
  put the box's width minus the width divided by 2 minus the abca into the x.

to get an x coord given a string and a box (fast - left):
  get an abca given the string and the memory canvas.
  put - the abca into the x.

to get an x coord given a string and a box (fast - right):
  get an abca and an abcc given the string and the memory canvas.
  get a width given the string and the memory canvas.
  put the width minus the abca minus the abcc into the width.
  put the box's width minus the width minus the abca into the x.

a gigabyte is 1024 megabytes.

to globalize a box given a pair:
  move the box given the pair.

to globalize a line given a pair:
  move the line's start spot given the pair.
  move the line's end spot given the pair.

to globalize a spot given a pair:
  move the spot given the pair.

a gpbitmap is a gpimage.

a gpgraphic is a pointer.

a gpimage is a pointer.

a gpimageattributes is a pointer.

a gprect is a record with
  a number called x,
  a number called y,
  a number called width,
  a number called height.

the gptoken is a gptoken.

a gptoken is a number.

a grain is 10 milliseconds.

a grid is a pair.

a guid is a uuid.

the hand cursor is a cursor.

to handle any wm-activate with a w-param:
  split the w-param into a wyrd and another wyrd.
  put the other wyrd into a number.
  if the number is 0, handle any wm-activate with the w-param (deactivate); exit.
  handle any wm-activate with the w-param (activate).

to handle any wm-activate with a w-param (activate):
  call "user32.dll" "SetFocus" with the main window.
  call "user32.dll" "ClipCursor" with 0.
\  seterrormode(sem_failcriticalerrors)
   \ keeps certain disk errors from appearing
  create an event.
  put "activate" into the event's kind.
  enque the event.
  call "user32.dll" "PostMessageA" with the main window and 0 [wm_null] and 0 and 0.

to handle any wm-activate with a w-param (deactivate):
  create an event.
  put "deactivate" into the event's kind.
  enque the event.
  call "user32.dll" "PostMessageA" with the main window and 0 [wn_null] and 0 and 0.

to handle any wm-char with a w-param and an l-param:
  if the alt key was down, exit.
  if the ctrl key was down, exit.
  put the w-param into a byte.
  if the byte is not printable, exit.
  create an event.
  put "key down" into the event's kind.
  if the shift key was down, set the event's shift flag.
  put the byte into the event's byte.
  convert the l-param to the event's key.
  enque the event.

to handle any wm-create with a window:
  put the window into the main window.

to handle any wm-destroy:
  call "user32.dll" "PostQuitMessage" with 0.

to handle any wm-lbuttondblclk with a l-param:
  create an event.
  put "left double click" into the event's kind.
  if the   alt key was down, set the event's alt flag.
  if the  ctrl key was down, set the event's ctrl flag.
  if the shift key was down, set the event's shift flag.
  convert the l-param to the event's spot.
  enque the event.

to handle any wm-lbuttondown with a l-param:
  create an event.
  put "left click" into the event's kind.
  if the alt key was down, set the event's alt flag.
  if the ctrl key was down, set the event's ctrl flag.
  if the shift key was down, set the event's shift flag.
  convert the l-param to the event's spot.
  enque the event.

to handle any wm-mousehwheel with a w-param:
  split the w-param into a wyrd called high wyrd and a mouse wyrd.
  create an event.
  put "mouse horizontal wheel" into the event's kind.
  if the alt key was down, set the event's alt flag.
  if  ctrl is implied by the mouse wyrd, set the event's ctrl flag.
  if shift is implied by the mouse wyrd, set the event's shift flag.
  put the  high wyrd in the event's key.
  put the mouse wyrd in the event's byte.
  enque the event.

to handle any wm-mousewheel with a w-param:
  split the w-param into a wyrd called high wyrd and a mouse wyrd.
  create an event.
  put "mouse wheel" into the event's kind.
  if the alt key was down, set the event's alt flag.
  if  ctrl is implied by the mouse wyrd, set the event's ctrl flag.
  if shift is implied by the mouse wyrd, set the event's shift flag.
  put the  high wyrd in the event's key.
  put the mouse wyrd in the event's byte.
  enque the event.

to handle any wm-paint with a window:
\  if list or compile or test was requested, 
\    call "user32.dll" "ValidateRect" with the main window and 0;
\    exit.
  \ to-do:
  \ if the window has an update region,
  \   perform the next two steps.
  call "user32.dll" "BeginPaint" with the window and a paintstruct's whereabouts.
  \ to-do:
  \ update the memory canvas to match the paintstruct's hdc.
  call "user32.dll" "EndPaint" with the window and the paintstruct's whereabouts.
  create an event.
  put "refresh" into the event's kind.
  enque the event.
\
\ to-do:
\ to decide if a window has an update region:
\   create a box.
\   call "user32.dll" "GetUpdateRect" with the window and the box' whereabouts  and no.
\   if all four sides of the box are zero, say no.
\   say yes.
\
\ to-do:
\ to handle any wm-displaychange with a window a w-param:
\  w-param is the new display resolution, in pixels per inch
\  l-param's low-order word specifies the horizontal resolution of the screen.
\  l-param's high-order word specifies the vertical resolution of the screen.
\
\ to-do:
\ to handle any wm-ncpaint with a window a w-param and an l-param:
\  w-param is the handle to the update region of the window frame.
\
\ to-do:
\ to handle any wm-size with the window and the w-param and the l-param:
\   w-param possible values:
\     4:  some other window has been maximized; please hide.
\     3:  some other window has been restored to full size.
\     2:  the window has been maximized.
\     1:  the window has been minimized.
\     0:  the window has been resized, but neither minimized nor maximized.
\   the l-param's low-order word is the new width of the client area.
\   the l-param's high-order word is the new height of the client area.
\
\ to-do:
\ to handle any wm-sizing with the window and the w-param and the l-param:
\   w-param possible values:
\     1:  left edge is being adjusted
\     2:  right edge          ""
\     3:  top edge            ""
\     4:  top-left corner     ""
\     5:  top-right corner    ""
\     6:  bottom edge         ""
\     7:  bottom-left corner  ""
\     8:  bottom-right corner ""
\   the l-param is a box pointer with the drag rectangle.

to handle any wm-rbuttondblclk with a l-param:
  create an event.
  put "right double click" into the event's kind.
  if the alt key was down, set the event's alt flag.
  if the ctrl key was down, set the event's ctrl flag.
  if the shift key was down, set the event's shift flag.
  convert the l-param to the event's spot.
  enque the event.

to handle any wm-rbuttondown with a l-param:
  create an event.
  put "right click" into the event's kind.
  if the alt key was down, set the event's alt flag.
  if the ctrl key was down, set the event's ctrl flag.
  if the shift key was down, set the event's shift flag.
  convert the l-param to the event's spot.
  enque the event.

to handle any wm-setcursor:
  refresh the cursor.

to handle any wm-settingchange:
  create an event.
  put "setting change" into the event's kind.
  enque the event.

to handle any wm-syskeydown with a w-param and an l-param;
to handle any wm-keydown with a w-param and an l-param:
  put the w-param into a key.
  if the key with the l-param is any repeated escape or modifier key, exit.
  if the key is any wm-char key, exit.
  create an event.
  put "key down" into the event's kind.
  if the   alt key was down, set the event's alt flag.
  if the  ctrl key was down, set the event's ctrl flag.
  if the shift key was down, set the event's shift flag.
  put the key into the event's key.
  enque the event.

a handle is a number.

an hbitmap is a handle.

an hbrush is a handle.

an hdc is a handle.

the heap count is a number.

the heap pointer is a pointer.

a height is some twips.

a hex string is a string.

an hfont is a handle.

an hicon is a handle.

to hide the cursor:
  call "user32.dll" "ShowCursor" with 0 returning a number.
  if the number is less than 0, exit.
  repeat.

a horizontal line is a line.

an hour is 60 minutes.

an hpen is a handle.

an hrgn is a handle.

a hundred is 100 units.

the i-beam cursor is a cursor.

the i/o error is a string.

a iid is a uuid.

to imagine a box some twips by some other twips;
to make a box some twips by some other twips:
  put 0 into the box's left.
  put 0 into the box's top.
  put the twips into the box's right.
  put the other twips into the box's bottom.

to imagine a box some twips high by some other twips wide;
to make a box some twips high by some other twips wide:
  put 0 and 0 and the other twips and the twips into the box.

to imagine a box some twips smaller than another box;
to make a box some twips smaller than another box:
  put the other box into the box.
  indent the box by the twips divided by 2.

to imagine a box some twips smaller than another box on every side:
  put the other box into the box.
  indent the box by the twips.

to imagine a box some twips wide by some other twips high;
  to make a box some twips wide by some other twips high:
  put 0 and 0 and the twips and the other twips into the box.

to imagine a box with a left coord and a top coord and a right coord and a bottom coord;
to make a box with a left coord and a top coord and a right coord and a bottom coord:
  put the left coord and the top coord and the right coord and the bottom coord into the box.

to imagine a box with a spot and another spot;
to make a box with a spot and another spot:
  put the spot and the other spot into the box.

to imagine a dot about some twips wide;
to make a dot about some twips wide;
to make a dot some twips wide:
  make the dot the twips by the twips.

to imagine a dot between some twips and some other twips wide;
to make a dot between some twips and some other twips wide:
  pick some third twips between the twips and the other twips.
  make the dot the third twips wide.

to imagine an ellipse given a box;
to make an ellipse given a box:
  put the box into the ellipse's box.

to imagine an ellipse some twips by some other twips;
to make an ellipse some twips by some other twips:
  put 0 into the ellipse's left.
  put 0 into the ellipse's top.
  put the twips into the ellipse's right.
  put the other twips into the ellipse's bottom.

to imagine an ellipse with a left coord and a top coord and a right coord and a bottom coord;
to make an ellipse with a left coord and a top coord and a right coord and a bottom coord:
  put the left coord and the top coord and the right coord and the bottom coord into the ellipse.

to imagine an ellipse with a spot and another spot;
to make an ellipse with a spot and another spot:
  put the spot and the other spot into the ellipse.

to imagine a line across the bottom of a box;
to make a line across the bottom of a box;
to imagine a line along the bottom of a box;
to make a line along the bottom of a box:
  put the box's bottom line into the line.

to imagine a line across the top of a box;
to make a line across the top of a box;
to imagine a line along the top of a box;
to make a line along the top of a box:
  put the box's top line into the line.

to imagine a line in the middle of a box;
to make a line in the middle of a box;
to imagine a line across the middle of a box;
to make a line across the middle of a box;
to imagine a line in the center of a box;
to make a line in the center of a box;
to imagine a line across the center of a box;
to make a line across the center of a box:
  put the box's left into the line's start's x.
  put the box's right into the line's end's x.
  put the box's center's y into the line's start's y.
  put the box's center's y into the line's end's y.

to imagine a line some twips up from the bottom of a box;
to make a line some twips up from the bottom of a box:
  put the box's left into the line's start's x.
  put the box's right into the line's end's x.
  put the box's bottom minus the twips into the line's start's y.
  put the box's bottom minus the twips into the line's end's y.

to imagine a line with a spot and another spot;
to make a line with a spot and another spot:
  put the spot and the other spot into the line.

to imagine a line with an x coord and a y coord and another x coord and another y coord;
to make a line with an x coord and a y coord and another x coord and another y coord:
  put the x coord and the y coord and the other x coord and the other y coord into the line.

to imagine a roundy box from a box and a radius;
to make a roundy box from a box and a radius:
  put the box and the radius into the roundy box.

to imagine a roundy box some twips by some other twips;
to make a roundy box some twips by some other twips:
  put 0 into the roundy box's left.
  put 0 into the roundy box's top.
  put the twips into the roundy box's right.
  put the other twips into the roundy box's bottom.

to imagine a roundy box with a left coord and a top coord and a right coord and a bottom coord and a radius;
to make a roundy box with a left coord and a top coord and a right coord and a bottom coord and a radius:
  put the left coord and the top coord and the right coord and the bottom coord and the radius into the roundy box.

to imagine a roundy box with a spot and another spot and a radius;
to make a roundy box with a spot and another spot and a radius:
  put the spot and the other spot and the radius into the roundy box.

to imagine a spot with an x coord and a y coord;
to make a spot with an x coord and a y coord:
  put the x coord and the y coord into the spot.

an inch is 1440 twips.

to include a font in the current pdf:
  find a pdf object given the font's name and the pdf state's font index.
  if the pdf object is not nil, exit.
  create a font info given the font.
  convert the font info to pdf em units.
  \ stream
  put the actual data of the font into a buffer.
  convert the buffer to a nibble string.
  add a stream pdf object given "font stream".
  append the stream's number then " 0 obj" to the stream.
  append "<<" to the stream without advancing.
  append "/Filter /ASCIIHexDecode" to the stream without advancing.
  append " /Length " then the nibble string's length to the stream without advancing.
  append " /Length1 " then the buffer's length to the stream without advancing.
  append ">>" to the stream.
  append "stream" to the stream.
  append the nibble string to the stream.
  append "endstream" to the stream.
  append "endobj" to the stream.
  \ descriptor
  add a descriptor pdf object given "font descriptor".
  put "F" then the descriptor's number into a font name.
  put the font's name into a font base name.
  replace the space byte with the underscore byte in the font base name.
  append the descriptor's number then " 0 obj" to the descriptor.
  append "<<" to the descriptor.
  append "/Type /FontDescriptor" to the descriptor.
  append "/FontName /" then the font base name to the descriptor.
  append "/FontFile2 " then the stream's number then " 0 R" to the descriptor.
  append "/Flags " then the font info's flags to the descriptor.
  append "/FontBBox [" then the font info's font box then "]" to the descriptor.
  append "/Ascent " then the font info's ascent to the descriptor.
  append "/Descent " then the font info's descent to the descriptor.
  append "/CapHeight " then the font info's capheight to the descriptor.
  append "/ItalicAngle " then the font info's italicangle to the descriptor.
  append "/StemV " then the font info's stemv to the descriptor.
  append ">>" to the descriptor.
  append "endobj" to the descriptor.
  \ definition
  add a definition pdf object given "font definition".
  put the font name into the definition's font name.
  append the definition's number then " 0 obj" to the definition.
  append "<<" to the definition.
  append "/Type /Font" to the definition.
  append "/Subtype /TrueType" to the definition.
  append "/Name /" then the font name to the definition.
  append "/BaseFont /" then the font base name to the definition.
  append "/Encoding /WinAnsiEncoding" to the definition.
  append "/FontDescriptor " then the descriptor's number then " 0 R" to the definition.
  append "/FirstChar 0" to the definition.
  append "/LastChar 255" to the definition.
  put the font info's font widths into another buffer.
  append "/Widths [" to the definition.
  append the other buffer then "]" to the definition.
  append ">>" to the definition.
  append "endobj" to the definition.
  put the font info into the definition's font info.
  index the definition given the font's name and the pdf state's font index.

to include a font in a pdf object:
  if the pdf object is nil, exit.
  find a font pdf object given the font's name and the pdf state's font index.
  if the font pdf object is nil, exit.
  put "/" then the font pdf object's font name then " "
    then the font pdf object's number then " 0 R" into a string.
  find a string thing given the string and the pdf object's font strings.
  if the string thing is not nil, exit.
  create a new string thing given the string.
  append the new string thing to the pdf object's font strings.

to indent a box given a number:
  add the number to the box's left.
  add the number to the box's top.
  subtract the number from the box's right.
  subtract the number from the box's bottom.

an indent is an count.

an index is a thing with
  a bucket count,
  a first bucket and a last bucket.

to index a pointer given a string and an index:
\  if the index is nil, exit. \ to make compiler faster
  if the string's length is 0, exit.
  get a bucket given the string and the index.
  create a refer.
  append the refer to the bucket's refers.
  put the string into the refer's string.
  put the pointer into the refer's pointer.

to index a string in an index:
\  if the index is nil, exit. \ to make compiler faster
  index nil given the string and the index.

to initialize before run:
  call "user32.dll" "DisableProcessWindowsGhosting".
  call "kernel32.dll" "GetProcessHeap" returning the heap pointer.
  call "kernel32.dll" "LoadLibraryA" with "kernel32.dll"'s first
    returning a handle.
  if the handle is not 0,
    call "kernel32.dll" "GetProcAddress" with the handle
         and "HeapSetInformation"'s first returning a pointer.
  if the pointer is not nil,
    call the pointer with the heap pointer and 0 and 2's whereabouts and 4.

to initialize the canvases:
  initialize the screen canvas.
  initialize the memory canvas.
  put the memory canvas into the current canvas.

to initialize the cgi:
  call "kernel32.dll" "AllocConsole".
  call "kernel32.dll" "GetStdHandle" with -10 [std_input_handle]
    returning the stdin handle.
  call "kernel32.dll" "GetStdHandle" with -11 [std_output_handle]
    returning the stdout handle.

to initialize com:
  call "ole32.dll" "CoInitializeEx"
    with 0 and 2 [coinit_apartmentthreaded].

to initialize the cursors:
  initialize the cursors (arrow cursor).
  initialize the cursors (hand cursor).
  initialize the cursors (i-beam cursor).
  hide the cursor.

to initialize the cursors (arrow cursor):
  append $00000000000000004000000060000000 to an  xor-mask.
  append $70000000780000007C0000007E000000 to the xor-mask.
  append $7F0000007F8000007C0000006C000000 to the xor-mask.
  append $46000000060000000300000003000000 to the xor-mask.
  append $01800000018000000000000000000000 to the xor-mask.
  append $00 to the xor-mask given 48.
  append $7FFFFFFF3FFFFFFF1FFFFFFF0FFFFFFF to an  and-mask.
  append $07FFFFFF03FFFFFF01FFFFFF00FFFFFF to the and-mask.
  append $007FFFFF003FFFFF001FFFFF01FFFFFF to the and-mask.
  append $10FFFFFF30FFFFFF787FFFFFF87FFFFF to the and-mask.
  append $FC3FFFFFFC3FFFFFFE7FFFFFFFFFFFFF to the and-mask.
  append $FF to the and-mask given 48.
  call "user32.dll" "CreateCursor" with the module's handle
    and 0 and 0 and 32 and 32 and the and-mask's first
    and the xor-mask's first returning the arrow cursor.

to initialize the cursors (hand cursor):
  append $000000000180000019B0000019B00000 to an  xor-mask.
  append $0DB200000DB6000007F6000067FE0000 to the xor-mask.
  append $7FFC00003FFC00001FFC00001FF80000 to the xor-mask.
  append $0FF8000007F0000003F0000003F00000 to the xor-mask.
  append $00 to the xor-mask given 64.
  append $FE7FFFFFE40FFFFFC007FFFFC005FFFF to an  and-mask.
  append $E000FFFFE000FFFF9000FFFF0000FFFF to the and-mask.
  append $0001FFFF8001FFFFC001FFFFC003FFFF to the and-mask.
  append $E003FFFFF007FFFFF807FFFFF807FFFF to the and-mask.
  append $FF to the and-mask given 64.
  call "user32.dll" "CreateCursor" with the module's handle
    and 2 and 1 and 32 and 32 and the and-mask's first
    and the xor-mask's first returning the hand cursor.

to initialize the cursors (i-beam cursor):
  append $EE000000100000001000000010000000 to an  xor-mask.
  append $10000000100000001000000010000000 to the xor-mask.
  append $10000000100000001000000010000000 to the xor-mask.
  append $100000001000000010000000EE000000 to the xor-mask.
  append $00 to the xor-mask given 64.
  append $FF to an and-mask given 128.
  call "user32.dll" "CreateCursor" with the module's handle
    and 3 and 7 and 32 and 32 and the and-mask's first
    and the xor-mask's first returning the i-beam cursor.

to initialize the fonts:
  call "gdi32.dll" "GetStockObject" with 11 [ansi_fixed_font]
    returning the null hfont.
  get a string (command line).
  put the string in a command line.
  get the requested font given the command line.
  get the requested control font given the command line.
  get the requested editor font given the command line.
  put the requested font in the default font.
\  debug change given the current font and the requested font 
\    and "Initializing fonts.".
  put the requested font in the current font.
\  debug "The requested font is "  
\    then the requested font's name  
\    then " (" then the requested font's height then ");" 
\    then " the requested control font is "  
\    then the requested control font's name  
\    then " (" then the requested control font's height then ");" 
\    then " the requested editor font is "  
\    then the requested editor font's name  
\    then " (" then the requested editor font's height then ");" 
\    then " the default font is "  
\    then the default font's name  
\    then " (" then the default font's height then ").".
  \ stroked fonts below
  put 1/8 inch into the small letter height.
  put 1/4 inch into the medium letter height.
  put 1/2 inch into the large letter height.

to initialize gdi+:
  put 1 into a gdiplusstartupinput's gdiplusversion.
  call "gdiplus.dll" "GdiplusStartup" with the gptoken's whereabouts
    and the gdiplusstartupinput's whereabouts and 0.

to initialize the memory canvas:
  call "gdi32.dll" "CreateCompatibleDC" with the screen canvas returning the memory canvas.
  call "gdi32.dll" "GetCurrentObject" with the memory canvas
    and 7 [obj_bitmap] returning the saved memory hbitmap.
  call "gdi32.dll" "CreateCompatibleBitmap" with the screen canvas
    and the screen's pixel width and the screen's pixel height returning an hbitmap.
  call "gdi32.dll" "SelectObject" with the memory canvas and the hbitmap.
  normalize the memory canvas.

to initialize the module:
  \ temp path
  put 512 into a length.
  reassign the temp path's first given the length.
  call "kernel32.dll" "GetTempPathA" with the length
    and the temp path's first returning the length.
  put the temp path's first plus the length minus 1 into the temp path's last.
  null terminate the temp path.
  \ module handle
  call "kernel32.dll" "GetModuleHandleA" with 0 returning the module's handle.
  \ module name
  put 512 into the length.
  reassign the module's path's first given the length.
  call "kernel32.dll" "GetModuleFileNameA"
    with the module's handle and the module's path's first
    and the length returning the length.
  put the module's path's first plus the length minus 1
    into the module's path's last.
  if the module's path starts with "\\?\",
    remove leading bytes from the module's path given 4.
  lowercase the module's path.
  null terminate the module's path.
  \ module's other path pieces
  extract the module's name from the module's path.
  null terminate the module's name.
  extract the module's directory from the module's path.
  null terminate the module's directory.
  extract the module's root directory from the module's directory.
  null terminate the module's root directory.

to initialize the mouse:
  put 1 into the mouse's left button.
  put 2 into the mouse's right button.
  call "user32.dll" "GetSystemMetrics" with 23 [sm_swapbutton] returning a number.
  if the number is 0, exit.
  swap the mouse's left button with the mouse's right button.

to initialize the printer canvas:
  put a printdlgex's magnitude into the printdlgex's lstructsize.
  put the main window into the printdlgex's hwndowner.
  put 1288 [pd_returndc + pd_returndefault + pd_nopageenums] into the printdlgex's flags.
  put -1 [start_page_general] into the printdlgex's nstartpage.
  call "comdlg32.dll" "PrintDlgExA" with the printdlgex's whereabouts.
  call "kernel32.dll" "GlobalFree" with the printdlgex's hdevnames.
  put the printdlgex's hdevmode into the printer device mode handle.
  put the printdlgex's hdc into the printer canvas.

to initialize the screen:
  call "user32.dll" "GetSystemMetrics" with 0 [sm_cxscreen]
    returning the screen's maximum pixel width.
  call "user32.dll" "GetSystemMetrics" with 1 [sm_cyscreen]
    returning the screen's maximum pixel height.
  \   1000 pixels - 13/3 inches * 96 pixels/inch
  \ = 1000 pixels - 416 pixels = 584 pixels
  \ 584 pixels > (13/3 inches + 3/3 inches + 2/4 inches) * 96 pixels/inch
  \            >  416 pixels  +  96 pixels +  48 pixels
  \            >  560 pixels
  put 584 in a number called basic width.
  put 2 times the basic width in a number called double width.
  put the basic width in the screen's restored pixel width.
  if the screen's maximum pixel width is greater than the double width,
    put the screen's maximum pixel width divided by 2
    in the screen's restored pixel width.
  if the screen's maximum pixel width is not greater than the basic width,
    put the screen's maximum pixel width
    in the screen's restored pixel width.
  if the screen's maximum pixel height is greater than 100,
    put the screen's maximum pixel height minus 50
    in the screen's restored pixel height.
  if the screen's maximum pixel height is not greater than 100,
    put the screen's maximum pixel height divided by 2
    in the screen's restored pixel height.
  put 96 into the ppi. \ pixels per inch.
  put the tpi divided by the ppi into the tpp. \ twips per pixel.
  if full [screen] was requested,
    maximize the screen; exit.
  restore the screen.

to initialize the screen canvas:
   call "user32.dll" "GetWindowDC" with the main window returning the screen canvas.
   normalize the screen canvas.

to initialize a talker:
  \ clsid is short for class identifier.
  convert "{96749377-3391-11D2-9EE3-00C04F797396}" [clsid_spvoice] to a clsid.
  \ iid is short for interface identifier.
  convert "{6C44DF74-72B9-4992-A1EC-EF996E0422D4}" [iid_ispvoice] to an iid.
  call "ole32.dll" "CoCreateInstance"
    with the clsid's whereabouts and 0 and 7 [clsctx_all]
    and the iid's whereabouts and the talker's whereabouts
    returning a number.
  if the talker is not nil, exit.
  if the number is not 2147746132 [REGDB_E_CLASSNOTREG], exit.
  \ debug "The talker is not registered.".

to initialize the window:
  put a window class's magnitude into the window class' cbsize.
  put 40 [cs_owndc + cs_dblclks] into the window class' style.
  point the window class' lpfnwndproc to routine handle any message
    with a window a message number a w-param and a l-param.
  put the module's handle into the window class' hinstance.
  put the module's name's first into the window class' lpszclassname.
  call "user32.dll" "RegisterClassExA" with the window class's whereabouts.
  call "user32.dll" "CreateWindowExA" with 0 and the module's name's first
    and the module's name's first and -2147483648 [ws_popup] 
    and 0 and 0 and the screen's pixel width and the screen's pixel height
    and 0 and 0 and the module's handle and 0.
  resize the main window given the screen.
  call "user32.dll" "ShowWindow" with the main window and 1 [sw_shownormal].

to initialize a window placement:
  put the window placement's magnitude in the window placement's length.

to initialize winsock:
    call "ws2_32.dll" "WSAStartup" with 2 and a wsadata's whereabouts.

an input is an event.

to insert a number into some number things:
  if the number things are empty,
    append the number to the number things; exit.
  if the number is greater than the number things' last's number,
    append the number to the number things; exit.
  loop.
    get a number thing from the number things.
    if the number thing is nil,
      append the number to the number things; exit.
    if the number thing's number is the number, exit.
    if the number thing's number is greater than the number,
      create another number thing given the number;
      insert the other number thing into the number things
        before the number thing;
      exit.
  repeat.

to insert a spot into a polygon after a vertex:
  if the polygon is nil, exit.
  create another vertex given the spot.
  insert the other vertex into the polygon's vertices after the vertex.

to insert a string into another string before a byte#:
  if the string's length is 0, exit.
  privatize the byte#.
  limit the byte# to 1 and the other string's length plus 1.
  slap a substring on the other string. \ left side
  put the substring's first plus the byte# minus 2 into the substring's last.
  slap another substring on the other string. \ right side
  put the other substring's first plus the byte# minus 1 into the other substring's first.
  put the other string's length plus the string's length into a combined length.
  reassign a pointer given the combined length.
  put the pointer into a third substring's first.
  copy bytes from the substring's first to the third substring's first for the substring's length.
  add the substring's length to the third substring's first.
  copy bytes from the string's first to the third substring's first for the string's length.
  add the string's length to the third substring's first.
  copy bytes from the other substring's first to the third substring's first for the other substring's length.
  unassign the other string's first. \ don't use put a string into a string to prevent extra allocating and copying
  put the pointer into the other string's first.
  put the other string's first plus the combined length minus 1 into the other string's last.

to insert a thing into some things after another thing:
  if the thing is nil, exit.
  if the other thing is nil, prepend the thing to the things; exit.
  insert the thing into the things before the other thing's next.

to insert a thing into some things before another thing:
  if the thing is nil, exit.
  if the things are empty, append the thing to the things; exit.
  if the other thing is nil, append the thing to the things; exit.
  if the other thing is the things' first, prepend the thing to the things; exit.
  put the thing into a new thing.
  put the other thing into a previous thing.
  put the new thing into the previous thing's previous' next.
  put the previous thing into the new thing's next.
  put the previous thing's previous into the new thing's previous.
  put the new thing into the previous thing's previous.

to insert some things into some other things after a thing:
  if the thing is nil, prepend the things to the other things; exit.
  insert the things into the other things before the thing's next.

to insert some things into some other things before a thing:
  privatize the thing.
  loop.
    put the things' first into another thing.
    if the other thing is nil, exit.
    remove the other thing from the things.
    insert the other thing into the other things before the thing.
  repeat.

to insert a vertex into a polygon after another vertex:
  if the polygon is nil, exit.
  if the vertex is nil, exit.
  insert the vertex into the polygon's vertices after the other vertex.

to insert a vertex into a polygon at a spot:
  if the polygon is nil, exit.
  if the vertex is nil, exit.
  loop.
  get another vertex from the polygon's vertices.
  if the other vertex is nil, exit.
  if the other vertex's next is nil, exit.
  put the other vertex's spot and the other vertex's next's spot into a line.
  if the spot is not on the line, repeat.
  insert the vertex into the polygon's vertices after the other vertex.

to insert a vertex into a polygon before another vertex:
  if the polygon is nil, exit.
  if the vertex is nil, exit.
  insert the vertex into the polygon's vertices before the other vertex.

an interpretation is a string.

to intersect a box with another box giving a third box:
  \ boxes do not touch
  clear the third box.
  if the box's left is greater than the other box's right, exit.
  if the box's top is greater than the other box's bottom, exit.
  if the box's right is less than the other box's left, exit.
  if the box's bottom is less than the other box's top, exit.
  \ boxes touch
  put the box into the third box.
  if the box's left is less than the other box's left,
    put the other box's left into the third box's left.
  if the box's top is less than the other box's top,
    put the other box's top into the third box's top.
  if the box's right is greater than the other box's right,
    put the other box's right into the third box's right.
  if the box's bottom is greater than the other box's bottom,
    put the other box's bottom into the third box's bottom.

to invert a flag:
  if the flag is yes, put no into the flag; exit.
  put yes into the flag.

a in_addr is a record with
  a byte called s_b1,
  a byte called s_b2,
  a byte called s_b3,
  a byte called s_b4,
  a wyrd [unsigned] called  s_w1 at the s_b1,
  a wyrd [unsigned] called s_w2 at the s_b3,
  a number called s_addr at the s_b1.

an ip address has
  a number,
  a string.

an istream is a pointer to an istream object.

an istream object is a record with an istream vtable called vtable.

an istream vtable is a pointer to an istream vtable record.

an istream vtable record is a record with
  \ iunknown
  a pointer called queryinterface,
  a pointer called addref,
  a pointer called release, \ function(this:istream):number; stdcall;
  \ istream
  a pointer called read,
  a pointer called write,
  a pointer called seek,
  a pointer called setsize,
  a pointer called copyto,
  a pointer called commit,
  a pointer called revert,
  a pointer called lockregion,
  a pointer called unlockregion,
  a pointer called stat,
  a pointer called clone.

an item has
  a kind,
  a path, a directory, a designator, an extension,
  a size,
  a win32finddata and a handle.

a kilobyte is 1024 units.

a kind is a string.

a l-param is a number.

a landscape sheet is a sheet.

the large letter height is a letter height.

the largest number is 2147483647.

the largest square is a number equal to 2147395600.  \ 46,340 * 46,340

the largest square root is a number equal to 46340.

an lcm is a number.

a left click is an input.

a left is some twips.

a length is some twips.

a letter height is some twips. \ indicates actual height of a typical uppercase letter

the lexicon is a thing with an index.

a library is a string. \ the name of a .dll or similar file.

a library procedure is a string. \ the name of a procedure in a .dll or similar file.

to limit a box to another box:
  limit the box's left to the other box's left and the other box's right.
  limit the box's top to the other box's top and the other box's bottom.
  limit the box's right to the other box's left and the other box's right.
  limit the box's bottom to the other box's top and the other box's bottom.

to limit a number to another number and a third number:
  if the number is less than the other number,
    put the other number into the number; exit.
  if the number is greater than the third number,
    put the third number into the number.

to limit a spot to a box:
  if the spot's x is less than the box's left, put the box's left into the spot's x.
  if the spot's y is less than the box's top, put the box's top into the spot's y.
  if the spot's x is greater than the box's right, put the box's right into the spot's x.
  if the spot's y is greater than the box's bottom, put the box's bottom into the spot's y.

a line has a start spot and an end spot.

to load a font source returning a font resource:
  \ to-do:
  \ put 1 in a number. \ the number of fonts in the resource.
  \ use the number's whereabouts in the following call:
  call "gdi32.dll" "AddFontMemResourceEx"
    with the font source's first
    and the font source's length
    and 0 and a number's whereabouts
    returning the font resource.

to load the lexicon:
  if the lexicon is not nil, exit.
  extract a directory from the module's path.
  loop.
    if the directory is blank, exit.
    put the directory then "lexicon\" into a path.
    if the path is in the file system,
      load the lexicon given the path; exit.
    extract the directory from the directory.
  repeat.

to load the lexicon given a buffer:
  if the lexicon is nil, create the lexicon.
  slap a rider on the buffer.
  loop.
    move the rider (index lexicon rules).
    if the rider's token is blank, exit.
    index the rider's token in the lexicon's index.
  repeat.

to load the lexicon given a path:
  get an item from the path.
  if the item is not found, exit.
  if the item's kind is not "file", repeat.
  read the item's path into a buffer.
  if the i/o error is not blank, repeat.
  load the lexicon given the buffer.
  repeat.

to load a path into a buffer;
to read a path into a buffer:
  put the largest number in a size called max bytes.
  read the path into the buffer given the max bytes.

to load a path into a picture:
to read a path into a picture:
  read the path into a buffer.
  if the i/o error is not blank, void the picture; exit.
  create the picture given the buffer.

to localize a box given a pair:
  privatize the pair.
  negate the pair.
  move the box given the pair.

to localize a spot given a pair:
  privatize the pair.
  negate the pair.
  move the spot given the pair.

to lock a gpbitmap given a bitmapdata (24-bit rgb):
  put the gpbitmap's gprect into a gprect.
  call "gdiplus.dll" "GdipBitmapLockBits" with the gpbitmap
    and the gprect's whereabouts and 3 [imagelockmoderead or imagelockmodewrite]
    and 137224 [pixelformat24bpprgb] and the bitmapdata's whereabouts.

a logbrush has
  a number called lbstyle,
  a colorref called lbcolor,
  a number called lbhatch.

to lowercase the character under a finger and put it into a string:
  if the finger is nil, exit.
  put the finger's target into the string.
  lowercase the string.

to lowercase a string:
  slap a substring on the string.
  loop.
    if the substring is blank, exit.
    lowercase the substring's first's target.
    add 1 to the substring's first.
  repeat.

the main window is a window.

to make a ratio pair given a box and another box:
  put the box's x-extent into the ratio pair's ratio's numerator.
  put the other box's x-extent into the ratio pair's ratio's denominator.
  put the box's y-extent into the ratio pair's other ratio's numerator.
  put the other box's y-extent into the ratio pair's other ratio's denominator.

to make sure the osmosian font is loaded:
  if the osmosian font is loaded, exit.
  load the osmosian font source returning the osmosian font resource.

a margin is a number.

to mask inside a box:
  create an hrgn given the box.
  mask inside the hrgn.
  destroy the hrgn.

to mask inside an ellipse:
  create an hrgn given the ellipse.
  mask inside the hrgn.
  destroy the hrgn.

to mask inside an hrgn:
  call "gdi32.dll" "ExtSelectClipRgn"
    with the current canvas and the hrgn and 4 [rgn_diff].

to mask inside a polygon:
  create an hrgn given the polygon.
  mask inside the hrgn.
  destroy the hrgn.

to mask inside a roundy box:
  create an hrgn given the roundy box.
  mask inside the hrgn.
  destroy the hrgn.

a mask is a hex string.

to mask only inside a box:
  unmask everything.
  mask inside the box.

to mask only inside an ellipse:
  unmask everything.
  mask inside the ellipse.

to mask only inside a polygon:
  unmask everything.
  mask inside the polygon.

to mask only inside a roundy box:
  unmask everything.
  mask inside the roundy box.

to mask only outside a box:
  unmask everything.
  mask outside the box.

to mask only outside an ellipse:
  unmask everything.
  mask outside the ellipse.

to mask only outside a polygon:
  unmask everything.
  mask outside the polygon.

to mask only outside a roundy box:
  unmask everything.
  mask outside the roundy box.

to mask outside a box:
  create an hrgn given the box.
  mask outside the hrgn.
  destroy the hrgn.

to mask outside an ellipse:
  create an hrgn given the ellipse.
  mask outside the hrgn.
  destroy the hrgn.

to mask outside an hrgn:
  call "gdi32.dll" "ExtSelectClipRgn" with the current canvas and the hrgn and 1 [rgn_and].

to mask outside a polygon:
  create an hrgn given the polygon.
  mask outside the hrgn.
  destroy the hrgn.

to mask outside a roundy box:
  create an hrgn given the roundy box.
  mask outside the hrgn.
  destroy the hrgn.

to maximize a screen:
  resize the screen given the screen's maximum pixel width
    and the screen's maximum pixel height.

the medium letter height is a letter height.

a megabyte is 1024 kilobytes.

the memory canvas is a canvas.

a message is a string.

a million is 1000 thousands.

a millisecond is a number.

to minimize a window:
  call "user32.dll" "ShowWindow" with the window and 6 [sw_minimize].

a minute is 60 seconds.

to mirror the gpbitmap in a picture:
  if the picture is nil, exit.
  reverse the picture's mirror flag.
  mirror the picture's gpbitmap.

to mirror a gpimage:
  call "gdiplus.dll" "GdipImageRotateFlip" with the gpimage and 4 [rotatenoneflipx].

to mirror a picture:
  if the picture is nil, exit.
  put the picture's box's center's x minus the picture's uncropped box's center's x into a pair's x.
  multiply the pair's x by 2.
  move the picture's uncropped box given the pair.
  mirror the gpbitmap in the picture.

to mirror a polygon:
  if the polygon is nil, exit.
  put the polygon's box into a box.
  loop.
    get a vertex from the polygon's vertices.
    if the vertex is nil, exit.
    subtract the box's left from the vertex's x.
    put the box's right minus the vertex's x into the vertex's x.
  repeat.

a mixed has a whole number and a ratio.

the module has
  a handle,
  a path,
  a directory,
  a root directory, \ one up from the directory that exe is run from
  a file name w/o extension called name.

the mouse has
  a key called left button,
  a key called right button.

a mouse wyrd is a wyrd. \ with flags for which mouse buttons are down, plus Ctrl and Shift.

to move a box to the bottom of another box:
  move the box down the other box's bottom minus the box's bottom.

to move a box down some twips:
  move the box given 0 and the twips.

to move a box given a pair:
  move the box given the pair's x and the pair's y.

to move a box given a ratio pair and a spot:
  get a difference between the box's left-top and the spot.
  put the difference into another difference.
  scale the other difference given the ratio pair.
  subtract the difference from the other difference.
  move the box given the other difference.

to move a box given some x twips and some y twips:
  add the x twips to the box's left.
  add the y twips to the box's top.
  add the x twips to the box's right.
  add the y twips to the box's bottom.

to move a box left to a coord:
  move the box left the box's left minus the coord.

to move a box to the left side of another box;
to move a box to the left of another box:
  move the box left the box's left minus the other box's left.

to move a box left some twips:
  move the box given - the twips and 0.

to move a box to the right side of another box;
to move a box to the right of another box:
  move the box right the other box's right minus the box's right.

to move a box right some twips:
  move the box given the twips and 0.

to move a box to a spot:
  get a difference between the spot and the box's left-top.
  move the box given the difference.

to move a box to the top left corner of another box:
  move the box to the other box's left-top.

to move a box to the top of another box:
  move the box up the box's top minus the other box's top.

to move a box up some twips:
  move the box given 0 and - the twips.

to move an ellipse down some twips:
  move the ellipse given 0 and the twips.

to move an ellipse given a pair:
  move the ellipse given the pair's x and the pair's y.

to move an ellipse given some x twips and some y twips:
  move the ellipse's box given the x twips and the y twips.

to move an ellipse left some twips:
  move the ellipse given - the twips and 0.

to move an ellipse right some twips:
  move the ellipse given the twips and 0.

to move an ellipse to a spot:
  get a difference between the spot and the ellipse's left-top.
  move the ellipse given the difference.

to move an ellipse up some twips:
  move the ellipse given 0 and - the twips.

to move a finger over a number:
  if the finger is nil, exit.
  add 1 to the finger.

to move a line down one pixel:
  move the line down the tpp.

to move a line down some twips:
  move the line given 0 and the twips.

to move a line given a pair:
  move the line given the pair's x and the pair's y.

to move a line given some x twips and some y twips:
  add the x twips to the line's start's x.
  add the y twips to the line's start's y.
  add the x twips to the line's end's x.
  add the y twips to the line's end's y.

to move a line left some twips:
  move the line given - the twips and 0.

to move a line to a spot:
  get a difference between the spot and the line's start.
  move the line given the difference.

to move a line some twips to the right;
to move a line right some twips:
  move the line given the twips and 0.

to move a line up one pixel:
  move the line up the tpp.

to move a line up some twips:
  move the line given 0 and - the twips.

to move a picture down some twips:
  move the picture given 0 and the twips.

to move a picture given a pair:
  move the picture given the pair's x and the pair's y.

to move a picture given some x twips and some y twips:
  if the picture is nil, exit.
  move the picture's box given the x twips and the y twips.
  move the picture's uncropped box given the x twips and the y twips.

to move a picture left some twips:
  move the picture given - the twips and 0.

to move a picture right some twips:
  move the picture given the twips and 0.

to move a picture to a spot:
  if the picture is nil, exit.
  get a difference between the spot and the picture's left-top.
  move the picture given the difference.

to move a picture up some twips:
  move the picture given 0 and - the twips.

to move a polygon down some twips:
  move the polygon given 0 and the twips.

to move a polygon given a pair:
  move the polygon given the pair's x and the pair's y.

to move a polygon given some x twips and some y twips:
  if the polygon is nil, exit.
  loop.
    get a vertex from the polygon's vertices.
    if the vertex is nil, exit.
    move the vertex given the x twips and the y twips.
  repeat.

to move a polygon left some twips:
  move the polygon given - the twips and 0.

to move a polygon left some twips and down some other twips:
  move the polygon left the twips.
  move the polygon down the other twips.

to move a polygon left some twips and up some other twips:
  move the polygon left the twips.
  move the polygon up the other twips.

to move a polygon right some twips:
  move the polygon given the twips and 0.

to move a polygon right some twips and down some other twips:
  move the polygon right the twips.
  move the polygon down the other twips.

to move a polygon right some twips and up some other twips:
  move the polygon right the twips.
  move the polygon up the other twips.

to move a polygon to a spot:
  if the polygon is nil, exit.
  get a difference between the spot and the polygon's box's left-top.
  move the polygon given the difference.

to move a polygon up some twips:
  move the polygon given 0 and - the twips.

to move a rider (index lexicon rules):
  skip any leading noise in the rider's source.
  position the rider's token on the rider's source.
  loop.
    if the rider's source is blank, exit.
    bump the rider.
    if the rider's source's first's target is noise, exit.
  repeat.

to move a rider (quoted string rules):
  bump the rider.
  if the rider's source is blank, exit.
  if the rider's source's first's target is not the double-quote byte, repeat.
  if the rider's source's first is the rider's source's last, bump the rider; exit.
  bump the rider.
  if the rider's source's first's target is not the double-quote byte, exit.
  repeat.

to move a rider (spell checking rules):
  skip any non-alphanumeric bytes in the rider's source.
  position the rider's token on the rider's source.
  loop.
    if the rider's source is blank, exit.
    bump the rider.
    if the rider's source is on any contraction, bump the rider; repeat.
    if the rider's source's first's target is not alphanumeric, exit.
  repeat.

to move a rider (text file rules):
  position the rider's token on the rider's source.
  loop.
    if the rider's source is blank, exit.
    if the rider's source's first's target is the return byte, bump the rider; break.
    if the rider's source's first's target is the linefeed byte, bump the rider; exit. \ *dahn new to handle lines terminated by just linefeed
    bump the rider.
  repeat.
  if the rider's source is blank, exit.
  if the rider's source's first's target is the linefeed byte,
    add 1 to the rider's source's first.

to move a rider (word wrapping rules):
  position the rider's token on the rider's source.
  if the rider's source is blank, exit.
  if the rider's source's first's target is the return byte, bump the rider; exit.
  loop.
  if the rider's source is blank, exit.
  if the rider's source's first's target is the return byte, exit.
  if the rider's token is blank, bump the rider; repeat.
  if the rider's source's first's target is like the rider's token's last's target, bump the rider; repeat.

to move a rider given a box (word wrapping rules):
  skip any leading linefeed byte in the rider's source.
  position the rider's token on the rider's source.
  if the rider's source is blank, exit.
  slap another rider on the rider.
  loop.
    if the rider's source is blank, exit.
    move the other rider (word wrapping rules).
    if the other rider's token is blank, exit.
    if the other rider's token's first's target is the return byte,
      bump the rider; exit.
    if the other rider's token's first's target is whitespace,
      bump the rider by the other rider's token's length; repeat.
    if the rider's token is blank,
      bump the rider by the other rider's token's length; repeat.
    if the rider's token then the other rider's token is wider than the box, exit.
    bump the rider by the other rider's token's length.
  repeat.

to move a rider given a separator byte:
  position the rider's token on the rider's source.
  loop.
    if the rider's source is blank, exit.
    if the rider's source's first's target is the separator byte,
      add 1 to the rider's source's first; exit.
    bump the rider.
  repeat.

to move a spot to another spot:
  put the other spot into the spot.

to move a spot given a pair:
  move the spot given the pair's x and the pair's y.

to move a spot given some x twips and some y twips:
  add the x twips to the spot's x.
  add the y twips to the spot's y.

to move a spot some twips down;
to move a spot down some twips:
  move the spot given 0 and the twips.

to move a spot some twips to the left;
to move a spot some twips left;
to move a spot left some twips:
  move the spot given - the twips and 0.

to move a spot some twips right;
to move a spot some twips to the right;
to move a spot right some twips:
  move the spot given the twips and 0.

to move a spot some twips to the right and some other twips down;
to move a spot some twips right and some other twips down:
  add the twips to the spot's x.
  add the other twips to the spot's y.

to move a spot some twips up;
to move a spot up some twips:
  move the spot given 0 and - the twips.

to move a substring given a number:
  add the number to the substring's first.
  add the number to the substring's last.

to move a thing from some things to some other things:
  if the thing is nil, exit.
  privatize the thing.
  remove the thing from the things.
  append the thing to the other things.

to move some things to some other things:
  put the things' first into the other things' first.
  put the things' last into the other things' last.
  clear the things.

to move a vertex down some twips:
  move the vertex given 0 and the twips.

to move a vertex given a pair:
  move the vertex given the pair's x and the pair's y.

to move a vertex given some x twips and some y twips:
  if the vertex is nil, exit.
  add the x twips to the vertex's x.
  add the y twips to the vertex's y.

to move a vertex left some twips:
  move the vertex given - the twips and 0.

to move a vertex right some twips:
  move the vertex given the twips and 0.

to move a vertex to a spot:
  if the vertex is nil, exit.
  put the spot into the vertex's spot.

to move a vertex up some twips:
  move the vertex given 0 and - the twips.

to move a window left:
  call "user32.dll" "GetWindowRect" with the main window and a box's whereabouts.
  subtract the screen's pixel width from the box's left.
  call "user32.dll" "MoveWindow"
    with the window and the box's left and the box's top
    and the screen's pixel width and the screen's pixel height and 1.

to move a window right:
  call "user32.dll" "GetWindowRect" with the main window and a box's whereabouts.
  add the screen's pixel width to the box's left.
  call "user32.dll" "MoveWindow" with the window
    and the box's left and the box's top
    and the screen's pixel width and the screen's pixel height and 1.

a ms is 1 millisecond.

a msg is a record with
  a window called hwnd,
  a number called message,
  a w-param called wparam,
  a l-param called lparam,
  a number called time,
  a spot called pt.

a multiple is a number.

to multiply a number by another number returning a number called result:
  privatize the number.
  multiply the number by the other number.
  put the number in the result.

to multiply a number by a ratio;
to scale a number given a ratio:
  if the ratio's denominator is 0, exit.
  call "kernel32.dll" "MulDiv" with the number and the ratio's numerator and the ratio's denominator returning the number.

to multiply a pair by another pair:
  multiply the pair's x by the other pair's x.
  multiply the pair's y by the other pair's y.

to multiply a pair by a number:
  multiply the pair's x by the number.
  multiply the pair's y by the number.

to multiply a pair by a number and another number:
  multiply the pair's x by the number.
  multiply the pair's y by the other number.

to multiply a pointer by a number;
to multiply a number by another number:
  intel $8B8508000000. \ mov eax,[ebp+8] \ the number
  intel $8B00.         \ mov eax,[eax]
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the other number
  intel $F72B.         \ mul [ebx] \ means mul eax,[ebx] but is weird form
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the number
  intel $8903.         \ mov [ebx],eax

to multiply a ratio by a number:
  multiply the ratio's numerator by the number.
  reduce the ratio.

a name is a string.

to negate a number:
  intel $8B8508000000. \ mov eax,[ebp+8] \ the number
  intel $F718.         \ neg [eax]

to negate a pair:
  negate the pair's x.
  negate the pair's y.

to negate a ratio:
  negate the ratio's numerator.

a nibble is a byte. \ only low order 4 bits are valid

a nibble string is a string. \ $0010A0...

to non-destructively resize a picture given a ratio pair:
  if the picture is nil, exit.
  move the picture's uncropped box given the ratio pair and the picture's box's left-top.
  resize the picture's uncropped box given the ratio pair.
  resize the picture's box given the ratio pair.
  if the picture's right is less than the picture's left, mirror the gpbitmap in the picture.
  if the picture's bottom is less than the picture's top, flip the gpbitmap in the picture.

to non-destructively resize a picture given a twip pair:
  if the picture is nil, exit.
  put the picture's box into a box.
  resize the box given the twip pair.
  make a ratio pair given the box and the picture's box.
  non-destructively resize the picture given the ratio pair.

to normalize an angle:
  divide the angle by 3600 giving a quotient and the angle.

to normalize a box:
  if the box's right is less than the box's left, swap the box's left with the box's right.
  if the box's bottom is less than the box's top, swap the box's top with the box's bottom.

to normalize a canvas:
  call "gdi32.dll" "SetGraphicsMode" with the canvas and 2 [gm_advanced].
  call "gdi32.dll" "SetBkMode" with the canvas and 1 [transparent].
  call "gdi32.dll" "SetMapMode" with the canvas and 8 [mm_anisotropic].
  call "gdi32.dll" "SetViewportOrgEx" with the canvas and 0 and 0 and nil.
  call "gdi32.dll" "SetViewportExtEx" with the canvas and the ppi and the ppi and nil.
  call "gdi32.dll" "SetWindowOrgEx" with the canvas and 0 and 0 and nil.
  call "gdi32.dll" "SetWindowExtEx" with the canvas and the tpi and the tpi and nil.

to normalize an ellipse:
  normalize the ellipse's box.

to normalize a horizontal line:
  if the line's end is less than the line's start,
    swap the line's end with the line's start.

to normalize a picture:
  if the picture is nil, exit.
  normalize the picture's box.
  normalize the picture's uncropped box.

to normalize a ratio and another ratio:
  reduce the ratio.
  reduce the other ratio.
  get a lcm given the ratio's denominator and the other ratio's denominator.
  call "kernel32.dll" "MulDiv" with the ratio's numerator and the lcm
    and the ratio's denominator returning a number.
  put the number in the ratio's numerator.
  put the lcm into the ratio's denominator.
  call "kernel32.dll" "MulDiv" with the other ratio's numerator and the lcm
    and the other ratio's denominator returning the number.
  put the number in the other ratio's numerator.
  put the lcm into the other ratio's denominator.

to normalize a vertical line:
  if the line's end is less than the line's start, swap the line's end with the line's start.

the null hbrush is an hbrush.

the null hfont is an hfont.

the null hpen is an hpen.

to null terminate a string:
  put the string's length into a saved length.
  reassign the string's first given the saved length plus 1.
  put the string's first plus the saved length minus 1 into the string's last.
  put the string's last plus 1 into a byte pointer.
  put the null byte into the byte pointer's target.

to null terminate a wide string:
  put the wide string's length into a saved length.
  reassign the wide string's first given the saved length plus 2.
  put the wide string's first plus the saved length minus 1 into the wide string's last.

a number has
  a first byte,
  a second byte,
  a third byte,
  a fourth byte,
  a low wyrd at the first byte,
  a high wyrd at the third byte.

a number pointer is a pointer to a number.

a number thing is a thing with a number.

an offset is a number.

to open a file given a path:
  clear the i/o error.
  extract a directory from the path.
  if the directory is not in the file system,
    put "Directory '" then the directory then "'"
    then " doesn't exist." into the i/o error; exit.
  set the path to read-write mode.
  privatize the path.
  null terminate the path.
  call "kernel32.dll" "CreateFileA" with the path's first
    and -1073741824 [generic_read+generic_write] and 0 and 0 and 4 [open_always] 
    and -2147483520 [file_flag_write_through or file_attribute_normal] and 0
    returning the file.
  if the file is -1 [invalid_handle_value],
    put "Error opening file '" then the path then "'." into the i/o error; exit.

to open a file given a path and some milliseconds:
  start a timer.
  loop.
    open the file given the path.
    if the i/o error is blank, exit.
    if the timer's ticks are greater than the milliseconds, exit.
  repeat.

an operation is a string.

an origin is a spot.

the osmosian font resource is a font resource.

the osmosian font source is a font source equal to $00010000000B0080000300304F532F32BB41B2760000013800000056636D6170E2B9EDE9000005440000032867617370FFFF000300008BDC00000008676C79664268E45D00000A4800007A6868656164E4394351000000BC00000036686865610D54057A000000F400000024686D747868C6405100000190000003B46C6F6361A327C3220000086C000001DC6D6178700559021500000118000000206E616D659DA64946000084B0000004FA706F73745544E6B3000089AC00000230000100000001000091EDF0B35F0F3CF5000B080000000000BF91DAB800000000C0031E39FFBAFE4805CC071A00000009000100000000000000010000073EFE4E0043063D0005000105CC0001000000000000000000000000000000ED0001000000ED00DF00070104000400020010002F00420000040C000000020001000102FB019000050008059A05330000011B059A0533000003D100660212000002000000000000000000A00002AF500078FB0000000000000000484C20200040002025CA05D3FE510133073E01B26000019FDFF70000000003E8007F00C8000000C8000001900000025800CE02BC007804B0002F03B6004603E8005D04B00050019000780284006402840064046D0022046700400190005703E80064019000640320006B03E8003603E8006B03E8003503E8003203E8002803E8003C03E8006403E8006C03E8007203E8005A01D400640190005604B0002E04B0005704A9002104B000C804B00064043F002803E8003B0460003C03AC00050460000E03C000640467002104740011039E0006039F000D03D4004B03CD004A047B0022044C003504B0005603E80064051400490403004203B600350453000D038C0036037700280535001403DB001B03690028041D00210258004903200022025800490384004204A9004A0258004303E8002F03EF005A0320002803D400280363002F0334002103E1004303A5005001980064021C000D033B00190161005405350064038A0050049500430341002803D7004302AF0038033B002102A1001E0377003603200014041700360348001B031300140409001B02580042019000490258004E03E8005D043F0028043F0028046000360460000E044C003504B00056038C003603E8002203E8003203E8002F03E8002F03E8002F03E8002F03200028036300220363002F0363002F0363002F0190FFBA0190FFD90190FFD90190FFBE038A0020049500360495004304950043049500430495004303770036037700360377003603770036034F0042025800490320007E046D00210438007802580063049C0078041D008505CB005D0517004904F3006A02AE006B02E4005E04EC0043051400560495005E0564005D048F006404590042048F0042042B003603AC006403B3006B048F005004B0006403E800720319008B0320006A051E001A046C007E04B0005004B000C80190007104600042044C007203E8006404B0005604B0005104B0007804B0006B02FF0042043F0036043F003D04B00056051A0067042B002F04670056063D008C0320005D02C3000701ED007802010078046700500453006B031300140369002804B0005D0438005602BC006402BC006403E5007F0190002F01F400560320005D053C0069043F00280460000E043F00280460000E0460000E039E002F039E001A039E0006039E002E04B0005604B0005D04B0005D038C0036038C0036038C0036019000780320005703E8006502BC007801F4004902C3004903B60035033B0021041D00210409001B025800DC0453004A041D0064036900280313001403A50050038B005704380057039F005002580071032000A0032000AE04B0006A0507006B0578007F03E8007904B0004A000000020001000000000014000300010000011A0000010600000100000000000000010200000002000000000000000000000000000000010000030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F505152535455565758595A5B5C5D5E5F60610062636465666768696A6B6C6D6E6F707172737475767778797A7B7C7D7E7F808182838485868788898A8B8C8D8E8F909192939495969798999A009B9C9D9E9FA0A1A2A3A4A5A6A7A8A9AA03ABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBD0000BEBFC0C1C2C3C4C5C6C7C8C9CACBCCCD00CECFD0D1D2D3D4000000D5D60000D70004020E00000048004000050008007E00FF0131015301610178017E019202C702DA02DC037E2014201A201E202220262030203A204420AC2122212622022206220F22122215221A221E222B22482260226525CAFFFF0000002000A00131015201600178017D019202C602DA02DC037E20132018201C2020202620302039204420AC2122212622022206220F221122152219221E222B22482260226425CAFFFFFFE30000FFA1FF5CFF78FF41FF5DFF130000FDFBFDF8FCA0E09D000000000000E084E092E083E076E00FDF6ADF78DE96DEA1DE8B0000DEA50000DE74DE70DE5EDE2FDE30DAED00010000004600000000000000000000000000F8000000000000000000F200F600FA000000000000000000000000000000000000000000EA000000EA0000000000000000000000000000000300A20084008500EB009600DC0086008E008B009C00A800A30010008A00EC0083009300E600E7008D0097008800BF00D600E5009D00A900E900E800EA00A100AB00C500C300AC006200630090006400C7006500C400C600CB00C800C900CA00DD006600CE00CC00CD00AD006700E4009100D100CF00D0006800DF00E10089006A0069006B006D006C006E009F006F0071007000720073007500740076007700DE0078007A0079007B007D007C00B600A0007F007E0080008100E000E200B800D300D700B400B500C000B200B300C1008200BE0087009900E300BF00A40000004E004E004E004E007E00AC011A01A0021C028202A202E0031C037803AE03D203F2040E043A04B404EA054805A8060C068E06FA073807C60844087608AE08E80928096209C00A5C0ADC0B600BBE0C380CAC0CFC0D8E0DFE0E380E7C0ED60F1A0F9C0FFE113011941232134E13B013EC1446149E152C159815DA162C165A168616B416E8170617241794180E186A18D0194619A41A461AB21AE41B281B8C1BB41C2E1C741CE41D401DB21DEA1E3E1E881ECE1F201F8C1FD8201E207820CC20EC213E217821842190219C21A821B421C021CC21D821E421F021FC220822142220222C223822442250225C226822762282228E229A22A622B222BE22CA22D622E222EE22FA233A237023B6244824D024F0255425C2265C26DC273C275C278627E2284428EA295E29B029FA2A442A9A2AE22B362B8A2BC82C102C502C942CFA2D782DF82E562E842EA82EF22F5C2FC43010306430B830E430F030FC3108318631FA32123228327032B832DC32FE3336339833A433B033F63456348234AE34FA3518353A3582362A36363642364E365A36663672367E368A369636A236AE36BA36C636D236DE3702372A3762379637C037EA37F63802380E381A384A38B439343940394C399A39F63A1C3A643A943AD23B183B943C103CA83D163D340002007F0000036B0560001E003400001333173317053332151114071507111615062B01262722273534271127113617111711161D011617143B01113735363D0127232527BF2C2C3420011C24C00C0810193BE02AE67C140C080878080C1EF21C98080C2828FEC420056008080454FEE0AD93202CFE3C15175C0B0544CCAD9301142C01804088FED42CFEE093AD8C08040801D82C1493ADF0040408000200CEFF8F017105FB0011001C000001161511071517150623263D01273537113613161D01062322273437340131401008083840081008294008383B191405FB0732FE367DA172E5390732E5728F7D01DC39FA74083860405C10284C00000000020078030602300582000D001B000013321714071106232635112734370532170711062326351126353437D03F09140838400C44012C3F090C08384014440582601A16FE5440083801B4302F25046030FE704008380198161A2F250002002FFFFA048F04BA0047005000000116150714172127353633161D01173325321714230723151F013215062B0122271517150623223522272623161D010623263D013427232635363B01352635232635363B01263534131733321735262735014F40041C0104040838400424010C270D74CC1C20BA580838201C86200838440818714F2008384028E8400838C830D8400838B418BC38103C800C0C04BA0D27407B6D309440083894301440441010DC0F40400314AF204064E31CE32960400838604BCD083840048622083840767A6CFE24B418047F2D1C00000000030046FFE60346056000470052005C000001161D01071536331615142706071536333437161D01140706072207060F01161706072637222707060F012635343F0136352627060F022227353635363736333736373536333403363734333735060706150517333732373237220701E2400840287589272D537D1C40240C140E161622501403165938280903444162184093801C0C241D6073183B19182C2847192040280A1AF488380C041C406401402404480B0906122D5705600838202C38282338390C2408D0240701083840153B0F3D3C184070958A3F0828964C341C1804083839175C0A067A962F4233045C60502C5A3258143F05847409FD1456490804B01D23713328B07C30241C0005005D002E03A1056200190028003100450053000001161507060703072207150623263D01363F011237323736353605321F0115062326272635343734370716333637352306070133321716171514070623222F01353633263534171514071715071517343735262702CD402C693F5C4807090838400A263C4454061A5C17FE956A1E08414F5448382C6814201C15132C150F01CC20315F310334153BA8180C0B0908840C0408242C053305620838A4A4ECFEB0B84434400838404D57A0011CE844945044DC4C2C40D808382C4441234434DC28213F28063EFE6C40352B202557604C2C4044153F3E76081D0704102C24081848100C1C000300500006044005C2002E0035004400000133321F0115061507161F01333637363316151407060F01161506232235272307140723222F013637363F010335361715173337352603140F011514173332373637262F010138203A8A2420382C2C4404DE4E2A2240403BBD50280838401404B848209F350440486117146C088C2804081A0E7C4C38341781252744301005C2885C806D437462B29CB1532C083829274696406E5A405C5C680C0C704CCE7AA8402002182040B404C8286440FD900EDAC814110B500E227BA1440001007803260114057A0012000013331615140715140F012635363D0127363334C0045010301C400C0C0E16057A0E3A1715F0E9030408383369E4305809000000010064FFB0022005BC00260000011615140702150706151114171617161D0106232227262F01263511343736373637323736373601E04034A044243C23157C0838283854204814401B192636072133192105BC08382B19FEEF0F88761EFEEC885C501C83210440544B5594822E0100659F213B595B44501418000000010064FFB0022005BC00260000172635343712353736351134272627263D0136333217161F011615111407060706072207060706A44034A044243C23157C0838283854204814401B19263607213319215008382B1901110F88761E0114885C501C83210440544B5594822EFF0064A0213B595B4450141800010022009A042204D6003D0000011615140706071537363316151407060F0101170623222F0123061507062326353637363523220F01140726353437363F01352627353633321F0136373602E64018101CC02014403851536401480408382B45D80448201B1D40201C20040B8DEC284098AA4A64D60A08382C3C8024141C04D608380F316860048C1408382E16453348FE80184064F8C15F941C0A32CE7A4A0E60540B05083843213E423004F61610405C90857760000000010040FFC0042004200020000001062B0107131714072235030607232635363B01363F01260336333217133733160420083874D44C044044488A72A04008389465830C28380838430D48E0804002504030FE5440270D740188141C08384018140892010E4080FEBC34080000010057FEB9010F00BD0015000037161532171506071423263D013637353427263D013697680B050C1840401C08281008BD0C3028C04A4A4C08382058346C0719151720400000000001006401C2038402AA00110000011615140714050607232635363B0136253403444064FEE0C7554040083834A3018102AA0838371D081C1C1408384024280C000100640000012C0124000E0000133217161706231407263D01343736C43A0A160E0C3428601C0E01244C1751600B05093F2061174400000001006BFFB002EF05C80017000000171507020F01020706071423222734371312373413363302E7085090045C60440D0B48380824645048CC233505C84008ACFECC38F4FEB6965F097C401C9C011801169E4401B060000000030036000003AE0584002A002E00560000013316150623153332171615321D0107151407140706230723222726272627263D01343736373437343736171533350115141714171617163B0136353635363D0137352627262B01062326353437352306071407060F0101BE2040091B8C507858080C2844745080207C3C17612C182828174D58641B5508FEC02C581C34151334A474240C081C543C6415174040102838401731380584083838046868581C60F030518B3672A41C44065E406C3D7FE06266736D13650943287C0404FDE8E05C5C41530B2D0C1C18874D812744F054472D5C10083830180424200947324AC40000000001006BFFBD038705A500230000011615113633321714230415060723263534373633110623062B01263534333F02353601C740E8602D0B5CFE246E2E0840CC222E7D0B1E1620405C5854140805A50838FB282040402E12181808384D1F1403C47C1408384458883020400000010035FFD703C7055B003F0000001716171615140706072207060733361733321F0132170623222734272324071407232227343736373637363D0134272607060706070623263534373637363702A92F30101F6B1F6611D8391704D7EA0F612C490A05083520344122FEF3ED351F351B3219ADBE1FB32A95A428371D1815193D41622B8B7C054435314F905495A33672F0271D4828203C284030110328641A0A5848282597D709DE7E1472866B8B17351C40140838334D620A56120001003200000396057300420000013332171615140714070607061532171617161D0114070607060723220726353437363B01363F0135342726272627263534373637363723072126352227363B01172102B2402B15205058167A2C3197973D0C30315340BC5421AB407C4B5934D63630443AB248A824EC77351622048CFEA07409030838202C01680573321426264508602F5D16074F63AA4B35226934453321292E083A440F1D2943424F863C60351E0B19264D4C515D0B2F110B1A25430900010028000003D7054000450000013217071506151F0136373633161514070607151615333617363316151407061706070623222735342726270706232227263511363334371615071117253526353437353433020C2B150414040CAC67271940A02DBA340403082D1740342A0B141019472D0B24060AE42E2631271C0C202440100401140C143C05403050404F91D00448311C08384523254C04E4501A132008382B191D1A0E4E204050B2A62808603C24685C0200B409030A3270FDD428740459B383613480000001003C000003C00570005C000001321714230607060714231407150715141715333637363736373637333217161D0106070607060714072635343736373637363D013427232207220F011407140723170623222735263D013437351233343716150607323F0136373633036C270D74F64E804C30240C140410242A366E3246664C51333C0553AA06127E3C4078241CCF010C3C383860158738283C080808385A12140C1F1940401C101351780E46FC5805704044442C4341080B09104C94445C58703056327D174C14588A4278477DB71D1E92210B083824882739DF2D0E1A683D6B609C68315727092440FC346B41803933140144320A083856663C400C1C5C000000000200640000037B0573002C0047000001161514070607060722073237363F01321F01150706070607060714072227222726352227353437123F013637032315141F02331733363736373637323F013527060706150706019040400B29301806060F8C10DC5458241C03371D124E3B3DCC0C244C543C0A0624343C501F11880C1C20309030042A1A3C1C141812010C142E169CDB140573083A1089264A84AE2E7F395A154F74844BD42977585F150C111967764580216587014275B63901FC9B4F457543210C1634318E17697529644A0A133722BD2900000001006C00010384054000260000013217161514030607060F0206232635363F023437363F0123260F022635343736373237032C301414A82E0654594D27181C40131449615C17454008AA667A9E40AA6B4B0FE505403C161A18FEC88B01CDB0A4BE180838923898C912C65E7A7C0B1B30AE083842A031130800000000020072000003620574004E0062000001161514071407060714070615060F0115161F01333437343F0134371615140706070607161714171615140706070607140727232227222F013437363736352627263D01343736373437363736333413140706071516331716173336373637352726270232405C48142C2C14372104239128084858703C406867052F1D495B340838064A132D3C2C405F351A3E14383F414012BE681C173D38422E2D3F2084461A130D10012B7020243C24300850057408383D0B0B051010071D0F112D4704142C2C1C1173228288210B08383068893F32522B811858223664641E622622210B08288868684C78484B152143561A0C611734481D1B390B2007FD45179D7840186C200C0C0D433E864460234D0002005AFFB9039E0592003C0054000001321F0232171617151407150607060706070607220F022635363B0137343F01363736370607060F01232635263D0134373536373637363F013E01011507151633141733363736372627222F0126070607220702AE392F241810100A221C1C0C0B0D3D232880132D7440400838246C3478242420185868297738209C540C1C262D27497F403240FE700C312728046969646E03190F191222485086134F0592686060CA212F10142C68515F0C80C3102F5D1C2404083840240C0C641EA1D9375D6B293F0C32224D6B0C393334B34B433B2D6324241AFD82304C40580C0818684C7E89737C2C2C212F66A40000000200640014017003D0000E001E000001321732171506070623263534373603161D01140722070623263D0136373601041C2C1B091E422014403C15015C380923310F400D272B03D028382064281408386B6510FD94193B403D3730180838206349440000020056FEB9011E034000150024000037161532171506071423263D013637353427263D0136133217161706231407263D0134373697680B050C1840401C08281008573A0A160E0C3428601C0EBD0C3028C04A4A4C08382058346C07191517204002834C1751600B05093F20611744000001002EFFF9043E043900220000052227262726272627263534253637363736331615140506051516173217161716150603BA39637D878CDC2838240180CE626A622E2640FEC48CFEA477CD0894596740080754497354C8100418246349343033453C0838539D404C047E8A78354B08384000000002005700DC0437030C00120028000001331615062B010607220F012635343F01253613331615062B0107230723062326353433373336373603B74040083854FEA290805C40689C0138E12F4040083840E0548C748844405CA49448D44F030C083840301020100838410B181C30FE940838401410200838402010041000000000010021000004310440002200001332171617161716171615140506070607062326353425362535262722272627263536A539637D878CDC283824FE80CE626A622E2640013C8C015C77CD089459674008044054497354C8100418246349343033453C0838539D404C047E8A78354B0838400000000200C8FF4F040005A90033003F00000132173217161D0106070607060715141F01142B0126353734272635343F013637363D013427232207061506232635343736253603321716150623270722273603205E16124A100D634E4AB41034083C084004241854583A6A7C4414DE36D8181C403C2E0126509B5B1D10083818202F190B05A924A05739206F5D612F6A02042E9E38800D274C265A534534343012627A3E147C582C451F1808382B2D21630CFA7D3E1D215B06067D5A0000000100640000046804B80071000001331732171615161D011407060723222F0107232627263536333633321F010623263D01232215141F013237353633161D01363F01353427262726272623342F0123220706070615061D0116171633163B013637363F01161514070623062B0122272627263D0134373637363736373637340270603C50484C3C5030540434400430206C384C182434745A2A08083840145C443C13210838404315042C130507111A12580854922A31434814477962322236705E3A38342440783F15721A809E5A5B69703806220933204C1E4A04B8145480406888208E3E461A400C0C163652967C38385C4008381440722610241C40083878382C2C346B49372D012738090F085026A67E3A432180873140083A121242080838364A20483C2B518B45646D9B015704783B5920240F0000020028FFCE03FC05E5004B005800000116151406153217141F01163B01371615140F011417161716171617321506232227262F012227263523060714070623220706072207062326353437343F0122273437363713363F013437360B0106072207333F0127342735020C402C0D23444C1206108040603048083020041206080838410B13090C1B4928080D539838482222320614081824402430200B053420086C13191838281C6814080701108C8C504805E50A4337501B651287BB2C220A434B0B0F14B120365F27035D224D7D234721CF501E0D190C2E22C07B3B642C0D3B5441197C86303220785B012E44304817AC1DFE69FED63960183039C11683180002003BFF8803B505C80053005F000013161D0137330417321715060714071533321F011615171514070615070615070623263534373635363F01363F013526232627262B0107232227151715161D01161D010623263D01263D012735273527113735361311171532373437363526238340042C0145096810097F342C7183543C08985C3C3C101B1D404C2C1E0E68223A0C052F2735493B908A1817150814100838401014080808087008AC564C28081805C808384C041206BC0446960F2504483C4B2D5064328A5014542A2A381C0A32546011231E1E64283018447C29131C08105060BC4F2D381517304008381C1517448CAC60F82C01802C3440FEFCFEF82C145409573A16300001003C0000041D055F003E0000013316151427062B0106070607220706071407061513171615141F01371732373316151407252435222726272635270334373437363736373237363334373402D018618120340813393F01154F2341203C06042084849EEC0E4F084095FEF8FEFE1468590F50080630402C4C14480F21443C84055F31404E280E100B3B0A45085D0B1E8859FEF7450F1F1D3E3C04042E0A404F2805091C373514722A4E011C58841962473A073D2A40120E080000000200050000038D05C000330052000013161D013320151617161F01161715071406071407140706070607062723170623263537352627361726272227353F01273F0136171507151407151716171637363736353637363726363526232627222726239D4070010457212157241F09142B4830341C79582C5B29080808385408571D1058230D070110143F142116741410180B0D5B677116441D1F3523050C131926520F291DCF05C00838381C14200761304050189C858454112B0A2A30633A1709022440153B2C040E42490A95CC3CE0A0952A4B1575F804602C6B35E4FC318B302B6A16540C13352C5893751D6C43251418000001000E000004160520005300000116151407232723072315071105333217062B012227230723150715161F01363B01173215062B01222723222723220F012327072322272627353723220F0126353437363711372326353437363717363B01173303564058D82CA4381414017C843A0E0838406E56D02C0808102008AF41ACCC48083830171508273DA437B9140C04041052161C100804093F1C4060440408104054174534232DAC2CAC052008383B11080C1850FEF004504010080C2C30FD57446C204040101074040404CC5AF64C20400408382E460F0D0108480838491B0804040C08000000000100640000039C06060035000013161D013305331617331615062B01262723252311140717153637363734371615140F010514071517150623263D0127352735371334B8404001082C286C5C400838646D3320FEF83C09013672A26C58407884FEFE500808384008081004060608383E200C08083840080C20FEC2275D643C150F24100D0B0838420E202C100440C0E6400838DEC0FC603454020C2D0000000001002100000421058C0065000001161514071407060706070607060F0115140706071516171617333217333637363F0235263D0123060F012635343736373637343716151407060F011F011106071407060706071407232623222726272627263D0136373237323F01363734373633343736025D405C2C012738283C241D13102814104438354704325A281963380C241C4C048B2D2440B4313F0F755440301769085C0C0818301B6D4020287845173A1A2E623F510814280E0E0D0F3C431D48391F343B058C0838351F0A0E090F3F153153167E1418193F2B4D906775411B181B252B2D3C68F0462A0C47450808384765200C1923250F08382B152A1A086834FEF84C20244053450D270B0518180A6A7B81112F94605C5464706F050632440913280000010011FFAC04640581004B0000131615061506151117253526031136331615111217153733161514071516173217150623263D01032627052315171516070617062322272637273527220F0126353437363327113437363736E74006040801FF100C0838400C10780840B8180C0808083840240B05FE1904120D10070308383A060414090E302C18403430340C04020C1B05800A32354B5544FEE068421041010B0100400838FF00FEF333082C083848240C8FE19C204008382001B0173D3E04D734854A283540443E6D7134CB240408382B19208401206D4C364A1C000000000100060000036605A40027000001331615062B012215161D011311331615062321263536332111342735262307232635363B0137330246C0400838D434181CF4400838FD40400838014C1C10148CA0400838A0A03405A40838400C534514FEF4FD2008384008384002E032CE34800C0838400C0001000D000003450580002C0000013217321F011617110223220706150607062B012635263D013633321716173336373437343F01352627352736024E453F09032122243E120E0E5C2470883020C04408383E062C64102FAD602830382F500805809524558290FF00FEEC28622A2E2A4036223B2920405432160C5024682020C8E4F75C108940000001004B000203BC0600003B000013161517160722171536133F011615140F02161716171615062322272627262715161D01161732071516071407223F01262F0135363511273727368B400D010409121BFB94404044C8A097CD96224408381E4AC3246DEC081306070B122140440D06030210020A040D080600083846394969FF09010E881408383117BCA020D6C61933254044DF288A3804153F146CD6426A3A312D0B907181B35034B61F010BDB103A4000000001004A000003BE0574002B00001316151407150715031217161715373337363736371615142706230607230623222734270313353735343736B6401810040C1C0F091458BE3B65147C5AAA34604ED01C1A2A4038281804102014057408381C18686C04FE40FEED4D173908041E120E0C2429384207201B1734942B75013401C0106C34601C200000010022000004440554005B00000132171617321732173337363336373437363B011615161D0114071112173217150623263D01262F0111373522072207060F01060F01150715062322352627032723140715070615220F01150623263D0112373637363D0137343734011C353B21130B210729044016120543903018185C0C141C04060A083840140C1014093B1331291F18240C080C08384410446810041C2034060C040838401C1E10140C1C1C05546423D17C8CC464165226722418400E1A1C2167FEB0FED28E844C40083844B6D6B4016C68183C601A6A506C4408087874407450B0014088204C3CC08973F610344008384801568817850E1A58681E563800000000010035FFA303F3059E0040000013161D01161F01141716171617161735131134273536333217321711140711161706272227262726273427222726272635231507111311062326351103113711368140265290840818323E114B1C1C08382E160C0C1C271333453416173719495C151B16DE3C040C04083840040C080540083858056390156B0127295B2044640120016E10300C403848FE8646C6FEE28D7045439C106825700B753005EB32124830FEBCFEFFFE984008380158012501403001304000000100560000045A057800DE000001173733173733161F0116173217161D0107171507171507171514030607060706070607062322272227262726353327353727353727353727353727353727353727353727353727353727353727353727353437363B011615140F01171506231715071715071715071715071715071715071715071715071715071715071617161516171617163736373637343712352735372735373427342726272623350723272207060722072207220723171507171507171507171507171507141715062322272635332735372735372735372735372735372735363734373637363702EE04041C040410364624290F151330040404040404101418104E15614C8C60501933395F25174C0404040404040404040404040404040404040C0404040404243C200440240404091B0404040C0404040404040404040404040404040418281C1C142014695F605D5F30201804040404341805271D2F041C041E76081C0612130D0E1204040404040404040404045008382E16480404040404040404040404041418400745299705780404040406322C38285038380C04041C04041C04040461FEE63F2540854334511B0D28AC5D0F9977041C04041C04041C04041C04041C04041C04041C04041C04041034041C04041C04040453194808381B290C041038041C04041034041C04041C04041C04041C04041C04041C04041C04041C04A52B26121F41232538062E455D970E36013B40041C04041C041A4E1D131933340404043C0553245C58041C04041C04041C04041C04041C04377D1040386B5D041C04041C04041C04041C04041C04041058303C48404C340C0000020064FFE60390060C003400440000011615140714071533363F01331615161715140F022207062317151423151617061707062322272637263D01372635113F02361323071136373637363735262B010607010040181404875D68847C1E0ED0906417891E16040C160C11111C08383014030E0D041014141C164A0C18911F0967D5371428508147060C0838142845170C1C241018181A4A485FB5685C94141C100824CA1E383846403C5D9A962134182D37019488649C70FE9090FE9496061D478E76381C0B2500010049FF7B049D05BF006E000001331615142306070607060F031517151417141F01163B0137323735273427263536333217321F0137363F01262F0123060714072635343F01363B01161716130706071407161716173217062326352627262722270623060723222726273427263D0127353736371237363F010259204064163A6A2A261E381C1008404060643824580A2A804018083829230B415C307A0614146034407A0638405080153F2050506814141C5C60810B290B210B0838583B1917110A265E1A372920EA721A4A20300820182458406B454005BF083844140C47555761989844242C34424A2147322640300488083C2117403C505C40C262B2A5350C450B1A0A083830384408083867FEFF7CA781107C863A261A3C40182837450E26306036027804741626496B142C40908F45011438770D1C000000010042FFC403EA056E00CF000013321733363315373317373332171617150717150717150717150717151407060706071407011617161506232227012227343732373637363537273537342F01062335062307171507171507171507171507171507171507171507171507172317150717150717150717150717150717150717150717150717150716152317150717150717150623263D013727353727353727332735372735372735372735372735372735372635332735372735372733273537273537273537273537273537273537273537273537273537273536338E231D0442325C0C040404986C453704040404040404042C53675B1B180190522E1408382F81FE88301C680E26903820040404F8103B316C1C04040404040404040404040404040404040C040404040410040404040404040C04040404041804040404040408384004040404041804040404040C040404040404041004040404040C04040404040404040404040404040404040404040D33056E291404110404362C541D04041D04051C05041D0404101E318E3B460B0C19FEA45413171B4280014367306E2E3383292104041D0455270511041914041D04051D04041D04041D04041D04041D04051D04041D046F051D04041D045F0C04051C05041D04041D043A0C04051C05041D048832041D04041D04041177096E0D04041D04041D04BA041D04041D043A0D04041D04041D04041D043D33041D04041D0470041D04041D04051C05041D04041D04041D04041D04051C05041D0404108D0000000100350000037D056C004000000116150627060F010623060715171417161F011617161D01140706070623072225273633321F01363F01363D012627252726232627263D013637363732373237360243B11AB66F1547202B400C5942228BFC302C1B353A1E7F4D1F75FEFF09093D1FE5425A30351F1E67FEE1051A2D3340580D2423470F2F30356F056C5F389EB51020243C45533C3C0D0B1A22481A361C58402567394F9404BD20409508366E403F15602B115404141B35215740613343353C3428000001000DFFA3041705440026000001330415161506232523150711140716151706232227352637113706072207062326353437343702A7380120180A32FEFC1814030710083840100E0A14F16D1B352E16406CF20544220A181C40200478FDB471A2774F40407008ABF602A05C140A2820083832360E1C0000010036FFF20350055D0039000001161D010717150717031607060F0106070607232627262F023327113633161D01071307141716171617363F013637323727132735372735360310400404040406021B063A2C3814202040D44F2C4C200804040838400404043C214302B94711241D0A1107041004040408055D08380C04041C0404FD63F016414F5D2D0A0C20437C1DDB6C640402504008380C04FDC4043EB2634D154A0C30441073940402CC041C04041040000100280000033C04D8003A000001161514070607060F0214070607060F01062322272227353727332735372627262F02363332173217161F021533343F01133637363F013602FC404C241C0B0D24281C18280E0E18161A390F0903040804040410281D4F4C200838380C060E505040080824283C0F091311581604D808381779698F174D986C0E3A5E52145C2C1454240C0448041C04A2568898E49C40486CF5ABE02414204C6C010C2355264E941400010014FFF704F80573005800000116170F02030603070E01072627262726272627230306070607060726272627262726272627263726272627373617160F0116171607161716170617161F02363F033617160716071617161F023312371337363704D81D0314080C2A08541E0728384404111F3E0C0A17043A053B292F19353E0E0C183A112C241A1E3B04180C0B01060E383F0604090D20053710022F024C0229190456053216150E383D022003130D161F1C3D0447082A11082805711C3854542BFE4E5BFEB66E3B310307633A89C7510973FEED3A9586273918073D0B7D63554D8319918D311B650128403F050E38340E542E359050136218AC24444301E52CF08BDF3F05065455231F6021857BCB01125801BE5F6E440000000001001BFFF9039B05C9004700000116151407060F01171617161716171615142B0122272227262F01262726270607060706070306070623263534373637363736373526272635363332171617321733343736373633032F405467351430110B3533132148441830240D13212310271517154B1D2030162E5C0F19181C404048283937313F0B49500838331507310D33044C4F3D1D2705C908382C74F52F2844091B256F113F05375C4C3C284418192B14245F411490465EFF00093F1808381B75E044BF3D5D47041B458F154044025E400C6CC3514C000000010028FF81034405A4002700000116151407060F01060706070607060714072635263F013E01272627263D013633321716171237360304405C2C284C2A1A17191A16260140400E452C2E1A1381707C0A327076415F9C321B05A408381E8A5577D47D5F4197455F38CF320A0838C483A87FB726E688123A044074959D01B14B4400000000010021FFD103FC0547003400000132171615140714070306072207061507153605171615140726250722353437343736373437363F0123040722072635343732372403111B21103C20B92C23076560046101928C543873FE68D85C3070552F6E523C1004FEB0941F4D40781B5D018E05473C15171C501A42FEEA7544D87D530404281C2136382E1657042C4412823DAFB070129E6390381B34140838430D203B00000000010049FF1002290648001D000013211615062B011517110711331615062321223D01343711371127353437C90100400838D8080CFC400838FF00A0240C084406480838402C2CFD40A0FD800838403C0C1A2E0270A002B42C602F2500010022FFB002A605C8001700001332171215161B0116150623223526272603272603273536623523CC485064240838480B0D44605C0490500805C860FE50449EFEEAFEE89C1C407C095F96014AF4380134AC084000000000010049FF1002290648001D000005212635363B013527113711232635363321321D0114071107111715140701A9FF00400838D8080CFC4008380100A0240C0844F00838402C2C02C0A002800838403C0C192FFD90A0FD4C2C602E260001004203CD02FE0585001F00000132173217163316150623263526272306070607062326353437363736373637021E37150917382418083854263E04446C3375141440400785584419530585545884181C40191B1AA2404C16560C08383018124A3C40342400000001004A0000044A00A8001000002516151407230507232635363B01372533040A4080F0FE70A02040083820A00190E4A80838430D0C0C0838400C0C000100430460023305DC001000001332171617163332170623222F01263536831D5323813315401408382850A4940805DC481060285C403C785137400002002FFFD0039303E80039004B0000013304151617161D01161506231707170623222F01352207060F012326272627353637363736213334273427232207060714072635343736333603151633141733363F01352723200706070601A76001002C2C1C14060E0C04100838410B080A628B3D5080315F23191B3D7D4B3B013D1C40A8681E4E260E40402C4242269A1B1D2498257BB80430FEDD254E5A1F03E82D3F33A9B53388161A2C68045840683818403F2D0403492454209040891F4432861A1E180D27270D0A324A1A4818FCC804400C08243070B4283C26762E0000000001005AFFAA03BC05FE0051000013161714071506171617363F0136373637363F013316171617161D01140706070607060F01060F0223263534333637363736373237363D01262F0123060F010615060F02060722272627033537362726AC401426160803260B1844262E41431C3C14604D3B1D0B0C200A0A091B164A5C4D833C18204058C04040241612090B20101C203C283428742E1A10431439391A0C1A010C150A0205FE08671CC5FCB2375AB12854DC2D574E1E0A2604104C1448154B40662E13390460167A8C585C2004083844728E53450B5940352F745410141C141CA533A11740824C0F5193800185AC9C12AD4D0000010028000002E80448003D0000011615062B0107060706070607060F0115161716171617141733363536371615140706230607232227262326272635223D0136373637343736373637323702A8400838344434406513123A211F101408141018143824783F3540501E2E295B402C581D07101C340C172133454042322957104804480838401C2B196E0A27494C24605457050C24082C0C1013313705083834184C181040300735294B5C40AB096359182C541C0C401C0000020028FF9C03C80610002D0041000001160703141715173734371615062314071F01140722352627230607062B01223527363736373637363F01171336011F01333237363727352F01372706070615070602EE5C52180408603C40142C94280440441408043ABA3B1920C4280D1F30300F314E42726A212EFDF9184020089E4268040804040CAC2080402306104F45FDE874A4887C2427090838600533C4242D0B641B651DA32C6C99AFE34458172948303B0B01BB98FAAC702A7D3245043080A07C571137711764CE00000001002FFFCB032B040B0051000001333217141F011516151407060706071407060F012635343734373637363734273427232207220706070615111417163B0136373637363736331615140706072207062B012227262711343736353637363701B780354B30044078063E555F58015710406C6008554348282C58243C132536222438254F0C1B5528403309272940454F300F752E1A20B636380858582523194F040B7C1476180C08383F15091733150C0C090F0408383810110B0B10202527315A24485027834A1AFEE23D2F100F2613311249400838256046283D24505050015029C36C1430103319000000010021FF6A031305D1003E0000013332171615062322272227230615061507173336333615060F01220715061D011607160306232637362736273537060F012635343727363F013637323736021B2461175C08381D2F0A12405450100E04644B8C0845532E710C0E0106041D6038250B0905060442421840E40E14081C23350B393B05D11C2D33402C102D075C80509216213F40140E1604251F2C71A475FEF168367993A88C8B243017310408384B49B6625A4C3F45242400000000030043FE5503CB04390046005800710000013217161507161506070E01070E013315370516171417161D011407060706070623222723222F013534373437363335263D013637352227262F013437363732373335262735360115163B01363736353635342F01070607060315161733321F01333237363F0135262325272306072207140246216B180C440C4834503C50071C14010C3933402C282F5124382A6A3E8E405983081C883014100714294F3F15047C6779147C04460A08FED862222C255F44443408C83D2B50233D2F1831933C040E2E7F35104F15FEF804044C3C2D4F04394C310F30364E53F13C29073A460404040830094F3C1C205F35412B19133C249424406117286C18041517202632044C273D4C3F895D1B240424201040FDF41C5C0C0C2507F01C0E0A0838212365FD59544907200428353F2834780404111F640A00010050FFB7035805C3004A00001316150F011507113237323F013637363736331615161D01161D0107151706070623263527323D013437353427353427230607060706070607060714070607150623223527263511123736C840240C080B090D371C2E22113FA421602C140C1B090B181C401B080C141404195B412C07150A16181050081C08384004100A220B05C30838909F3480FDCC3CC0448937342828142C4F79146B41A04C54DB021E180838CF1430393394445C203D47074019940143095B4C182484028348405CA1224A02800181327000000000020064FFDF010805B800140020000013161D0107111715170706232237263D012711363337223D01343B011615071714B0400C1410100838471B1414062E26443C0840040404000838204CFE944C74DB2E40C5663250500164BCBC740C800D274C4C270002000DFE7001BD0540000B002C000001321D01142B01263537273413161D01141F02151407140706232635343736373637363735342703222735360121443C08400404404014282060A0452B40343F4D12262A0E1C300907080540740C800D274C4C27FEAD0838203C48E4DCDC877530745008382B194731104C2A4EE04583011880204000000000010019FFBA031D05C70044000013161D010615111733363F013437323736333437161514070623060706072207321716171615161F01062322272227262F011514071407062F013637363D013711343735368540010404261E1C5809671D1F5440382C2C294B1C200D23165E4B0DA92B2108083840801E5B2B55611308104D3203141301010805C7083840EB7CFECC1C17311819475014141808382E16282A2A1C3434705C23D1263F1D2040FEAC1E6230543A8278643C023B43889236588C01407AF93440000000010054FFB6011005AD0015000013161707110615131417062322273703343711342736A2402E1814040808384616140414021505AD084560FEC03F3DFDBE38D440A0B002464242011067561000000000010064FF7B04E203D400530000013217321715363734373332173217321711161707263F011127342723061506072207151407142326352637112735232207060F0106070607160706232637352635262711363316151114173637323736373637025488180903386C28602A360B150C0C140A62631B0C182030990C04100F0C4C400410084C34540A1E181C1418101414083868281C080C0838400C140406420D1F4F3903D44C24302C100B05506048FDE46A503738594C022448251726360D37A4A011567E0838743501182CF094054B6C2C5C851767394014C028315793290140400838FECC1D0349337C063A5E0E00000000010050FF96033803F2002E000013161511373637363B013217141F01161314171407223534272627263523060706070615140715062326351103353690404C48443E1E203E2A3424202C084044400F1D3C046E3E182C3010083840080803F20838FEE88C6B3130781A82C42BFEA79D2B2D0B70EAF613C1862A4A961A8659372212F440083801B00100D040000200430000043704140025004A00000116150733161F011615161D0106071407062B01262F012627262726273534373637363736330115141714171E0117333637363F0135262726232723220F01263534373633272307220706026B600454753B4018141C28708A2A807867613E32172121034046724C0C5D3FFE94283C2856B664644C1420141804520E2C44085C3840482616084C6C2E86200414093F1C1E4E582A3E155B608C303D6358142E3E2C4C095F352F80228A644C270D40FE246813491C3C3C3A261D5F3C34547454286C144C0C0838380C300848882F00000000020028FE4D031F044A0027003A0000131615140F01153637363B011617161115060714070607062716071607262736372736351134373613111716373637363734232627230607060706D240280810717464144F552C2A3A4C2E777E6E061B1B4F5701100D3222381C2C04817C6937171D2C171D1C5728384C48044A083810603C04183A6C0F6D2EFEFE0CDA47105C2A524F22CE7478231948AED649396601B065C358FE60FE2C3022635A6A20A9F81E0E2B243625440000010043FE4E03D6043C004E00000116151407220F010607060F01151417163B0136373637363D0136373633161D01140714070615070617363F0116151407060F01232227263F0123060706232627262F01353437363F013637363334037340701E32B45048A03C08B40E1A1477316E1614121E291F40382018271B3517351C40182E375C0C39132C1B27041C802266A828412B1470293F9850A45C54043C0838410B285024304D8F701467250C245081872D1340761628083820119715633FB1E7D2A035440408380F313F350E907DEAC740402027211C585020CC64342C582C44440700010038FFC602A80426002100000116170627060F0206170615070623263537343734032734373215173637363736020C7E1E3478800C541C1911090D0838400D0524184048101B1D2490180426246A6B717444982858988D485B4008385B33BE310147E42D0B8C84184C5E7216000000010021FFB1030D042A003900000116151427060F010607163B01051617321715140714071407140706232227222736333217323736373437352723263522273534373637363336023B4D913B9D1C2E342F1984013C41130B055E58246C42421246320A08382A3A1E52364E46F0C07831135629977A4E27042A3638441E066E1876401804192B284026B11B3108241351282840402848522A0F981C040B1D6020229062524C14000001001EFFB00272057C00300000011615140711363B011615062B01220714171417061F010706232237222735263726272637062326353437363311363736012640106E4E20400838206256050F0312070D15384B2007010E020C04101367194038641C100418057C0838462AFEA41C0838402427A55D682F433D6E8AF41C300C902D871C644408382E16440198324A2400000000010036FF95033603DD002F000013161D010715161F0136133727353633321715071715141714171506232227222726352302232227263D01343F013536A640300CB828296F200408383F09041C281808382E1609171C0462526BB96428080803DD0838C0C0C4495F10510153604C60406060489850AFB1352F084038B47E62FEBC8C51778C467E28B4400000010014000002F803F00035000001161514071407060F01060722072317150623222726272627222726272635263536333217161716171617161734373637363736373602B840283C1C1814190F0B09040408382E161E2A1834112B3014303408384020130D240C261E363228243C140C0B211803F008381E5E49BB557B541E6234140440380F3D0B5178453F475D8C1040943B553335265E5B211E5EBAAE496F026A1800010036FFCE03EE041C0047000001161506150207060706070623222722272635262723060F01060F0115062322272627262F01353633161D01163317363736373637363F01363332171517121F013336373637123303AE4030380C141C26121428390F0F11380C0C0414183854100808383D0B1C380B1D1008384009134035131C101F050E0E10152B3B1928281C0C042008181C2F19041C083BD838FECF6E61537A042A587EC63D2686306B8A933F082E436083A72F3EB08643093A86ACCD51452B5C5141179558326037C4FEC44E37946355E60108000001001BFFDE032B03F6003100000116151407060F01153217161D010623222F01070607060706070623263534373437363F0126272635363332171617363736029B40701E32080AB65808382B4DA440334D2329162615174040682B4D2C6448540838126639573D632503F608382E561F790804A0531D04406488604B99217317491008381E621FA1626E48541C2830403C1D439F3D380000010014FE4802F103EC002A000001161707060F01061507020F01062326373436373626272627262726273633161F0114173736373536373602B73901290814251824462424181C4007242F18242835633D59200D0838545BAC3418141D141E1803EC1552662283BE3C50C0FED46E761808600F64E12173305E8641C124304014E2F41044985A903462626E0001001BFFC803FC0421003B00000132171407171407060F0114070615373637361734371615060726070607060706232635343F013437343F02060F01060F0126353437363736333402DC2D0B0C043C712F3C6C20E0063E7469246F0E59545AB8AB2F55201440404074487018735A5815A318405C5ACE955C0421461517272521E1495C0FB23E0D650A193D080A03093D501F372964472A2016093D36637716B8106ACE35312834045605093E30411D69540D0000010042FF3E01FE0642003A00000133161514230615071514171617161D0114230715161507140F011F011615062B01222F011233373427232635343F013637352F01263D013437360192204070880C381523101C245C71141C429340083840A42849230D71286040543010182C401450A806420838443E0610347947443C2311207034084CBCA00F29D074140838408292010C9079270838390F2C261A30608C4F49403642540000010049FF74012D063400110000131615111615140714072635112227343734C54028284040320A2406340838FA5C1D231D43320A083805B440113F230000000001004EFF3E01FE0642003A00001723263534333635373534272627263D0134333735263537343F0127232635363B01321F010223071417331615140F010607151F01161D01140706AE2040706E0C1D1623101C245C71141C5D6440083840A41B42220E71286040543010182C341444A8C20838443F0510347947443C2311207034084CB6A01028D08E08384081A0FEFB9073270838390F2C261A30607F4E4A403550540001005D0168037D02B40026000001161D010623140723262F01262B0106150623263D0134373633321F0114173336353235323736033D40251B5C606B29305622105C1824407036227527903C4C140807051802B4083820AC2319112B2450434D2408382033713030700709251F144C24000000FFFF0028FFCE03FC07060222002400000003008E009D0145FFFF0028FF5D03FC070902220024008F000300D500A50198FFFF0036FE5D041705CA02220026FA6B000300D6016AFF8FFFFF000E0000041607060222002800000003008D00A20152FFFF0035FFA303F30711022200310000000300D4000A01CBFFFF00560000045A070D0222003200000003008E00EA014CFFFF0036FFF20350070D0222003800000003008E0070014CFFFF0022FFD0038605C802220044F3000002008D5C140000FFFF0032FFD0039605BA0222004403000003004300AAFFDEFFFF002FFFD0039305B2022200440000000200D357FA0000FFFF002FFFD0039305780222004400000002008E74B70000FFFF002FFFD003930589022200440000000200D4DE430000FFFF002FFFD003930599022200440000000300D5008E0028FFFF0028FE5D02E804B302220046006B000200D6388F0000FFFF0022FFCB031E05A702220048F3000002008D33F30000FFFF002FFFCB032B05AD0222004800000003004300A0FFD1FFFF002FFFCB032B05B8022200480000000200D331000000FFFF002FFFCB032B057E0222004800000002008E48BD0000FFFFFFBAFFDF01AA05AD022200D2F3000003008DFF4FFFF9FFFFFFD9FFDF01C905A0022200D200000002004396C40000FFFFFFD9FFDF01B605B8022200D20000004200D39400333340000000FFFFFFBEFFDF01C20571022200D200000003008EFF60FFB0FFFF0020FF96033C0582022200510000000200D4BB3C0000FFFF00360000042A05C802220052F3000003008D00D60014FFFF00430000043705CF022200520000000300430112FFF3FFFF00430000043705B8022200520000000300D300C00000FFFF00430000043705850222005200000003008E0112FFC4FFFF0043000004370589022200520000000200D443430000FFFF0036FF95033605A70222005800000002008D66F30000FFFF0036FF95033605A0022200580000000300430093FFC4FFFF0036FF95033605B8022200580000000200D338000000FFFF0036FF95033605710222005800000002008E57B0000000010042FF95030205B5002A00000116150F01153733373217142306071715161315062B01222734373503273507232635363B01373534373401CA401C041404C82D0B708E1A040C40163A083F0920400CAC4040083840A82405B50A32883CE4041040440C0814049EFDE244A0601A264002348C081008384010F85B752700000002004903CE020905A600160021000001321732171617150623062322272627263D01343F0136071514173F0135342707060161231D2E162103111B2A325771243C105458356198200828403005A62838382C40785C2C03411652202D473C30F4300E26342C281B352C16000001007E003C02A205280031000001161D0133161506232227230607061D011433143B013237363316150623140723150623263D012227263D01343F01273536019640505C08381A16205262408450143B15151740183068180838407A461CC01C040805280838CC193B401411776A52283C082C1008385C0D13F0400838FC58332120E4A01444C84000000000010021FFAA041D058A0068000001321732173217062322272623270607061507220715161F012533161514072207171506070607220733173217161F013326353633321F01151407062B01222722272627262F01232207062B0126353437363732373523072326353433363727342735363336373637029962261F2D1B0908382636290F28AA16543010081A1A2801040840701B89040913211F0606346431B33F2D2808140838313B043820202014701040285C1B790864202C2117204094283C070904CC204064088428301B1D171D4296058A243C38403C180409171937443444223E40340838410B201CA05D172D3F1020683A0A18161A406014202E16243C302626161A0830180838317B2173449034083844081C4C0C4C707C1D43512300000000020078FF88039805B8004B0060000005262726353633321716173336373526272627263D0134373637352635223D01343F01363B01321716150623222F0123220F0115163316171617161716171514231407151615171407060714133427262F0123060F011514171617153637363F01021496461808381D2F235118625E52C656C64C70445C40084848614F1C4147280838263224084868180D1B1D7B028A6404160E1C6C6404607D2BA89C0C380C808E1610386CC40C581B3504781A42181C402C160E2890344C48156F4F9920384C1C1004365A1C402D633440442C1C404408583C24641947084C5820175140701E3204453334625E7D070C02F45854090B0C1523100C83113E42040C041814040001006301CF01F3038D0012000001333217161D01140F0123263D013437363334012425463F2545459373402A37038D454834504E46190C702380375E09000000020078FF310424059D003200410000013217361707151714171106232635112F01112307151615161503110623263511343734272326232227222726353437363736011417161732173503350607060706030C76224D0B080828083840280888080C1C0C0838400C0C14682C3F4D3480207C32BEADFE6770451F554F0C69672B3140059D0804404CE8EC40BCFD5C4008380294F0FC01041CF0ADB78D4FFEF4FEAC400838014039E73349242C983B79AC44355738FE608A5A190F2004013CF4164214282700000000010085002103790551004B00000133161516151714070623151617321F01150607060706232227343336373637363D0126232627263534373637363537353427262B010607060F01111716150623222F011134373637363734022D20745808902616715B2B29040953CB71E1432D0B64C672B410140E224167A0341E5E6C04300828383B45274510182408383B2918582D1F6B29055118185321507E5E28042F499C3C604B558B194040442C2C691F20107054442016462A1A34205C10101C311F18122A0C5828FE7C74261E407480016486463A0A4404140000000004005D003C05490558002500480065006E000001333217161716173217140706070607232227262726272635263D0134373635363316153334150623220706072207151417161F01163B013637363F013403272627262B012207263517321F011506230607231F0132170623222F02150623263511343334171533323735342B01033920607C4F1D7E120F09381A828662A0959B38942D2F2C0C789C88403C04053713C57507090320153B60B4809C70901632046C2010783038281E4E3C3CB232141C241C6404745C281808382B6D445C083840641C0436726440055890403CF8949C824658585E12500E7E22523A0E2B3D80AC84A60A8C0927606848DC734D3CA8361638344C681983137544900104403A5E48180927E86440205C20185C485840743040DC4008380240440787643404340000030049005E04C50532001E003B0059000001331617161532171617161716151407060F01232227262F0135343736373601151617163B013237323736353427262734272627342723220706150625321506232723061507151633163B01371615140722272227263D01343702A9205692301D3F37250B1110B459A78020BBE931470C6439CB83FE952745C0683482562884302439532407694428466AC85401A4A00838401084107739163A082C40605E4633A11C6C05320A56291B685D6711634F41E18B53350C941B8930C089A37DBB48FD68C46F21683C9041735E7E9769150F15270E0A40D72590945040101D1B101880180808383F0924A423194031570002006A031304760577002600420000013217161715062322353427060706070623222F01150623263D013437343732171417333637360533161514230623161D01170623222722032707232635343336333603C2430D491B083840401C08090B181C2341240838404024353720043C1C18FE442040701B11101408383A06130908642040706A5617057780EB9124405C18E41F35021E18481CD8400838E0763A0903580B19725E1808083844107583246C4044014C2C10083844140F0000000001006B0438025B05B4001000000017140F0106232227363332373637363302530894A450283808144015338123531D05B4403751783C405C286010480000000002005E04E5026205C1000D0019000001321D0106231715062322273536071615140F0123263D01363301EA78050B04193B3B150BDF4C54182040155305C140042804105C5C40400411372F410408382058000000010043FF24047B0474003E0000011615140F01331617161506232723060717331615062B012F0107140722070623263534371327232227263536331F013317132325232635363B01053337360377402C4434A147180838CC501448F84840083840D854443807091B1D40285C04D073791408388040906C6004FEE0C0400838C00120245434047408382028BC161A181C402462CE1C0838401808E8198B381C0A322F5101280438161A40240404012C1008384010E85800000200560064049E0524003B004200000132151733253332171423072315161F01331615062B012715132116150623211407263D010335210607060F0226353437343F013637363736373403333427060F0102824004200144042D0B8CF40C3014E44840083864B4240108400838FEF0384024FED4432D101C3024402458504B31333D2B0978D4401A265405245C3418404810049587040838400410FEA40838401A0A0838600160049C40125A4C080838163E2490AC8F4570643F452DFDCF37D1225A880003005EFF24043A05F00042005D0071000001161D01060F011714071516173217161D01020714070607062B01222706151407140F01263534373437343F01263D01373437363736373637363B01321F0133363736011514173637363736373437363727262B0106070615060706150601140F01060F0133363736373637363D0127262703CA402430140424311B1133281329500D67AA36804A1618284C204030281C04A8283C181C10249B294315402F652804420618FD386C3B593B310D4F1C2222046D1B245A2A50210F5018024864502C346898347843112E261848172105F0083820802828241F1104393B783E1A60FEEC1C16863359540C290F0B3D27510808381B3D183C1A2A187FBDA0B0498728580F5DAB0120441C505C24FC4CA8615BA5C3D23A377D0B295127045017413E323838906C3A016A0AAAAC9F69FC04403F3943618A42548C1147000003005D011E04ED03BA002D003C004E00000132171617161F01151407062B012627262706070623072627342F01353633343732173637343733321F013736331706070615161F0133323735262F0105231514171417323736372627230615060703954A2E8004282C084C415B204C64702C521E622A3C5C50500818282C1C185F3530404C341878451728412F3852823028441027356CFD48104450263622523814286C293703BA448C20443420602E4220073948545A425C081B7112AA2860580E06182E0205076C28804C7C3F3D2818833108203C256F7C8014108C243C443D5F6D13130D0B210002006400000420043C00230036000001161D01253316150623222723051407150623263D01343F01230607263534373637353601331615062322272322070607263534372536022840011C405C08381A162CFEE428083840200804E35D406823F908018810600838171504B1DB77AD4070016068043C0838C008193B401408817F40400838203A7664181C0838410B0C1CCC40FCA4153B4010300C240838410B381C0000020042003C041603F0001E002C000001161514070607060F02041716150623242526272635343F013637363736013305331615062B012523263536031E40346B3D6854702401E3911C0838FEDBFEF5765A40749884204C486EFDC2C00180E0400838E0FE80C0400803F008382B19681C68204C201C181B1D401C0C14180838392B684E1A482870FCD40808384008083840000000020042003C041603F0001E002C000000171617161F0116151407060704052227343736252F012627262726353437001714072305232227343733253301646E484C20849874405A76FEF5FEDB38081C9101E3247054683D6B344002A00840C0FE80E0380840E00180C003F07028481A4E682B39380818140C1C401D1B181C204C20681C68192B3808FCD440380808403808080000010036FFC403DA0584003C000013321516171633373637363316151407220F0115331615062B011517211615062B011711062326351127232235363317333527232635363B010027353676442672B50BEC23511513407C105C8CB8400838B80C0110400838F004083840088CA0083840900CC8400838ACFE9D31080584645183ACD80C6C0C08382D73607C0C083840047C08384050FEA040083801743C504010047C0838400126CA20400000010064FF1D031C03250030000001161D0116153217161506232227222706070623222723031423263D011332373637363B01161D0114173337363F013536029C40140606200838331D0A062020342C5038046C4040680A0E2513093B04402C044029130C080325083834739D30281C4050241F3D4460FE4C50083820019CE09527640838E08C2064417748344000000002006BFFC4032F04900028003900000132171615161D011407062314072322272635343736373637332F01262B0107150623263D01343736131433163B01323F01352723060714070601A3833184543C465230205A8E38440A724070243C342F2114C00838403C22A21C583808582C0C0C346F5D2810049060EA46C9A760B0486805078C2692924A264E1F19B46C600850400838602B2D20FC786460688460800C500A362200000001005000570410054B0038000001331615142304231617161716151407060706070607151617163B011615062B0122272627263D013437363736373637352726272635363337039C204064FDCC2836AA5C5C60540864497F327A63FD7FC13040083830C28EE458C4A04E52564A063E407DAB80191BCC054B08384494305C4430442C3E060B25255B0D7F04231D280838402820143A2A1039834C24461E0917042057616034542800010064FF95044803FD0028000013163321363316151407061D0113150623263D01033534372122270711100706232635363511363334C8AD5301B44D3F4034140C0838400C18FE3045830824161A4014101403FD241008381656497B24FE70F0400838F0019010A74D1820FE4CFE8E3A140A32A2E201C08C0E000000010072FEE1035A0651002D0000013217140F0106070607061511161511140F011407060F012635343736373637363F01113427113437363736373403222D0B4844035D40180820183488365A184048063E0F590D2F0C205C3F292054065140380C38174558801222FE987F6DFEE0581C740B8515470408382C280E1E045C027E0C014C627E01608BB9570D37391A000002008B035C02A705C80020002A00000133321F0115171407222707232227263D01363F0133161735342F0123072635341315141F013332372623011F60C23E240440301C3840693B74134544A03913581C7030404C6024481D070E3205C8A08C709C270D480C28275528720A040810044B29040C08383EFEAA180D23040C400002006A034802B60610001A002C00000132171417161D01062306072326352627263D0134373637333536171407270607061D0116173317333237352601B6343850442331313360942666147018701408403818333120452B242C44390F19061050155F932580A025070F15156B290F609E5A22260C40B01A0A040A3E2838644A1A085C647500000001001AFFD804A6042C00470000013332173217161532173217151407331615062321263534373637363D0126272627222722272307230615071516171617161716150623212635363B012F023534373637363B0101F28017212765940616090350C4400838FEA040382C18300C1808640E3A2A12604C4C3C402A2202562F15280838FEA0400838DC683430480844296B14042C184C995FB824C024B808384008382E16184C651BA425BB33752C14102C0C5CC0B632156F38301428400838409078BCCC394F2C30300000000003007EFFDE040A03FE003F004B005A000001321F0233363B0132171617151407060F01141F013633161D010623222717150623263D0107222726353437363B01373326272627230615142326353437360115173336353735232723220123151417163337353427342B01060172363E203004502020B6361008241C5C98A4581123400838BF6D0C08384080647C383C2014344C601C301C14185040406422015E0410C4140480140BFE77107C1513601C08643303FE503C783834133940153B4329202282141C083820407894204008383408A03E722B2D140CD547440C13654808389D372CFE7048141937202808FED40C3B690C080C3C68100C0000030050FEA00428051C0033004200550000013316151407060732171617161D01140F010607062B0122270306232635343F012627263D013637363F01363733173337363736011516173613373527230615061506250307151F013332373237363F01353427263503C8204044385021271D37302C382755A523402D73C40D3F4078703F59180C1407318413AD60401458323E15FD53224A71872820448C642E0206C8745C142818842C300A2E045438051C08383A06448C783D4F4F6160144C6848244848FE886C083845CFDC1F6D181CC0571D235980191F10944E460CFD28983C30D001144408081715541850C4FE7CD80830043C60076504702B75700C00000200C8FF4F040005A90033003F00000522272227263D0136373637363735342F01343B0116150714171615140F010607061D011417333237363536331615140706050613222726353633173732170601A85E16124A100D634E4AB41034083C084004241854583A6A7C4414DE36D8181C403C2EFEDA509B5A1E10083818202F190BB124A05739206F5D612F6A02042E9E38800D274C265A534534343012627A3E147C582C451F1808382B2D20640C05833E1E205B06067C5B00000000020071FF8F010D05FB0011001C00001627112735373534373217150715171114070235263536333217151407950810084038080810404814193B380840713D01F6849879F234083CF279AA85FE1D3508058C4C28105C40603808000001004200FD03EE0305001400001321053316151417150623263D0127232521263536820140018060400C0838400C20FE80FEC040080305080838859B6040083860E0080838400000010072FFD803E605AC0031000001331615142306071423161D01030623072227262726272306151423263D013437363F013217141317333711340335343736038620405C21C71834041030143F290C503A1E04544040445721203C20800C040434D08405AC0838400B0908E9FFC0FE2CB804940FD56761DB214808382013C1CF0D085C32FEF6243C01BCEB010520590B04000000010064FF4603A00642004B00000133161532170623222F012307140F01140F011517331615062B012715061506070607060F012322272635273437161D013217333736353735343735232635363B013534373437343736373602EC20800E0608382418240C28441C1C0480044008380480180A12294F0F4918401D53180440400E12183C4C14147C4008387C20204804542E0642142C2C4024083C175D7C2C68408C0408384004345FD110DC6F552A2E04403014242D0B0838101050429A9C54416B280838408C596739671F69255B180000000002005600AE0469032000240049000001333217163B013237363316151407062B012227262F01230607060714072635343736333413333217163B013237363316151407062B012227262F01230607060714072635343736333401A560334D6038781F25242C40543F396071471F551C7C10302F353840703C346160334D6038781F25242C40543F396071471F551C7C10302F353840703C340320446844440838206C3C3C14540811072F191A0A0838383C3C14FEBA446844440838206C3C3C14540811072F191A0A0838383C3C140000020051FFC50431042D001D002E0000013215161716171613321706230F012307230607232635343713363736371706070306153337333237262726272627023D441A323C7037710B0514406C809080D44F25084040A44440035D0434408C20E480A4761E494F5E364A02042D707E423DEB41FEF1285C1004080A16083818980198D9672375E85DC7FEA44A0E080CBF71C53F6729000000000200780000042C03F0001B0035000001161514070607061516171615062322272627263534373637363536051615140703060716171617161506232227262726353437133603BC4044693784C672600838206859BF44A435475408FEB04034E41C3806AA462E1008382D9F534D184CF84803F00A32465285639B11856B23354048578133254AB65D5B6C14401008381C38FEBC1C580B853F19151740903A4A28141C64016070000002006B0000041F03F0001B00350000001714171617161514070607062322273437363734272627263534370417131615140706070623222734373637363726270326353437011308544735A444BF59682038086072C6843769444001B848F84C184D539F2D3808102E46AA06381CE4344003F040146C5B5DB64A25338157484035236B85119B63855246320A1070FEA0641C14284A3A90401715193F850B581C0144381C380800000300420013029A00BA00080011001A00003716151407263D01361736333217062B01260526353437161D01068260604008D4153B3B1508382040013C60604008BA153B3B150838204060606040080F153B3B1508382040FFFF0036FF6A040A071A022200240E9C0003004300FD013EFFFF003DFF92041107170222002415C4000300D4003601D1FFFF00560000045A0703022200320000000300D4007401BD00020067005704AB05330039005800000116172116150623211617113337331615062B01072327230607060F011721321D01062327212723062B0126273427263D0137363F01363B01341714070607060722072207151633161F01333635363736353635112623262301D34D5B0170400838FEE01424C02C40400838342CCC040418100B211008016CA00A3264FEC0800C5020405662442C1C090B4C64480C2C38511B12160705070118143C242C241C3F0D3C1C3729261E0533064A083840247CFEF40808384008045765095710083C0C4008083812760D5F6C5CA0900864C8981B77121A597F23894C14A48C661A1C0C0C3E265A524F550110BC400003002F005703C303A7003300430050000001321716151734373437333217161D010607062B01161F0236331615140F0122272635230607062B0122272635113437363736170F0115161733323F01363D0126233425150733363536373534272306014B1824741C702C60424E2026324C2078253740281424404C2C619B2004175536661C246C48382448403080141C481813213C1C160E01041068301014304C3003A71C59232066360E064C392320873D3C93293014200838322608AC3B11573D60504E2601002F692C7C4888C844E42D2734382A1AD4641F0D306818240C48042410180000000001005601AA03F6022E000B000013172116150623212722273486F00240400838FDC0EC270D022E0408384004402B000001008C01B905CC02390009000013211615062321263536CC04C0400838FB404008023908384008384000000002005D037002A105D8001C00300000011615140714070607220715373316150623222F0135343734373633360516151407060715333217062322273536373633012D40302810180C04041040193B41330C242C3F0D2001484050160A083E0E153B5B29281C442005D808382B150A2E1E5244640408385C5038605E4623495C141008381C684B0D78605C74D07E2668000200070341024B05A9001C00300000012635343734373637323735072326353633321F0115140714070623062526353437363735232227363332171506070623017B40302810180C04041040193B41330C242C3F0D20FEB84050160A083D0F153B5B29281C4420034108382B150A2E1E5244640408385C5038605E4623495C141008381C684B0D78605C74D07E2668000100780333018405A70014000001331615062307061D013217062B01222F01343736012420400838301C4014093F204C1C04581F05A70838407046661C5C608C4CAD9B54000000000100780335018405A90014000013232635363337363D012227363B01321F01140706D820400838301C4014093F204C1C04581F03350838407046661C5C608C4CAD9B5400030050003C03F003C0000A00150021000001171615140723222735360117211615062321263536013217142B01222F0134333402106C2054283B1508FEB82C02F4400838FD00600801E0361A44202F25043403C028151F621E5C4040FE8C08083840093F40FECC786444147C0500000002006B000003C705880028003E000001161D01161716171617161F0114230603060723171506232227262726272627263D0134371237363717060706071516171615161733123735272627262F010247641010251F1E461D27101C4157150B04040838373D224259335D1B6C48FD0361170823612E86501484356F0477452C156F17351405881252381331315719734335387065FED92D67041040781D6F815F5F417616084430012B259612C8537142960458309C2041B701924A18543B8D47592C00FFFF0014FE4802F105770222005C00000002008E3CB60000FFFF0028FF81034406FA0222003C00000003008E006801390001005DFFDE04550572002B0000011615140F0106072207060706150607060714070607062326353437363F01363736373637363736373237360415402C6C2B39085820107059171C54742C041B1D40445E6648521638243E322739164E072125057208381937D03769801B319A0E55372F61097F342C1C083835576682705335375941532D6B0FA94430000001005600AD03BA050D0042000001331615062B010607060F0121161506232107211615062321141716331417161506232227222726352635232635363B01363F0127262726353633173336373633363702F640400838343A564C2820019C400838FE282001F4400838FE00B4304C441C0A3224385662903060400838640616040454442408388C28104479332E5E050D0838400133264A4C083840600838405E861C0B0D1B1D4014507F1D395708384001570404100418244010119F84290F0001006400A0023C039400190000011615140F01153217161F010623222726272635343F0136373601FC40A890226E77210408381F4D4157886C685A2A15039408382FD1800468442C18403C25533E3E2B555C71473000000001006400A0023C0394001900001217161F01161514070607062322273736373633352726353437CF152A5A686C8857414D1F38080421776E2290A84003943047715C552B3E3E53253C40182C44680480D12F38080000000001007FFFF9038305990033000001161D01133336331615142307231617211615062321121D010623263D01340323223D013633173303232722273633173503353601BF40088C3339405C449009130118400838FEF8340838403458A00A3264441804D42D0B0B2DD008080599083820FEE40C0838400CB15B083840FEF34B80400838803A011E3C0C4008010C04404004040118204000000001002F022A0147033E00100000133332153217140F012227222F01343736B9265011075117123A312E053E20033E6E383B2E051E551A352032000000010056FF25016201990014000017232635363337363D012227363B01321F01140706B620400838301C4014093F204C1C04581FDB0838407046661C5C608C4CAD9B54000002005DFED402A1013C001C00300000012635343734373637323735072326353633321F011514071407062306252635343736373523222736333217150607062301D140302810180C04041040193B41330C242C3F0D20FEB84050160A083D0F153B5B29281C4420FED408382C140A2E1F5144640408385C5038605E4623495C141008381D674B0D78605C74D07D276800070069006A04EC04AA00190033003F00520065006D00740000011615140F0106070607062314072635363736373637363F0136053217141F0214071407232227222F01373437363B0117333417061507333217333527342301321F01151423140723222722273534373237051737161F0115140706232227263D01363336051517333527230605151737352706037740A0649D0F32A64507244009BB581C02BA2B496415FDCD2050282C0820584061172C30041C4015170C0404141818040F196440140323325E144028401850260E4C2113FE6818242F550460290F6751141B1D3E01C230141C0417FE3B3C28283C04AA08382DE788AB3147B570090308384EBE6D330ED2495FAC10483C112740383824161A1C4C3854313710040B770D23381410540CFE285C4040A00B05385C803226180C0404086418602C5C18602711207C5088541C681810500C2034302433FFFF0028FF6403FC0718022200240096000300D300560160FFFF000E00000416070A022200280000000300D300740152FFFF0028FF7703FC070D0222002400A90003008D00970159FFFF000E0000041607070222002800000003008E00910146FFFF000E0000041607070222002800000003004300DD012BFFFF002FFFA3038F07140222002C29A30003008DFFEB0160FFFF001AFF95037A070B0222002C1495000300D3FFE60153FFFF00060000036607000222002C00000003008E0027013FFFFF002EFFB0038E07070222002C28B0000300430053012BFFFF0056FFCB045A06FA0222003200CB0003008D00E70146FFFF005DFFBD046107040222003207BD000300D300CC014CFFFF005DFF8F046106DE02220032078F00030043017E0102FFFF0036FFF2035006F20222003800000003008D006E013EFFFF0036FFF203500718022200380000000300D300440160FFFF0036FFF20350070002220038000000030043006A012400010078FFDF011C04000014000013161D0107111715170706232237263D0127113633C4400C1410100838471B1414062E04000838204CFE944C74DB2E40C5663250500164BC000000010057042402AB05B800160000013217161716150623222726270706232635343F01363701DB2E162A4A1808382B194616C84F1D403490495B05B8387153181C40344844A44008382B19783163000000010065043E0381054600240000013316171617163B01363F0116151407062B012227222F0123060722070623263D013437360175202B5D302C3B19081C2C2440682711203781103C38047A061C041824406816054603350B25201B41080838345C1450241411173424083820323E190002007803F50250057100130020000001161716151407062B012627263D01343F0136330715173337352623272306150601685F31583C38306047612C3034164A405C4830283C0404381605710C24442C77254008382F1D2022364824D0041C3014340411072A0000010049FECE017D00D6001A0000251615073217140722070623263D013437363D0123263534373637012540141D0F9C1513161A4044702840481F11D6083844788F4128140838203B052F2D2008382B453701000001004903FC02710574001900001332171617343732353633161506230607140722272627263536892E1621877808182440191B51333C30683C3C24080574380A96146C0C24083854454B210B804527321A4000FFFF0035FFB6037D07090222003600B6000300D7006C0195FFFF0021FFB1030D05D1022200560000000200D7275D0000FFFF0021FFD103FC07090222003D0000000300D7008A0195FFFF001BFFC803FC05E50222005D0000000200D772710000000200DCFF7A01780606000F001D000001161514071507150623263D0137353613161D0117150623263D01273536013840100C0838400C151F400C0838400C08060608381715D0A0A0400838A0A0E05CFBF40838A0A0C0400838C0A0A04000000002004A006B03FA053F0030004A000001161D01373337333217161F0115140706070607062322273433353327352306070623263534373637363D01342F0135361723061D01161D0136371615140F011136373637363D01022B01013E401C348C60466A503C044C7D9B65CB3F212D0B580404042B4115174048293F2C200808B4102420AD4B4070C8A781304C30488468053F0838080410545FCD4CC026A675533937104044083CC40D2F100838311B26120A0A4C9BED684040C4070920C8B4282C0C0838410B30FEF0315F184C7410D4012C0000030064000003B004980021003F00580000011615140706071716150623222F0106232635343736332627263522273633321736033217363332171417161D01140706230723202F013437363736373237361723070607060F0115163B013237363F013534273427263506028040383A12BC180A322E6A7090244034410B021E600B050838199F8E42231115135379403C5079375080FED149041C19378C20092F2236204C1C404B110432CA743755300C14585C4814049808382E16271544181C4030287808382B1934090B360628405C84FE401C0C6C073553314077755C14C84861173F2DA212280880342A464331045864301F2D40542F3D1B2912120C00FFFF0028FF4B034407000222003C00CA0003008D0045014CFFFF0014FE4802F105A00222005C00000002008D40EC000000020050FFF9034C05790024003300001316150715333217321716173217151407060714052315062307263D013735273711271136131517113336373637352726272623984008B49D731359152B09033C2567FED474062E18400C08081409771458F81C64182813357153057908382CC0687402A22440791B291F1814A8BC040838204CD02C2C012CE0014060FE5404D0FEE80917202058840B4D5800020057FE70031B05100030003E0000133215131533321716151714070607060723150607150706232635343735363735232635363B01033523263536333503341315133325363735342726232623B7441C80CD2F84047C5389057F18100C1018245C280C100840083808080840083820A8080C01043D27482E3A153F051070FED00468DA6E3C3D573414091B7041BF205C24163A241C10BC505C0838400138BC0838400401682DFDE7BCFED0441E2E04617F700800000000010057017C03B70240001500001316053317331617161506232227232723242726353697600100402CB433492408383933B42C34FECD511C0802401818080C041824400C081C1C1B1D4000000100500099033803A9002F0000011615140706071517141714171615062322272627071407062B0126353437343736372627263536333217161737363702F8404402B2843020140838375D3E2E885060140C405068017F20C4300838232D9A3E88453303A9083820441BA9046C093B0612161A40882828880A427008382947085C08781C80321E4038623288632D0000010071033401F105BC001D000001161D011615173316150623212635363B01372F010623263534373637340131400C0430400838FF00400838480404041E1E4030074105BC083880A89C0408384008384010DC1C2008381D3316422D000000000100A0034802B805C4002A00000116153217321D011407060F011533321D010623272126353437363F0135262B01060706232635343736330160B01D1710206A3220A0A00A3264FF005C8832421C0B69200533141440281C5405C40917346420601C701814043C0C4008193B386C1E3E2070101C500C08381D4358000100AE035502A605D5003000000133321F0114073217161D01140F011407232635363B01373237323734272627263534373437352723220F01263536333401624093211434362E0C5C7844A04008389460210B07115421471878141C80191F1C40184005D554542329741414202A6230090B08384024201C38141315181C3C1C09031004240408385C0C000003006A000004520554001D0035005700000116151117331615062B0107222734333527352306232635343734373536051615140706070607060706232635363F023637363736033332151615140F013316150623210722273437363F013523220706232635363334014E40082440083854742D0B5C0804181C4034440802B840B88331296F8F7D193B40046C84B43A5EB44815A5207C146C18D0400838FEEC542D0B6023450C281808181C401C2405540838FE6C280838401040440424B41808382B190A4E284018083828F8B0504D8FCBC57008384B95C8F86F79F3750CFD5434155B538D300838400C40246841633818201808385C100003006BFFFA048B056E001D0035005800000116151117331615062B0107222734333527352306232635343734373536051615140706070607060706232635363F023637363736131615113215062B0127161D010623263D0134272322352227353633161D0117331136014F40082440083854742D0B5C0804181C4034440802B840B88331296F8F7D193B40046C84B43A5EB44815274068083804140C0838400C68B80701083840287008056E0838FE6C280838401040440424B41808382B190A4E284018083828F8B0504D8FCBC57008384B95C8F86F79F3750CFDE40838FEDC44400443895040083850834D301C8040083848040120400003007FFFD105030565002D004B006B000001321F01150623151615171407140706072635343736353237352723072235343F01353423220F0123263534373405161514071407140103061506070623263534373637360134373637363303161507113217140F01150623263D0137232635373536331615071507331136021F3B351413255C04908C42824060845567106C3C649064103C484408409803284060B0FE64E8442711181C40587C28CC0138AC024A1F296840082D0B3C0808384008E45C20093F40080CB00905654840205C0836420C6D57112B1A1208383F091113700C1010443E2A4C0418201C083841270E020838267220A818FE68FEF4341C3F391808382C947642DC01380EB21A5244FDB408382CFEDC4030146C804008388064153B70706008382C7430013C600000020079014D038D043D0039004B00000132173736331615140F01161D0106071617161506232227222735230623222706230607263534373635263527363F012635273633321736333603151633363F013527262F010727230607060215336D701513406034380B293C20240838271D14440447414B611C2C313340443840041C14046C0408382759505811BD6F7D73110C2C172D10242C20481C12043D70500C083830302C742C2445333C102E1A403054083C34182507083832161709372D38781C0C640C1440604C1CFE88149449172C1074174D0C08082D371C0001004A04BD044A0565001000001333051733321714072327252326353437D6E40190A02038084020A0FE70F0804005550C0C4038080C0C0D4338080000002801E60001000000000000005000000001000000000001000800570001000000000002000700500001000000000003001500570001000000000004000800570001000000000005002E006C000100000000000600080057000100000000000A0040009A0003000104030002000C02CA0003000104050002001000DA0003000104060002000C00EA0003000104070002001000F60003000104080002001001060003000104090000007001160003000104090001001001940003000104090002000E01860003000104090003002A01940003000104090004001001940003000104090005005C01BE000300010409000600100194000300010409000A0080021A00030001040A0002000C02CA00030001040B00020010029A00030001040C0002000C02CA00030001040E0002000C02E80003000104100002000E02AA0003000104130002001202B80003000104140002000C02CA0003000104150002001002CA0003000104160002000C02CA0003000104190002000E02DA00030001041B0002001002E800030001041D0002000C02CA00030001041F0002000C02CA0003000104240002000E02F800030001042D0002000E030600030001080A0002000C02CA0003000108160002000C02CA000300010C0A0002000C02CA000300010C0C0002000C02CA4F736D6F7369616E20536C6F70707920A920323030352052656C6174696F6E616C2053797374656D7320436F72706F726174696F6E20323030352E20416C6C205269676874732052657365727665642E526567756C61726F736D6F7369616E3A56657273696F6E20312E303056657273696F6E20312E3030204E6F76656D62657220362C20323030352C20696E697469616C2072656C656173655468697320666F6E74207761732063726561746564207573696E6720466F6E742043726561746F7220352E302066726F6D20486967682D4C6F6769632E636F6D006F00620079010D0065006A006E00E9006E006F0072006D0061006C005300740061006E0064006100720064039A03B103BD03BF03BD03B903BA03AC004F0073006D006F007300690061006E002000A90020003200300030003600200054006800650020004F0073006D006F007300690061006E0020004F0072006400650072002E00200041006C006C0020005200690067006800740073002000520065007300650072007600650064002E0052006500670075006C00610072006F0073006D006F007300690061006E003A00560065007200730069006F006E00200033002E0030003000560065007200730069006F006E00200033002E003000300020004E006F00760065006D00620065007200200036002C00200032003000300035002C00200069006E0069007400690061006C002000720065006C0065006100730065005400680069007300200066006F006E00740020007700610073002000630072006500610074006500640020007500730069006E006700200046006F006E0074002000430072006500610074006F007200200035002E0030002000660072006F006D00200048006900670068002D004C006F006700690063002E0063006F006D004E006F0072006D00610061006C0069004E006F0072006D0061006C0065005300740061006E00640061006100720064004E006F0072006D0061006C006E0079041E0431044B0447043D044B0439004E006F0072006D00E1006C006E0065004E0061007600610064006E006F0041007200720075006E0074006100000002000000000000FF270096000000000000000000000000000000000000000000ED0000010201030003000400050006000700080009000A000B000C000D000E000F0010001100120013001400150016001700180019001A001B001C001D001E001F0020002100220023002400250026002700280029002A002B002C002D002E002F0030003100320033003400350036003700380039003A003B003C003D003E003F0040004100420043004400450046004700480049004A004B004C004D004E004F0050005100520053005400550056005700580059005A005B005C005D005E005F0060006100620063006400650066006700680069006A006B006C006D006E006F0070007100720073007400750076007700780079007A007B007C007D007E007F0080008100820083008400850086008700880089008A008B008C008D008E008F0090009100920093009400950096009700980099009A009C009D009E009F00A000A100A200A300A400A500A600A700A800A900AA00AB00AD00AE00AF00B000B100B200B300B400B500B600B700B800B900BA00BB00BC010400BE00BF00C200C300C400C500C600C700C800C900CA00CB00CC00CD00CE00CF00D000D100D300D400D500D600D700D800D900DD00DE00E100E400E500E600E700E800E900EA00EB00EC00ED00EE00EF00F001050106010700F400F500F600BD00DA052E6E756C6C106E6F6E6D61726B696E6772657475726E044575726F07756E693030423907756E693030423207756E693030423300000001FFFF0002.

to outdent a box some twips;
to outdent a box given some twips;
to outdent a box given a number:
  subtract the number from the box's left.
  subtract the number from the box's top.
  add the number to the box's right.
  add the number to the box's bottom.

an outdent is a number.

to outline a box with a color:
  draw the box with the color and the clear color.

a outlinetextmetric is a record with
  a number called otmsize,
  a textmetric called otmtextmetrics,
  3 bytes, \ needed to align structure
  a byte called otmfiller,
  a panose called otmpanosenumber,
  1 bytes, \ needed to align structure
  a number called otmfsselection,
  a number called otmfstype,
  a number called otmscharsloperise,
  a number called otmscharsloperun,
  a number called otmitalicangle,
  a number called otmemsquare,
  a number called otmascent,
  a number called otmdescent,
  a number called otmlinegap,
  a number called otmscapemheight,
  a number called otmsxheight,
  a box called otmrcfontbox,
  a number called otmmacascent,
  a number called otmmacdescent,
  a number called otmmaclinegap,
  a number called otmusminiumppem,
  a spot called otmptsubscriptsize,
  a spot called otmptsubscriptoffset,
  a spot called otmptsuperscriptsize,
  a spot called otmptsuperscriptoffset,
  a number called otmsstrikeoutsize,
  a number called otmsstrikeoutposition,
  a number called otmsunderscoresize,
  a number called otmsunderscoreposition,
  a pointer called otmpfamilyname,
  a pointer called otmpfacename,
  a pointer called otmpstylename,
  a pointer called otmpfullname.

to output the arc of an ellipse given a string:
  put 2761/10000 into a ratio. \ 2/3*(sqrt(2)-1)
  put the ellipse's center into a center spot.
  put the ellipse's x-extent divided by 2 into a half width.
  put the ellipse's y-extent divided by 2 into a half height.
  put the ellipse's x-extent times the ratio into an x offset.
  put the ellipse's y-extent times the ratio into a y offset.
  \ control point 1
  if the string is "left-top", put the ellipse's left and the center's y minus the y offset into a first control spot.
  if the string is "right-top", put the center's x plus the x offset and the ellipse's top into the first control spot.
  if the string is "right-bottom", put the ellipse's right and the center's y plus the y offset into the first control spot.
  if the string is "left-bottom", put the center's x minus the x offset and the ellipse's bottom into the first control spot.
  \ control point 2
  if the string is "left-top", put the center's x minus the x offset and the ellipse's top into a second control spot.
  if the string is "right-top", put the ellipse's right and the center's y minus the y offset into the second control spot.
  if the string is "right-bottom", put the center's x plus the x offset and the ellipse's bottom into the second control spot.
  if the string is "left-bottom", put the ellipse's left and the center's y plus the y offset into the second control spot.
  \ ending point
  if the string is "left-top", put the ellipse's left plus the half width and the ellipse's top into an ending spot.
  if the string is "right-top", put the ellipse's right and the ellipse's top plus the half height into the ending spot.
  if the string is "right-bottom", put the ellipse's right minus the half width and the ellipse's bottom into the ending spot.
  if the string is "left-bottom", put the ellipse's left and the ellipse's bottom minus the half height into the ending spot.
  \ spit it out
  output the first control spot without advancing.
  output the second control spot without advancing.
  output the ending spot without advancing.
  output "c".

to output lineto given a spot:
  output the spot without advancing.
  output "l".

to output lineto given an x number and a y number:
  put the x and the y into a spot.
  output lineto given the spot.

to output moveto given a spot:
  output the spot without advancing.
  output "m".

to output moveto given an x number and a y number:
  put the x and the y into a spot.
  output moveto given the spot.

to output a number without advancing:
  convert the number to a string.
  output the string without advancing.
  output " " without advancing.

to output the pdf border given a color:
  if the color is the pdf state's current border, exit.
  output the color without advancing.
  output " RG".
  put the color into the pdf state's current border.

to output the pdf fill given a color:
  if the color is the pdf state's current fill, exit.
  output the color without advancing.
  output " rg".
  put the color into the pdf state's current fill.

to output setcolor given a border color and a fill color:
  if the fill is not clear, output the pdf fill given the fill.
  if the border is not clear, output the pdf border given the border.

to output a spot without advancing:
  output the spot's x without advancing.
  output the pdf state's current height minus the spot's y without advancing.

to output a string:
  append the string to the pdf state's current contents.

to output a string without advancing:
  append the string to the pdf state's current contents without advancing.

to output stroke and fill given a border color and a fill color:
  put "B" into a string. \ stroke and fill
  if the fill is clear,   put "S" into the string. \ stroke
  if the border is clear, put "f" into the string. \ fill
  output the string.

a pabc is a pointer to an abc.

a paintstruct is a record with
  an hdc called hdc,
  a number called ferase,
  a box called rcpaint,
  a number called frestore,
  a number called fincupdate,
  32 bytes.

a pair has an x number and a y number.

a panose is a record with
  a byte called bfamilytype,
  a byte called bserifstyle,
  a byte called bweight,
  a byte called bproportion,
  a byte called bcontrast,
  a byte called bstrokevariation,
  a byte called barmstyle,
  a byte called bletterform,
  a byte called bmidline,
  a byte called bxheight.

to parse a command line returning some string things:
  clear the string things.
  if the command line is blank, exit.
  slap a rider on the command line.
  loop.
    if the rider is stashable,
      stash the rider's token in the string things.
    if the rider's source is blank, exit.
    if the rider's source's first's target is the double-quote byte,
      reverse a flag called quote flag.
    if the rider's source's first's target is noise,
      set a flag called noise flag.
    \ consecutive noise bytes are treated as a single delimiter.
    if the quote flag is set, clear the noise flag.
    if the rider's source's first's target is not noise,
      clear the noise flag.
    if the rider's token is stashable given the noise flag,
      stash the rider's token in the string things.
    if the noise flag is set,
      position the rider's token on the rider's source.
    bump the rider.
  repeat.

to parse a string returning some string things (within an option):
  clear the string things.
  if the string is blank, exit.
  slap a rider on the string.
  put the semi-colon byte in a byte called splitter.
  loop.
    if the rider's source is blank,
      stash the rider's token in the string things given the splitter;
      exit.
    if the rider's source's first's target is the double-quote byte,
      reverse a flag called quote flag.
    if the rider's source's first's target is the splitter,
      set a flag called splitter flag.
    if the quote flag is set, clear the splitter flag.
    if the splitter flag is set,
      stash the rider's token in the string things given the splitter;
      position the rider's token on the rider's source.
    clear the splitter flag.
    \ consecutive splitter flags are treated
    \ as separating zero-length tokens.
    bump the rider.
  repeat.

a path is a string. \ complete name = c:\folder1\folder2\file.ext

a pchar is a byte pointer.

a pdevmode is a pointer to a devmode.

a pdf is a buffer.

a pdf object is a thing with
  a kind [contents, font definition, font descriptor, font streamoutline, image object, outline entry, page, parent, root],
  a number,
  an offset,
  a data buffer,
  a font name [font definition],
  a font info [font definition],
  some string things called font strings [page],
  some string things called image strings [page].

a pdf outline entry is a thing with
  a pdf object (reference),
  a title string,
  a page height,
  a destination number.

a pdf pointer is a pointer to a pdf.

a pdf state has
  a pdf pointer,
  a document flag,
  a page flag,
  an object number,
  some pdf objects called objects,
  an xref offset,
  an outline pdf object (reference),
  some pdf outline entries called outline entries,
  a root pdf object (reference),
  a parent pdf object (reference),
  a current contents pdf object (reference),
  a current page pdf object (reference),
  a current height,
  a current border color,
  a current fill color,
  a font index.

the pdf state is a pdf state.

a pdf string is a string.
   \ string surrounded by ( )
   \ and has \( for left paren, \) for right paren, \\ for backslash

the pen size is a number.

a percent is a number. \ a scale with 100 in the denominator

to pick a number:
  pick the number between 0 and the largest number.

to pick a number within an amount of another number:
  pick the number between the other number minus the amount
    and the other number plus the amount.

to pick a spot anywhere in a box:
  pick the spot's x between the box's left and the box's right.
  pick the spot's y between the box's top and the box's bottom.

to pick a spot within a distance of another spot:
  pick the spot's x within the distance of the other spot's x.
  pick the spot's y within the distance of the other spot's y.

to pick some twips between some min twips and some other twips; \ are all these necessary? ***
to pick a number between some min twips and some other twips;
to pick a number between a min number and a max number;
to pick a number from a min number to a max number;
to set a number to something between another number and a third number;
to pick a random number between a min number and a max number:
  put the seed's whereabouts into eax.
  \ put address of randseed into ecx
  intel $8BC8.         \ mov ecx,eax
  \ calculate zero based max
  intel $8B8510000000. \ mov eax,[ebp+16] \ the max
  intel $8B00.         \ mov eax,[eax]
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the min
  intel $2B03.         \ sub eax,[ebx]
  intel $40.           \ inc eax
  \ adjust randseed
  intel $691105840808. \ imul edx,[ecx],134775813
  intel $42.           \ inc edx
  intel $8911.         \ mov [ecx],edx
  \ mul adjusted randseed by the zero based max
  intel $F7E2.         \ mul edx
  \ add the min to un-zero base the number
  intel $0313.         \ add edx,[ebx] the min
  \ store the result
  intel $8B9D08000000. \ mov ebx,[ebp+08] \ the random number
  intel $8913.         \ mov [ebx],edx

a picture is a thing with
 \ all boxes are in twits
  a box [location of cropped picture on the page],
  a uncropped box [location of entire picture on the page],
  a grayscale flag,
  a mirror flag,
  a rotate angle, \ rotation is clockwise
  a hex string called data [original bytes in original format],
  a gpbitmap.

to play a wave:
  if cannot find "PlaySound" in "winmm.dll", exit.
  call "winmm.dll" "PlaySound" with the wave's first and 0 and 5 [snd_memory+snd_async].

to play a wave and wait:
  if cannot find "PlaySound" in "winmm.dll", exit.
  call "winmm.dll" "PlaySound" with the wave's first and 0 and 4 [snd_memory+snd_sync].

to play a wave file:
  if cannot find "PlaySound" in "winmm.dll", exit.
  privatize the wave file.
  null terminate the wave file.
  call "winmm.dll" "PlaySound"
    with the wave file's first and 0 and 131073 [snd_filename+snd_async].

to play a wave file and wait:
  if cannot find "PlaySound" in "winmm.dll", exit.
  privatize the wave file.
  null terminate the wave file.
  call "winmm.dll" "PlaySound"
    with the wave file's first and 0 and 131072 [snd_filename+snd_sync].

a pointer has 4 bytes.

a polygon is a thing with some vertices.

a portrait sheet is a sheet.

to position a substring on a string:
  intel $8B8508000000. \ mov eax,[ebp+8] \ the substring
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the string
  \ put the string's first into the substring's first
  intel $8B8B00000000. \ mov ecx,[ebx+0] \ the string's first
  intel $898800000000. \ mov [eax+0],ecx \ the substring's first
  \ put the string's first minus 1 into the substring's last
  intel $49.           \ dec ecx
  intel $898804000000. \ mov [eax+4],ecx \ the substring's last

to post a data string to a url and receive a response string:
  \ only works with http and https
  clear the response.
  clear the i/o error.
  create a winhttp request for posting to the url.
  if the i/o error is not blank, exit.
  send the data to the winhttp request.
  if the i/o error is not blank, destroy the winhttp request; exit.
  receive the response from the winhttp request.
  if the i/o error is not blank, destroy the winhttp request; exit.
  read the response from the winhttp request.
  if the i/o error is not blank, destroy the winhttp request; exit.
  destroy the winhttp request.

a poutlinetextmetric is a pointer to an outlinetextmetric.

the ppi is some twips.

a prefix is a string.

to prepend a byte to a string:
  put the string's length into a saved length.
  reassign the string's first given the string's length plus 1.
  copy bytes from the string's first to the string's first plus 1 for the saved length.
  put the string's first plus the saved length into the string's last.
  put the byte into the string's first's target.

to prepend a string to another string:
  put the other string's length plus the string's length into a combined length.
  reassign a pointer given the combined length.
  put the pointer into a substring's first.
  copy bytes from the string's first to the substring's first for the string's length.
  add the string's length to the substring's first.
  copy bytes from the other string's first to the substring's first for the other string's length.
  unassign the other string's first. \ to avoid extra allocates and copies
  put the pointer into the other string's first.
  put the other string's first plus the combined length minus 1 into the other string's last.

to prepend a thing to some things:
  if the thing is nil, exit.
  put the things' first into the thing's next.
  if the things is not empty, put the thing into the things' first's previous.
  if the things are empty, put the thing into the things' last.
  put the thing into the things' first.

to prepend some things to some other things:
  loop.
    if the things are empty, exit.
    put the things' last into a thing.
    if the thing is nil, exit.
    remove the thing from the things.
    prepend the thing to the other things.
  repeat.

a printdlgex is a record with
  a number called lstructsize,
  a window called hwndowner,
  a handle called hdevmode,
  a handle called hdevnames,
  a canvas called hdc,
  a number called flags,
  a number called flags2,
  a number called exclusionflags,
  a number called npageranges,
  a number called nmaxpageranges,
  a pointer called lppageranges,
  a number called nminpage,
  a number called nmaxpage,
  a number called ncopies,
  a handle called hinstance,
  a pointer called lpprinttemplatename,
  a pointer called lpcallback,
  a number called npropertypages,
  a pointer called lphpropertypages,
  a number called nstartpage,
  a number called dwresultaction.

the printer canvas is a canvas.

the printer device mode handle is a handle.

a process is a handle.

a process pointer is a pointer to a process.

a processinfo is a record with
  a handle called hprocess,
  a handle called hthread,
  a number called dwprocessid,
  a number called dwthreadid.

a punch line is a string.

to put the actual data of a font into a buffer:
  \ only works with true/open type fonts
  create the hfont of the memory canvas given the font.
  call "gdi32.dll" "GetFontData" with the memory canvas
    and 0 and 0 and nil and 0 returning a count.
  reassign the buffer's first given the count.
  call "gdi32.dll" "GetFontData" with the memory canvas
    and 0 and 0 and the buffer's first and the count.
  put the buffer's first plus the count minus 1 into the buffer's last.
  destroy the hfont of the memory canvas.

to put the bottom of a box into a horizontal line;
to put the bottom edge of a box into a horizontal line;
to put the bottom side of a box into a horizontal line:
  put the box's left-bottom into the horizontal line's start.
  put the box's right-bottom into the horizontal line's end.

to put the bottom of a box into a line:
  make the line with the box's left-bottom and the box's right-bottom.

to put a box and a radius into a roundy box:
  put the box's left into the roundy box's left.
  put the box's top into the roundy box's top.
  put the box's right into the roundy box's right.
  put the box's bottom into the roundy box's bottom.
  put the radius into the roundy box's radius.

to put a box in the center of another box;
to center a box in another box:
  center the box in the other box (horizontally).
  center the box in the other box (vertically).

to put a box in the center of the screen;
to center a box on the screen:
  center the box in the screen's box.

to put a box into another box:
  put the box's left into the other box's left.
  put the box's top into the other box's top.
  put the box's right into the other box's right.
  put the box's bottom into the other box's bottom.

to put a box on a spot;
to center a box on a spot:
  get a difference between the spot and the box's center.
  round the difference to the nearest multiple of the tpp.
  move the box given the difference.

to put a box's bottom line into a horizontal line: \ and "vertical" for left and right
  put the box's left and the box's bottom into the horizontal line's start.
  put the box's right and the box's bottom into the horizontal line's end.

to put a box's bottom-center into a spot: \ *** need these without dashs too
  put the box's center's x into the spot's x.
  put the box's bottom into the spot's y.

to put a box's center into a spot:
  put the box's left plus the box's right into the spot's x.
  put the box's top plus the box's bottom into the spot's y.
  divide the spot by 2.

to put a box's center-bottom into a spot:
  put the box's center's x into the spot's x.
  put the box's bottom into the spot's y.

to put a box's center-top into a spot:
  put the box's center's x into the spot's x.
  put the box's top into the spot's y.

to put a box's height into a height:
  put the box's bottom into the height.
  subtract the box's top from the height.
  add the tpp to the height.

to put a box's left line into a line:
  put the box's left and the box's top into the line's start.
  put the box's left and the box's bottom into the line's end.

to put a box's left-bottom into a spot:
  put the box's left into the spot's x.
  put the box's bottom into the spot's y.

to put a box's left-center into a spot:
  put the box's left into the spot's x.
  put the box's center's y into the spot's y.

to put a box's right line into a line:
  put the box's right and the box's top into the line's start.
  put the box's right and the box's bottom into the line's end.

to put a box's right-center into a spot:
  put the box's right into the spot's x.
  put the box's center's y into the spot's y.

to put a box's right-top into a spot:
  put the box's right into the spot's x.
  put the box's top into the spot's y.

to put a box's top line into a horizontal line:
  put the box's left and the box's top into the horizontal line's start.
  put the box's right and the box's top into the horizontal line's end.

to put a box's top-center into a spot:
  put the box's center's x into the spot's x.
  put the box's top into the spot's y.

to put a box's width into a width:
  put the box's right into the width.
  subtract the box's left from the width.
  add the tpp to the width.

to put a box's x-extent into a width:
  put the box's right into the width.
  subtract the box's left from the width.

to put a box's y-extent into a height:
  put the box's bottom into the height.
  subtract the box's top from the height.

to put a byte and a number into a ratio:
  put the byte into the ratio's numerator.
  put the number into the ratio's denominator.

to put a byte into a number:
  intel $8B8508000000. \ mov eax,[ebp+8] \ the byte
  intel $0FB600.       \ movzx eax,byte ptr [eax]
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the number
  intel $8903.         \ mov [ebx],eax

to put the character under a finger into a character:
  if the finger is nil, clear the character; exit.
  put the finger's target into the character.

to put a date/time into another date/time:
  put the date/time's year into the other date/time's year.
  put the date/time's month into the other date/time's month.
  put the date/time's week day into the other date/time's week day.
  put the date/time's day into the other date/time's day.
  put the date/time's hour into the other date/time's hour.
  put the date/time's minute into the other date/time's minute.
  put the date/time's second into the other date/time's second.
  put the date/time's millisecond into the other date/time's millisecond.

to put a date/time's string into a string:
  clear the string.
  append the date/time's year to the string.
  append "/" to the string.
  zero fill the date/time's month given 2 and append it to the string.
  append "/" to the string.
  zero fill the date/time's day given 2 and append it to the string.
  append " " to the string.
  zero fill the date/time's hour given 2 and append it to the string.
  append ":" to the string.
  zero fill the date/time's minute given 2 and append it to the string.
  append ":" to the string.
  zero fill the date/time's second given 2 and append it to the string.
  append ":" to the string.
  zero fill the date/time's millisecond given 3 and append it to the string.

to put eax into a byte:
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the number
  intel $8803.         \ mov [ebx],al

to put eax into a flag;
to put eax into a pointer;
to put eax into a number:
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the number
  intel $8903.         \ mov [ebx],eax

to put eax into a wyrd:
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the wyrd
  intel $668903.       \ mov [ebx],ax

to put an ellipse in the middle of a box;
to center an ellipse in a box:
  center the ellipse in the box (horizontally).
  center the ellipse in the box (vertically).

to put an ellipse into another ellipse:
  put the ellipse's box into the other ellipse's box.

to put an ellipse on a spot;
to center an ellipse on a spot:
  center the ellipse's box on the spot.

to put a finger on the first character of a string:
  put the string's first into the finger.

to put a font into another font:
  if the font is the other font, exit.
  put the font's name into the other font's name.
  put the font's height into the other font's height.

to put some font widths into a buffer: \ used for pdf conversion
  clear the buffer.
  if the font widths are nil, exit.
  put the font widths' data into a number pointer.
  loop.
    if a counter is past the font widths' count, break.
    append the number pointer's target then " " to the buffer.
    add 1 to a count.
    if the count is evenly divisible by 16, append the crlf string to the buffer.
    add a number's magnitude to the number pointer.
  repeat.

to put a font's adjusted height into a height:
  put the font's height times 3/4 into the height.

to put a gpimage's gprect into a gprect:
  put 0 into the gprect's x.
  put 0 into the gprect's y.
  put the gpimage's width into the gprect's width.
  put the gpimage's height into the gprect's height.

to put a gpimage's height into a height:
  if the gpimage is nil, put 0 into the height; exit.
  call "gdiplus.dll" "GdipGetImageHeight" with the gpimage and the height's whereabouts.

to put a gpimage's width into a width:
  if the gpimage is nil, put 0 into the width; exit.
  call "gdiplus.dll" "GdipGetImageWidth" with the gpimage and the width's whereabouts.

to put a gprect into another gprect:
  put the gprect's x into the other gprect's x.
  put the gprect's y into the other gprect's y.
  put the gprect's width into the other gprect's width.
  put the gprect's height into the other gprect's height.

to put an index's count into a count:
  put 0 into the count.
  if the index is nil, exit.
  loop.
    get a bucket given the index.
    if the bucket is nil, exit.
    add the bucket's refers' count to the count.
  repeat.

to put an index's used bucket count into a count:
  put 0 into the count.
  if the index is nil, exit.
  loop.
    get a bucket given the index.
    if the bucket is nil, exit.
    if the bucket's refers are empty, repeat.
    add 1 to the count.
  repeat.

to put a left coord and a top coord and a right coord and a bottom coord and a radius into a roundy box:
  put the left into the roundy box's left.
  put the top into the roundy box's top.
  put the right into the roundy box's right.
  put the bottom into the roundy box's bottom.
  put the radius into the roundy box's radius.

to put a left coord and a top coord and a right coord and a bottom coord into a box:
  put the left into the box's left.
  put the top into the box's top.
  put the right into the box's right.
  put the bottom into the box's bottom.

to put a left coord and a top coord and a right coord and a bottom coord into an ellipse:
  put the left into the ellipse's left.
  put the top into the ellipse's top.
  put the right into the ellipse's right.
  put the bottom into the ellipse's bottom.

to put the left of a box into a vertical line;
to put the left edge of a box into a vertical line;
to put the left side of a box into a vertical line:
  put the box's left-top into the vertical line's start.
  put the box's left-bottom into the vertical line's end.

to put a line in the middle of a box;
to center a line in a box:
  center the line in the box (horizontally).
  center the line in the box (vertically).

to put a line into another line:
  put the line's start into the other line's start.
  put the line's end into the other line's end.

to put a line's box into a box:
  put the line's start into the box's left-top.
  put the line's end into the box's right-bottom.
  normalize the box.

to put a line's center into a spot:
  put the line's start's x plus the line's end's x into the spot's x.
  put the line's start's y plus the line's end's y into the spot's y.
  divide the spot by 2.

to put a line's left into a coord:
  put the line's start's x into the coord.
  if the line's end's x is less than the line's start's x, put the line's end's x into the coord.

to put a line's right into a coord:
  put the line's start's x into the coord.
  if the line's end's x is greater than the line's start's x, put the line's end's x into the coord.

to put a line's top into a coord:
  put the line's start's y into the coord.
  if the line's end's y is less than the line's start's y, put the line's end's y into the coord.

to put the middle of a line on a spot;
to center a line on a spot:
  get a difference between the spot and the line's center.
  round the difference to the nearest multiple of the tpp.
  move the line given the difference.

to put the mouse's spot into a spot:
  call "user32.dll" "GetCursorPos" with the spot's whereabouts.
  call "user32.dll" "ScreenToClient" with the main window
    and the spot's whereabouts. \ in case window is on another monitor.
  call "gdi32.dll" "DPtoLP"
    with the screen canvas and the spot's whereabouts and 1.

to put a name and a height into a font:
  put the name into the font's name.
  put the height into the font's height.

to put a number and another number into a pair:
  put the number into the pair's x.
  put the other number into the pair's y.

to put a number and another number into a ratio:
  put the number into the ratio's numerator.
  put the other number into the ratio's denominator.

to put a number into a big-endian unsigned wyrd:
  put the number into a wyrd.
  put the wyrd into the big-endian unsigned wyrd.

to put a number into a pair:
  put the number into the pair's x.
  put the number into the pair's y.

to put a number into a ratio:
  put the number into the ratio's numerator.
  put 1 into the ratio's denominator.

to put a number into a wyrd:
  intel $8B8508000000. \ mov eax,[ebp+8] \ the number
  intel $8B00.         \ mov eax,[eax]
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the wyrd
  intel $668903.       \ mov [ebx],ax

to put a number's absolute value into another number:
  put the number into the other number.
  de-sign the other number.

to put an outlinetextmetric into another outlinetextmetric:
  copy bytes from the outlinetextmetric's whereabouts
    to the other outlinetextmetric's whereabouts for the outlinetextmetric's magnitude.

to put a pair into another pair:
  put the pair's x into the other pair's x.
  put the pair's y into the other pair's y.

to put a pair's absolute value into another pair:
  put the pair into the other pair.
  de-sign the other pair.

to put a picture in the middle of a box;
to center a picture in a box:
  if the picture is nil, exit.
  center the picture in the box (horizontally).
  center the picture in the box (vertically).

to put a picture on a spot;
to center a picture on a spot:
  if the picture is nil, exit.
  get a difference between the spot and the picture's box's center.
  round the difference to the nearest multiple of the tpp.
  move the picture given the difference.

to put a pointer into another pointer;
to put a pointer into a number;
to put a number into a flag;
to put a number into a pointer;
to put a flag into another flag;
to put a flag into a number;
to put a number into another number:
  intel $8B8508000000. \ mov eax,[ebp+8] \ the number
  intel $8B00.         \ mov eax,[eax]
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the other number
  intel $8903.         \ mov [ebx],eax

to put a pointer into eax;
to put a flag into eax;
to put a number into eax:
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the number
  intel $8B03.         \ mov eax,[ebx]

to put a polygon in the middle of a box;
to center a polygon in a box:
  if the polygon is nil, exit.
  center the polygon in the box (horizontally).
  center the polygon in the box (vertically).

to put a polygon in the middle of the screen;
to center a polygon on the screen:
  center the polygon in the screen's box.

to put a polygon on a spot;
to center a polygon on a spot:
  if the polygon is nil, exit.
  get a difference between the spot and the polygon's box's center.
  round the difference to the nearest multiple of the tpp.
  move the polygon given the difference.

to put a polygon's box into a box:
  if the polygon is nil, clear the box; exit.
  if the polygon's vertices are empty, clear the box; exit.
  put the largest number and the largest number and the smallest number and the smallest number into the box.
  loop.
    get a vertex from the polygon's vertices.
    if the vertex is nil, break.
    if the vertex's x is less than the box's left, put the vertex's x into the box's left.
    if the vertex's y is less than the box's top, put the vertex's y into the box's top.
    if the vertex's x is greater than the box's right, put the vertex's x into the box's right.
    if the vertex's y is greater than the box's bottom, put the vertex's y into the box's bottom.
  repeat.

to put a polygon's center into a spot:
  if the polygon is nil, clear the spot; exit.
  put the polygon's box's center into the spot.

to put a polygon's center-bottom into a spot:
  if the polygon is nil, clear the spot; exit.
  put the polygon's box's center-bottom into the spot.

to put a polygon's center-top into a spot:
  if the polygon is nil, clear the spot; exit.
  put the polygon's box's center-top into the spot.

to put a polygon's height into a height:
  if the polygon is nil, clear the height; exit.
  put the polygon's box's height into the height.

to put a polygon's left-bottom into a spot:
  if the polygon is nil, clear the spot; exit.
  put the polygon's box's left-bottom into the spot.

to put a polygon's left-center into a spot:
  if the polygon is nil, clear the spot; exit.
  put the polygon's box's left-center into the spot.

to put a polygon's left-top into a spot:
  if the polygon is nil, clear the spot; exit.
  put the polygon's box's left-top into the spot.

to put a polygon's right-bottom into a spot:
  if the polygon is nil, clear the spot; exit.
  put the polygon's box's right-bottom into the spot.

to put a polygon's right-center into a spot:
  if the polygon is nil, clear the spot; exit.
  put the polygon's box's right-center into the spot.

to put a polygon's right-top into a spot:
  if the polygon is nil, clear the spot; exit.
  put the polygon's box's right-top into the spot.

to put a polygon's width into a width:
  if the polygon is nil, clear the width; exit.
  put the polygon's box's width into the width.

to put a polygon's x-extent into a width:
  if the polygon is nil, clear the width; exit.
  put the polygon's box's x-extent into the width.

to put a polygon's y-extent into a height:
  if the polygon is nil, clear the height; exit.
  put the polygon's box's y-extent into the height.

to put a ratio pair into another ratio pair:
  put the ratio pair's ratio into the other ratio pair's ratio.
  put the ratio pair's other ratio into the other ratio pair's other ratio.

to put a ratio's absolute value into another ratio:
  put the ratio into the other ratio.
  de-sign the other ratio.

to put a rider into another rider:
  copy bytes from the rider's whereabouts to the other rider's whereabouts for the rider's magnitude.

to put the right of a box into a vertical line;
to put the right edge of a box into a vertical line;
to put the right side of a box into a vertical line:
  put the box's right-top into the vertical line's start.
  put the box's right-bottom into the vertical line's end.

to put a roundy box into another roundy box:
  put the roundy box's left into the other roundy box's left.
  put the roundy box's top into the other roundy box's top.
  put the roundy box's right into the other roundy box's right.
  put the roundy box's bottom into the other roundy box's bottom.
  put the roundy box's radius into the other roundy box's radius.

to put a sockaddr into another sockaddr:
  copy bytes from the sockaddr's whereabouts to the other sockaddr's whereabouts for the sockaddr's magnitude.

to put a spot and another spot and a radius into a roundy box:
  put the spot into the roundy box's left-top.
  put the other spot into the roundy box's right-bottom.
  put the radius into the roundy box's radius.

to put a spot and another spot into a box:
  put the spot into the box's left-top.
  put the other spot into the box's right-bottom.

to put a spot and another spot into an ellipse:
  put the spot into the ellipse's left-top.
  put the other spot into the ellipse's right-bottom.

to put a spot and another spot into a line:
  put the spot into the line's start.
  put the other spot into the line's end.

to put a spot in the middle of a box;
to center a spot in a box:
  center the spot in the box (horizontally).
  center the spot in the box (vertically).

to put the square root of a number in a result number:
  \ Rounds down.  Finds magnitude of the square root.
  privatize the number.
  if the number is 0, put 0 into the result; exit.
  if the number is negative,
    negate the number.  \ similar to cal-4700's behavior.
  if the number is 1, put 1 into the result; exit.
  if the number is at most 100,
    put the square root of the number in the result (close); exit.
  if the number is at least the largest square,
    put the largest square root into the result; exit.
  \40971 * 40971 is 1678622841
  if the number is at least 1678622841,
    put 40971 into a number called lower bound;
    put the largest square root minus 1 into a number called upper bound;
    put the square root of the number in the result
      given the lower bound and the upper bound; 
    exit.
  \Perform binary search on the possible answers, 
  \to narrow down the answer to ten possibilities 
  \that are checked linearly.
  \4096 = 12 binary splits.
  \10 + 1         =    11 = lower bound 
  \10 + 10 * 4096 = 40970 = upper bound 
  put 11 into the lower bound.
  put 40970 into the upper bound.
  put the square root of the number into the result 
    given the lower bound and the upper bound.

to put the square root of a number in a result number (close): 
  if the number is at most 0, 
    put 0 into the result; exit.
  put the result times the result into a number called square.
  if the square is at least the number, exit.
  put the result plus the result in a number called margin.
  add 1 to the margin.
  put the square plus the margin in a number called next square.
  loop.
    if the next square is more than the number, exit.
    add 1 to the result.
    put the next square in the square.
    add 2 to the margin.
    add the margin to the next square.
  repeat.

to put the square root of a number in a result number given a lower bound number and an upper bound number:
  \uses binary search.  The bounds are inclusive.
  privatize the lower bound.
  privatize the upper bound.
  if the upper bound is greater than the largest square root, 
    put the largest square root in the upper bound.
  if the upper bound times the upper bound is less than the number, 
    put the upper bound in the result; exit.
  if the lower bound times the lower bound is at least the number, 
    put the lower bound in the result; exit.
  loop.
    put the lower bound plus 10 in a number called threshold.
    if the upper bound is less than the threshold, 
      put the lower bound into the result; 
      put the square root of the number into the result (close);
      exit.
    put the lower bound in a number called midpoint.
    add the upper bound to the midpoint.
    add 1 to the midpoint.
    divide the midpoint by 2.
    put the midpoint times the midpoint in a number called mid square.
    if the number is less than the mid square, 
      subtract 1 from the midpoint; 
      put the midpoint in the upper bound; 
      repeat.
    put the midpoint in the lower bound.
  repeat.

to put a string into another string:
  put the string's length into a saved length.
  assign a pointer given the saved length.
  copy bytes from the string's first to the pointer for the saved length.
  unassign the other string's first.
  put the pointer into the other string's first.
  put the other string's first plus the saved length minus 1 into the other string's last.

to put a string on the windows clipboard:
  call "user32.dll" "OpenClipboard" with the main window.
  call "user32.dll" "EmptyClipboard".
  put the string's length plus 1 into a number.
  call "kernel32.dll" "GlobalAlloc" with 66 [ghnd] and the number returning a handle.
  call "kernel32.dll" "GlobalLock" with the handle returning a pointer.
  copy bytes from the string's first to the pointer for the string's length.
  call "kernel32.dll" "GlobalUnlock" with the handle.
  call "user32.dll" "SetClipboardData" with 1 [cf_text] and the handle.
  call "user32.dll" "CloseClipboard".

to put a string's length into a length:
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the string
  \ load default result
  intel $B900000000.   \ mov ecx,0
  \ if first is 0, store 0
  intel $833B00.       \ cmp [ebx],0
  intel $0F8414000000. \ je store it
  \ if last is less than first, store 0
  intel $8B5304.       \ mov edx,[ebx+4] \ last pointer
  intel $3B13.         \ cmp edx,[ebx]
  intel $0F8C09000000. \ jl store it
  \ calc length
  intel $8B8B04000000. \ mov ecx,[ebx+4] \ last pointer
  intel $2B0B.         \ sub ecx,[ebx]   \ subtract first
  intel $41.           \ inc ecx         \ add 1
  \ STORE IT:
  intel $8B950C000000. \ mov edx,[ebp+12] \ the number
  intel $890A.         \ mov [edx],ecx

to put a string's width into a width:
  get the width given the string and the memory canvas and the default font.

to put a substring into another substring:
  copy bytes from the substring's whereabouts
    to the other substring's whereabouts for the substring's magnitude.

to put the system's date/time into a date/time:
  call "kernel32.dll" "GetLocalTime" with a systemtime's whereabouts.
  put the systemtime's wyear into the date/time's year.
  put the systemtime's wmonth into the date/time's month.
  put the systemtime's wdayofweek into the date/time's week day.
  put the systemtime's wday into the date/time's day.
  put the systemtime's whour into the date/time's hour.
  put the systemtime's wminute into the date/time's minute.
  put the systemtime's wsecond into the date/time's second.
  put the systemtime's wmilliseconds into the date/time's millisecond.

to put the system's last error into a number:
  call "kernel32.dll" "GetLastError" returning the number.

to put the system's last winsock error into a number:
  call "ws2_32.dll" "WSAGetLastError" returning the number.

to put the system's tick count into some ticks: \ wraps every 24.8 days or so
  call "kernel32.dll" "GetTickCount" returning the ticks.
  bitwise and the ticks with the largest number.

to put a thing at the end of some things;
to append a thing to some things:
  if the thing is nil, exit.
  put the things' last into the thing's previous.
  if the things are not empty, put the thing into the things' last's next.
  if the things are empty, put the thing into the things' first.
  put the thing into the things' last.

to put some things into some other things:
  put the things' first into the other things' first.
  put the things' last into the other things' last.

to put some things' count into a count:
  put 0 into the count.
  loop.
    get a thing from the things.
    if the thing is nil, exit.
    add 1 to the count.
  repeat.

to put a timer's string into a string:
  convert the timer's ticks to the string.

to put a timer's ticks into some ticks:
  put the timer's total ticks into the ticks.
  if the timer's count is 0, exit.
  put the system's tick count into some other ticks.
  subtract the timer's start ticks from the other ticks.
  add the other ticks to the ticks.

to put the top of a box into a horizontal line;
to put the top edge of a box into a horizontal line;
to put the top side of a box into a horizontal line:
  put the box's left-top into the horizontal line's start.
  put the box's right-top into the horizontal line's end.

to put a wyrd into another wyrd:
  intel $8B8508000000. \ mov eax,[ebp+8]  \ the wyrd
  intel $668B00.       \ mov ax,[eax]
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the other wyrd
  intel $668903.       \ mov [ebx],ax

to put a wyrd into a big-endian unsigned wyrd:
  intel $8B8508000000. \ mov eax,[ebp+8]  \ the wyrd
  intel $668B00.       \ mov ax,word ptr [eax]
  intel $86E0.         \ xchg al,ah
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the big-endian unsigned wyrd
  intel $668903.       \ mov word ptr [ebx],ax

to put a wyrd into a byte:
  intel $8B8508000000. \ mov eax,[ebp+8]  \ the wyrd
  intel $668B00.       \ mov ax,[eax]
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the byte
  intel $8803.         \ mov [ebx],al

to put a wyrd into eax:
  intel $8B9D08000000. \ mov ebx,[ebp+8]  \ the wyrd
  intel $0FBF03.       \ movsx eax,word ptr [ebx]

to put a wyrd into a number:
  intel $8B8508000000. \ mov eax,[ebp+8]  \ the wyrd
  intel $0FBF00.       \ movsx eax,wyrd ptr [eax]
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the number
  intel $8903.         \ mov [ebx],eax

to put an x coord and a y coord and another x coord and another y coord into a line:
  put the x into the line's start's x.
  put the y into the line's start's y.
  put the other x into the line's end's x.
  put the other y into the line's end's y.

a query byte is a query string.

a query string is a string.

to quit;
to tell Windows we're done;
to relinquish control:
  flush the event queue.
  create an event.
  put "done" into the event's kind.
  enque the event.

to quote a string: \ inserts leading, trailing and nested double-quotes
  convert the double-quote byte into another string.
  slap a substring on the string.
  loop.
    if the substring is blank, break.
    append the substring's first's target to the other string.
    if the substring's first's target is the double-quote byte,
      append the double-quote byte to the other string.
    add 1 to the substring's first.
  repeat.
  append the double-quote byte to the other string.
  put the other string into the string.

a quotient is a number.

a radius is some twips.

to raise a number to another number:
  if the other number is 0, put 1 into the number; exit.
  if the other number is less than 0, put 0 into the number; exit.
    \ should be 1/the raised result, but always comes out 0 with numbers
  put 1 into a result number.
  loop.
    if a counter is past the other number, break.
    multiply the result by the number.
  repeat.
  put the result into the number.

a random number is a number.

a ratio has
  a numerator number,
  a denominator number,
  a top number at the numerator, and
  a bottom number at the denominator.

a ratio pair has a ratio and another ratio.

to read a byte:
  read a string.
  if the string is blank, put the null byte into the byte; exit.
  put the string's first's target into the byte.

to read a file into a buffer:
  clear the i/o error.
  call "kernel32.dll" "GetFileSize" with the file and nil returning a size.
  reassign the buffer's first given the size.
  put the buffer's first plus the size minus 1 into the buffer's last.
  call "kernel32.dll" "ReadFile" with the file and the buffer's first and the size
    and a number's whereabouts and 0 returning a result number.
  if the result number is 0, put "Error reading file." into the i/o error; exit.

to read a flag:
  read a string.
  convert the string to the flag.

to read a number:
  read a string.
  convert the string to the number.

to read a path into a buffer given a size called max bytes:
  clear the i/o error.
  privatize the path.
  privatize the max bytes.
  null terminate the path.
  if the path is not in the file system,  
    put "File '" then the path then "' doesn't exist."  
    into the i/o error; exit.
\  set the path to read-write mode.
  call "kernel32.dll" "CreateFileA" with the path's first 
    and -2147483648 [generic_read]  
    and 3 [file_share_read+file_share_write] and 0  
    and 3 [open_existing] and 0 and 0 returning a handle.
  if the handle is -1 [invalid_handle_value],  
    put "Error opening file '" then the path then "'."  
    into the i/o error; exit.
  call "kernel32.dll" "GetFileSize" with the handle and nil returning a size.
  if the size is less than the max bytes, 
    put the size in the max bytes.
  reassign the buffer's first given the max bytes.
  put the buffer's first plus the max bytes minus 1 into the buffer's last.
  call "kernel32.dll" "ReadFile"  
    with the handle and the buffer's first and the max bytes 
    and a number's whereabouts and 0 returning the number.
  call "kernel32.dll" "CloseHandle" with the handle.
  if the number is not 0, exit.
  put "Error reading file '" then the path then "'." into the i/o error.

to read a ratio:
  read a string.
  convert the string to the ratio.

to read a response string from a winhttp request:
  if the winhttp request is nil, exit.
  clear the response.
  put 8 kilobytes into a buffer size.
  loop.
    put 0 into a size. 
    call "winhttp.dll" "WinHttpQueryDataAvailable"
      with the winhttp request's request and the size's whereabouts returning a result number.
    if the result is 0, put "Unable to query data available." into the i/o error; clear the response; break.
    put the response's length into a saved length.
    reassign the response's first given the saved length plus the buffer size.
    put the response's first plus the saved length into a pointer.
    call "winhttp.dll" "WinHttpReadData" with the winhttp request's request and the pointer
      and the buffer size and a count's whereabouts returning the result number.
    if the result number is 0, put "Error reading data." into the i/o error; clear the response; break.
    put the pointer plus the count minus 1 into the response's last.
    if the count is 0, break.
  repeat.

to read stdin into a buffer:
  clear the i/o error.
  clear the buffer.
  find a string given the environment variables and "CONTENT_LENGTH".
  if the string is blank, put "Error getting content_length" into the i/o error; exit.
  convert the string into a length.
  if the length is 0, exit.
  reassign the buffer's first given the length.
  call "kernel32.dll" "ReadFile" with the stdin handle
    and the buffer's first and the length and a number's whereabouts and nil.
  if the number is not the length, put "Error reading stdin data" into the i/o error; clear the buffer; exit.
  put the buffer's first plus the length minus 1 into the buffer's last.

to read a url into a buffer:
  \ prepare
  clear the buffer.
  clear the i/o error.
  \ internet open
  call "wininet.dll" "InternetOpenA" with the module's name's first and 0 [internet_open_type_preconfig] and nil and nil returning a internet handle.
  if the internet handle is 0, put "Could not connect to the internet." into the i/o error; exit.
  \ internet open url
  privatize the url.
  null terminate the url.
  call "wininet.dll" "InternetOpenUrlA" with the internet handle and the url's first and nil and 0 and 0 and 0 returning a url handle.
  if the url handle is 0,
    put "Could not connect to url '" then the url then "'." into the i/o error;
    call "wininet.dll" "InternetCloseHandle" with the internet handle; exit.
  \ read the file
  put 64 kilobytes into a buffer size.
  loop.
    put the buffer's length into a saved length.
    reassign the buffer's first given the saved length plus the buffer size.
    put the buffer's first plus the saved length into a  pointer.
    call "wininet.dll" "InternetReadFile" with the url handle and the pointer and the buffer size
      and a count's whereabouts returning a result number.
    if the result number is 0, put "Error reading url '" then the url then "'." into the i/o error; break.
    put the pointer plus the count minus 1 into the buffer's last.
    if the count is 0, break.
  repeat.
  \ clean up
  call "wininet.dll" "InternetCloseHandle" with the url handle.
  call "wininet.dll" "InternetCloseHandle" with the internet handle.

to reassign a pointer given a byte count:
  if the pointer is nil, assign the pointer given the byte count; exit.
  if the byte count is 0, unassign the pointer; exit.
  privatize the byte count.
  round the byte count up to the nearest power of two.
  call "kernel32.dll" "HeapReAlloc" with the heap pointer and 8 [heap_zero_memory] and the pointer and the byte count returning the pointer.

to receive a buffer from a socket:
  clear the i/o error.
  clear the buffer.
  put 8 kilobytes into a buffer size.
  loop.
    put 0 into a size. 
    put the buffer's length into a saved length.
    reassign the buffer's first given the saved length plus the buffer size.
    put the buffer's first plus the saved length into a  pointer.
    call "ws2_32.dll" "recv" with the socket and the pointer and the buffer size and 0 returning a count.
    if the count is not -1 [socket_error],
      put the pointer plus the count minus 1 into the buffer's last; exit.
    if the system's last winsock error is not 10040 [wsamsgsize],
      put "Error receiving data." into the i/o error; clear the buffer; exit.
    put the pointer plus the count minus 1 into the buffer's last.
  repeat.

to receive the response from a winhttp request:
  if the winhttp request is nil, exit.
  call "winhttp.dll" "WinHttpReceiveResponse"
    with the winhttp request's request
    and 0
    returning a result number.
  if the result is 0, put "Could not send request." into the i/o error; exit.

a recipient is a string.

to reduce a ratio:
  if the ratio's denominator is 0, exit.
  if the ratio's numerator is 0,
    put 1 in the ratio's denominator; exit.
  get a gcd given the ratio's numerator and the ratio's denominator.
  divide the ratio's numerator by the gcd.
  divide the ratio's denominator by the gcd.

a refer is a thing with a string and a pointer (reference).

to refresh the cursor:
  create an event.
  put "set cursor" into the event's kind.
  if the alt key is down, set the event's alt flag.
  if the ctrl key is down, set the event's ctrl flag.
  if the shift key is down, set the event's shift flag.
  put the mouse's spot into the event's spot.
  enque the event.

to refresh the screen given a box:
  if list or compile or test was requested, 
    exit.
  call "gdi32.dll" "BitBlt" with the screen canvas
   and the box's left and the box's top and the box's width and the box's height 
   and the current canvas and the box's left and the box's top and 13369376 [srccopy].

a remainder is a number.

the remembered pdf path is a path.

to remove any trailing backslash from a string:
  if the string is blank, exit.
  if the string's last's target is not the backslash byte, exit.
  remove the last byte from the string.

to remove any trailing linefeed byte from a string:
  if the string is blank, exit.
  if the string's last's target is not the linefeed byte, exit.
  remove the last byte from the string.

to remove any trailing return byte from a string:
  if the string is blank, exit.
  if the string's last's target is not the return byte, exit.
  remove the last byte from the string.

to remove bytes from a string given a substring:
  if the string is blank, exit.
  if the substring is blank, exit.
  put the string's last minus the substring's last into a length.
  put the substring's last plus 1 into a pointer.
  copy bytes from the pointer to the substring's first for the length.
  put the string's length minus the substring's length into a new length.
  reassign the string's first given the new length.
  put the string's first plus the new length minus 1 into the string's last.

to remove the first byte from a string:
  slap a substring on the first byte of the string.
  remove bytes from the string given the substring.

to remove the first two bytes from a string:
  remove leading bytes from the string given 2.

to remove the last byte from a string:
  slap a substring on the last byte of the string.
  remove bytes from the string given the substring.

to remove the last three bytes from a string:
  remove trailing bytes from the string given 3.

to remove the last two bytes from a string:
  remove trailing bytes from the string given 2.

to remove leading bytes from a string given a count:
  privatize the count.
  if the count is greater than the string's length, clear the string; exit.
  slap a substring on the first byte of the string.
  put the substring's first plus the count minus 1 into the substring's last.
  remove bytes from the string given the substring.

to remove leading noise from a string;
to remove any leading noise from a string:
  if the string is blank, exit.
  if the string's first's target is not noise, exit.
  remove the first byte from the string.
  repeat.

to remove a thing from some things:
  if the thing is nil, exit.
  if the thing is the things' first, put the thing's next into the things' first.
  if the thing is the things' last, put the thing's previous into the things' last.
  if the thing's next is not nil, put the thing's previous into the thing's next's previous.
  if the thing's previous is not nil, put the thing's next into the thing's previous' next.
  void the thing's next.
  void the thing's previous.

to remove trailing bytes from a string given a count:
  privatize the count.
  if the count is greater than the string's length, clear the string; exit.
  slap a substring on the last byte of the string.
  put the substring's last minus the count plus 1 into the substring's first.
  remove bytes from the string given the substring.

to remove trailing noise from a string;
to remove any trailing noise from a string:
  if the string is blank, exit.
  if the string's last's target is not noise, exit.
  remove the last byte from the string.
  repeat.

to rename a path to another path in the file system:
  privatize the path.
  remove any trailing backslash from the path.
  null terminate the path.
  privatize the other path.
  remove any trailing backslash from the other path.
  null terminate the other path.
  call "kernel32.dll" "MoveFileA" with the path's first and the other path's first returning a number.
  clear the i/o error.
  if the number is not 0, exit.
  put "Error renaming file '" then the path then "'." into the i/o error.

to replace a byte with another byte in a string:
  slap a substring on the string.
  loop.
    if the substring is blank, exit.
    if the substring's first's target is not the byte,
      add 1 to the substring's first; repeat.
    put the other byte into the substring's first's target.
    add 1 to the substring's first.
  repeat.

to replace a string called old string with a string called new string in a string (one instance):
  if the old string is not in the string, exit.
  find a substring in the string given the old string.
  put the substring's first minus the string's first plus 1 in a byte#.
  remove bytes from the string given the substring.
  insert the new string into the string before the byte#.

to replace a string called old string with a string called new string in a string (throughout):
  if the old string is "", exit.
  if the new string is "", exit.
  if the old string is in the new string, exit. \prevents infinite loops.
  loop.
    if the old string is not in the string, exit.
    replace the old string with the new string in the string (one instance).
  repeat.

a reply is a string.

to reque an event:
  copy the event into another event.
  enque the other event.

the requested control font is a control font.

the requested editor font is an editor font.

the requested font is a font.

to reset a count:
  put 0 into the count.

to reset the drawing origin:
  set the drawing origin to the zero spot.

to reset a flag;
to clear a flag:
  put no into the flag.

to reset a pointer;
to reset a pointer for the next time around;
to void a pointer:
  intel $8B8508000000. \ mov eax,[ebp+8] \ the pointer
  intel $C70000000000. \ mov [eax],0

to reset a timer:
  put 0 into the timer's count.
  put 0 into the timer's start ticks.
  put 0 into the timer's total ticks.

a residue is a string.

to resize a box given a ratio pair:
  put the box's x-extent into a width.
  put the box's y-extent into a height.
  scale the width given the ratio pair's ratio.
  scale the height given the ratio pair's other ratio.
  put the box's left plus the width into the box's right.
  put the box's top plus the height into the box's bottom.

to resize a box given a twip pair:
  add the twip pair's x to the box's right.
  add the twip pair's y to the box's bottom.

to resize an ellipse given a ratio pair:
  resize the ellipse's box given the ratio pair.

to resize an ellipse given a twip pair:
  resize the ellipse's box given the twip pair.

to resize a line given a ratio pair:
  put the line's box into a box.
  subtract the box's left-top from the line's start.
  scale the line's start given the ratio pair.
  add the box's left-top to the line's start.
  subtract the box's left-top from the line's end.
  scale the line's end given the ratio pair.
  add the box's left-top to the line's end.

to resize a line given a twip pair:
  put the line's box into a box.
  put the box into another box.
  resize the other box given the twip pair.
  make a ratio pair given the other box and the box.
  resize the line given the ratio pair.

to resize the memory canvas:
  call "gdi32.dll" "SelectObject" with the memory canvas
    and the saved memory hbitmap returning an hbitmap.
  call "gdi32.dll" "DeleteObject" with the hbitmap.
  call "gdi32.dll" "GetCurrentObject" with the memory canvas
    and 7 [obj_bitmap] returning the saved memory hbitmap.
  call "gdi32.dll" "CreateCompatibleBitmap" with the screen canvas
    and the screen's pixel width and the screen's pixel height returning the hbitmap.
  call "gdi32.dll" "SelectObject" with the memory canvas and the hbitmap.
  normalize the memory canvas.

to resize a picture to a width by a height:
  if the picture is nil, exit.
  put the width divided by the tpp into a pixel width.
  put the height divided by the tpp into a pixel height.
  call "gdiplus.dll" "GdipCreateBitmapFromScan0" with the pixel width and the pixel height
    and 0 and 137224 [pixelformat24bpprgb] and 0 and a gpbitmap's whereabouts.
  call "gdiplus.dll" "GdipGetImageGraphicsContext" with the gpbitmap and a gpgraphic's whereabouts.
  call "gdiplus.dll" "GdipDrawImageRectRectI" with the gpgraphic and the picture's gpbitmap
    and 0 and 0 and the pixel width and the pixel height
    and 0 and 0 and the picture's gpbitmap's width minus 1 and the picture's gpbitmap's height minus 1
    and 2 [unitpixel] and nil and nil and 0.
  call "gdiplus.dll" "GdipDeleteGraphics" with the gpgraphic.
  destroy the picture's gpbitmap.
  put the gpbitmap into the picture's gpbitmap.
  adjust the picture (extract boxes from gpbitmap).
  clear the picture's data.

to resize a polygon given a ratio pair:
  if the polygon is nil, exit.
  put the polygon's box into a box.
  loop.
    get a vertex from the polygon's vertices.
    if the vertex is nil, exit.
    subtract the box's left-top from the vertex's spot.
    scale the vertex's spot given the ratio pair.
    add the box's left-top to the vertex's spot.
  repeat.

to resize a polygon given a twip pair:
  if the polygon is nil, exit.
  put the polygon's box into a box.
  put the box into another box.
  resize the other box given the twip pair.
  make a ratio pair given the other box and the box.
  resize the polygon given the ratio pair.

to resize a screen given a pixel width and a pixel height:
  put 0 in a number called leftie.
  put the leftie times the tpp in a number called left.
  put the pixel width in the screen's pixel width.
  put the pixel height in the screen's pixel height.
  put the screen's pixel width times the tpp into a width.
  put the screen's pixel height times the tpp into a height.
  put the left and 0 and the left plus the width and the height
    into the screen's box.
  subtract the tpp from the screen's right-bottom.

to resize a window given a box (using MoveWindow):
   put the box's left divided by the tpp into a number called left.
   put the box's top divided by the tpp into a number called top.
   put the box's right divided by the tpp into a number called right.
   put the box's bottom divided by the tpp into a number called bottom.
   put 1 plus the right minus the left into a number called width.
   put 1 plus the bottom minus the top into a number called height.
   call "user32.dll" "MoveWindow" with the window
     and the left and the top and the width and the height and no.

to resize a window given a box (using SetWindowPlacement):
  put the box in a box called pixel box.
  scale the pixel box given 1 / the tpp.
  adjust the pixel box given 0 and 0 and 1 and 1.
  initialize a window placement.
  call "User32.dll" "GetWindowPlacement"
    with the window and the window placement's whereabouts returning a flag.
  if the flag is no, exit.
  put the pixel box in the window placement's boxWhenRestored.
  call "user32.dll" "SetWindowPlacement"
    with the window and the window placement's whereabouts.

to resize a window given a screen:
  if the screen is maximized,
    resize the window given the screen's box (using MoveWindow); exit.
  put the screen's box in a box.
  if right was requested,
    put the screen's maximum pixel width
      minus the screen's pixel width in a number called pixie;
    put the pixie times the tpp in a number called leftie;
    put the leftie plus the box's left in the box's left;
    put the leftie plus the box's right in the box's right.
  resize the window given the box (using SetWindowPlacement).

to restart a timer:
  add 1 to the timer's count.
  if the timer's count is not 1, exit.
  put the system's tick count into the timer's start ticks.

to restore a canvas:
  call "gdi32.dll" "RestoreDC" with the canvas and -1.
    \ need to use -1, windows documentation is wrong

to restore a screen:
  resize the screen given the screen's restored pixel width
    and the screen's restored pixel height.

to restore a window:
  call "user32.dll" "ShowWindow" with the window and 9 [sw_restore].

the return code is a number.
\
\ The return code is returned by the program
\ to the operating system when the program ends.
\ It is 0 if the program succeeds.
\ It is 1 if a command-line requested compilation failed.
\ (The /compile and /list flags request compilation.)
\ It is a positive number if one or more tests
\ in a command-line requested regression test run failed.
\
\ 259 is not a valid return code, because Windows
\ uses 259 to mean that a process is STILL_ACTIVE.
\ https://msdn.microsoft.com/en-us/library/windows/desktop/ms683189(v=vs.85).aspx
\
\ Forward- and backward-compatibility notes:
\  * A copy of this global declaration
\    is inserted by the compiler.
\    Thus, source code that compiled on cal compilers that
\    have hard-coded return codes will compile without change.
\  * Including this global declaration allows this source code
\    to compile on cal compilers that
\    do not insert a copy of this global declaration.
\  * This global declaration exactly matches
\    what is inserted by the compiler.
\    This otherwise-duplicate global declaration is ignored
\    because of the exact match to the inserted code.
\    Ignoring this otherwise-duplicate global declaration
\    allows compilers that insert the global declaration
\    to compile this source code.

to reverse a flag:
  if the flag is yes, put no into the flag; exit.
  put yes into the flag.

to reverse a number;
to invert a number:
  multiply the number by -1.

to reverse a string: \ could be more efficient
  privatize the string.
  clear the original string.
  loop.
    if the string is blank, break.
    get a character from the string (backwards).
    append the character to the original string.
  repeat.

to reverse some things:
  swap the things with some other things.
  loop.
    put the other things' last into a thing.
    if the thing is nil, exit.
    move the thing from the other things to the things.
  repeat.

a rider has \ fix "bump a rider" if you change me
  an original substring,
  a source substring and 
  a token substring.

to rotate a box:
  put the box's center into a center spot.
  put the box into another box.
  put the center's y minus the other box's top plus the center's x into the box's right.
  put the other box's left minus the center's x plus the center's y into the box's top.
  put the center's y minus the other box's bottom plus the center's x into the box's left.
  put the other box's right minus the center's x plus the center's y into the box's bottom.

to rotate an ellipse:
  rotate the ellipse's box.

to rotate a gpimage:
  if the gpimage is nil, exit.
  call "gdiplus.dll" "GdipImageRotateFlip" with the gpimage and 1 [rotate90flipnone].

to rotate a gpimage given an angle: \ angle can be 0, 900, 1800, 2700
  if the gpimage is nil, exit.
  put 0 [rotatenoneflipnone] into a number.
  if the angle is 900, put 1 [rotate90flipnone] into the number.
  if the angle is 1800, put 2 [rotate180flipnone ] into the number.
  if the angle is 2700, put 3 [rotate270flipnone ] into the number.
  call "gdiplus.dll" "GdipImageRotateFlip" with the gpimage and the number.

to rotate a line:
  put the line's center into a center spot.
  rotate the line's start around the center.
  rotate the line's end around the center.

to rotate a picture:
  if the picture is nil, exit.
  add 900 to the picture's rotate angle.
  if the picture's mirror flag is set, add 1800 to the picture's rotate angle.
  normalize the picture's rotate angle.
  rotate the picture's box.
  rotate the picture's uncropped box.
  put the picture's box's center into a center spot.
  put the picture's uncropped box's center into another center spot.
  put the center's y minus the other center's y plus the center's x into a twip pair's x.
  subtract the other center's x from the twip pair's x.
  put the center's y plus the other center's x minus the center's x into the twip pair's y.
  subtract the other center's y from the twip pair's y.
  move the picture's uncropped box given the twip pair.
  rotate the picture's gpbitmap.

to rotate a polygon:
  if the polygon is nil, exit.
  put the polygon's center into a center spot.
  loop.
    get a vertex from the polygon's vertices.
    if the vertex is nil, exit.
    rotate the vertex's spot around the center.
  repeat.

to rotate a spot around a center spot:
  put the spot into another spot.
  put the center's y minus the other spot's y plus the center's x into the spot's x.
  put the other spot's x minus the center's x plus the center's y into the spot's y.

to round a number to another number:
  round the number to the nearest multiple of the other number.

to round a number down to the nearest multiple of another number:
  divide the number by the other number.
  multiply the number by the other number.

to round a number to the nearest multiple of another number:
  if the other number is 0, exit.
  privatize the other number.
  divide the number by the other number giving a quotient and a remainder.
  divide the other number by 2.
  if the remainder is greater than or equal to the other number,
    round the number up to the nearest multiple of the original other number; exit.
  round the number down to the nearest multiple of the original other number.

to round a number up to the nearest multiple of another number:
  divide the number by the other number giving a quotient and a remainder.
  if the remainder is 0, exit.
  add the other number minus the remainder to the number.

to round a number up to the nearest power of two:
  intel $8B8D08000000. \ mov ecx,[ebp+8] \ the number
  intel $8B09.         \ mov ecx,[ecx]
  intel $49.           \ dec ecx
  intel $0FBDC9.       \ bsr ecx,ecx
  intel $41.           \ inc ecx
  intel $81F904000000. \ cmp ecx,4
  intel $0F8F05000000. \ jg over the next 1 statement
  intel $B904000000.   \ mov ecx,4
  intel $8B8508000000. \ mov eax,[ebp+8] \ the number
  intel $C70001000000. \ mov [eax],1
  intel $D320.         \ shl [eax],ecx  

to round a pair to another pair:
  round the pair to the nearest multiple of the other pair.

to round a pair to the nearest multiple of another pair:
  round the pair's x to the nearest multiple of the other pair's x.
  round the pair's y to the nearest multiple of the other pair's y.

to round a pair to the nearest multiple of a number:
  round the pair's x to the nearest multiple of the number.
  round the pair's y to the nearest multiple of the number.

to round a pair to a number:
  round the pair to the nearest multiple of the number.

a roundy box is a box with
  a left coord, a top coord, a right coord, a bottom coord,
  a left-top spot at the left, a right-bottom spot at the right, and 
  a radius.

to save a canvas:
  call "gdi32.dll" "SaveDC" with the canvas.

the saved memory hbitmap is a hbitmap.

the saved tpp is a number.

to say a number:
  put the number into a string.
  say the string.

to say a string;
to speak a string:
  if the silent flag is set, exit.
  if the talker is nil, exit.
  if the string is blank, exit.
  convert the string to a wide string.
  null terminate the wide string.
  call the talker's vtable's speak with the talker
    and the wide string's first
    and 17 [svsfdefault+svsflagsasyn+svsfisnotxml] and 0.

to say a string and wait;
to speak a string and wait:
  if the silent flag is set, exit.
  if the talker is nil, exit.
  if the string is blank, exit.
  convert the string to a wide string.
  null terminate the wide string.
  call the talker's vtable's speak with the talker
    and the wide string's first
    and 16 [svsfdefault+svsfisnotxml] and 0.

to scale a box given a ratio:
  if the ratio is 1/1, exit.
  scale the box's left given the ratio.
  scale the box's top given the ratio.
  scale the box's right given the ratio.
  scale the box's bottom given the ratio.

to scale a box to a percent:
  put the percent / 100 into a ratio.
  scale the box given the ratio.

to scale an ellipse given a ratio:
  if the ratio is 1/1, exit.
  scale the ellipse's box given the ratio.

to scale an ellipse to a percent:
  put the percent / 100 into a ratio.
  scale the ellipse given the ratio.

to scale a font given a ratio:
  if the ratio is 1/1, exit.
  scale the font's height given the ratio.

to scale a line given a ratio:
  if the ratio is 1/1, exit.
  scale the line's start given the ratio.
  scale the line's end given the ratio. 

to scale a line to a percent:
  put the percent / 100 into a ratio.
  scale the line given the ratio.

to scale a pair given a ratio:
  if the ratio is 1/1, exit.
  scale the pair's x given the ratio.
  scale the pair's y given the ratio.

to scale a pair given a ratio pair:
  scale the pair's x given the ratio pair's ratio.
  scale the pair's y given the ratio pair's other ratio.

to scale a pair to a percent:
  put the percent / 100 into a ratio.
  scale the pair given the ratio.

to scale a picture given a ratio:
  if the picture is nil, exit.
  if the ratio is 1/1, exit.
  scale the picture's box given the ratio.
  scale the picture's uncropped box given the ratio.

to scale a picture to a percent:
  if the picture is nil, exit.
  put the percent / 100 into a ratio.
  scale the picture given the ratio.

to scale a polygon given a ratio:
  if the polygon is nil, exit.
  if the ratio is 1/1, exit.
  loop.
    get a vertex from the polygon's vertices.
    if the vertex is nil, exit.
    scale the vertex given the ratio.
  repeat.

to scale a polygon to a percent:
  if the polygon is nil, exit.
  put the percent / 100 into a ratio.
  scale the polygon given the ratio.

to scale a ratio given another ratio;
to multiply a ratio by another ratio:
  multiply the ratio's numerator by the other ratio's numerator.
  multiply the ratio's denominator by the other ratio's denominator.
  reduce the ratio.

to scale a roundy box given a ratio:
  if the ratio is 1/1, exit.
  scale the roundy box as a box given the ratio.
  scale the roundy box's radius given the ratio.

to scale a roundy box to a percent:
  put the percent / 100 into a ratio.
  scale the roundy box given the ratio.

to scale a vertex given a ratio:
  if the vertex is nil, exit.
  if the ratio is 1/1, exit.
  scale the vertex's x given the ratio.
  scale the vertex's y given the ratio.

the screen canvas is a canvas.

a screen has a box, a pixel height, a pixel width,
   a restored pixel height, a restored pixel width,
   a maximum pixel height, and a maximum pixel width.

the screen is a screen.

a second is 1000 milliseconds.

a sector is a pair with an x coord and an y coord [indicating the left-top of the sector].

the seed is a number.

to send a buffer to a socket:
  clear the i/o error.
  put the buffer's first into a pointer.
  put the buffer's length into a length.
  loop.
    if the length is 0, break.
    call "ws2_32.dll" "send" with the socket and the pointer and the length and 0 returning a number.
    if the number is -1 [socket_error], put "Error sending data." into the i/o error; exit.
    subtract the number from the length.
    add the number to the pointer.
  repeat.

to send a data string to a winhttp request:
  if the winhttp request is nil, exit.
  call "winhttp.dll" "WinHttpSendRequest"
    with the winhttp request's request
    and 0 [winhttp_no_additional_headers]
    and 0 
    and the data's first
    and the data's length
    and the data's length
    and 0
    returning a result number.
  if the result is 0, put "Could not send request." into the i/o error; exit.

to send an email:
  clear the i/o error.
  \ create socket
  create a socket given the email's smtp server and 25.
  if the i/o error is not blank, exit.
  \ initial receive here for date/time stuff from server
  receive a response string from the socket.
  if the i/o error is not blank, destroy the socket; exit.
  if the response starts with "5", put the response into the i/o error; trim the i/o error; destroy the socket; exit.
  \ send HELO
  send "HELO " then the module's name then the crlf string to the socket and receive the response string.
  if the i/o error is not blank, destroy the socket; exit.
  if the response starts with "5",
    put the response into the i/o error; trim the i/o error; destroy the socket; exit.
  \ send MAIL FROM: <xxx>
  send "MAIL FROM: <" then the email's sender then ">" then the crlf string to the socket and receive the response string.
  if the i/o error is not blank, destroy the socket; exit.
  if the response starts with "5",
    put the response into the i/o error; trim the i/o error; destroy the socket; exit.
  \ send RCPT TO: <xxx>
  send "RCPT TO: <" then the email's recipient then ">" then the crlf string to the socket and receive the response string.
  if the i/o error is not blank, destroy the socket; exit.
  if the response starts with "5",
    put the response into the i/o error; trim the i/o error; destroy the socket; exit.
  \ send DATA
  send "DATA" then the crlf string to the socket and receive the response string.
  if the i/o error is not blank, destroy the socket; exit.
  if the response starts with "5",
    put the response into the i/o error; trim the i/o error; destroy the socket; exit.
  \ send From: xxx crlf To: xxx crlf Subject: xxx crlf Reply-To: xxx crlf message crlf . crlf
  clear a temp string.
  append "From: " then the email's sender then the crlf string to the temp string.
  append "To: " then the email's recipient then the crlf string to the temp string.
  append "Subject: " then the email's subject then the crlf string into the temp string.
  append "Reply-To: " then the email's sender then the crlf string into the temp string.
  append the crlf string to the temp string.
  append the email's message to the temp string (handling email transparency).
  append the crlf string then "." then the crlf string to the temp string.
  send the temp string to the socket and receive the response string.
  if the i/o error is not blank, destroy the socket; exit.
  if the response starts with "5", put the response into the i/o error; trim the i/o error; destroy the socket; exit.
  \ send QUIT
  send "QUIT" then the crlf string to the socket.
  \ destroy socket
  destroy the socket.

to send a message from a sender to a recipient:
  send the message to the recipient from the sender.

to send a message from a sender to a recipient via a smtp server:
  send the message to the recipient from the sender via the smtp server.

to send a message from a sender to a recipient with a subject:
  send the message to the recipient from the sender with the subject.

to send a message from a sender to a recipient with a subject via a smtp server:
  send the message to the recipient from the sender with the subject via the smtp server.

to send a message to a recipient from a sender:
  put the default smtp server into an email's smtp server.
  put the recipient into the email's recipient.
  put the sender into the email's sender.
  put the message into the email's message.
  send the email.

to send a message to a recipient from a sender via a smtp server:
  put the smtp server into an email's smtp server.
  put the recipient into the email's recipient.
  put the sender into the email's sender.
  put the message into the email's message.
  send the email.

to send a message to a recipient from a sender with a subject:
  put the default smtp server into an email's smtp server.
  put the recipient into the email's recipient.
  put the sender into the email's sender.
  put the subject into the email's subject.
  put the message into the email's message.
  send the email.

to send a message to a recipient from a sender with a subject via a smtp server:
  put the smtp server into an email's smtp server.
  put the recipient into the email's recipient.
  put the sender into the email's sender.
  put the subject into the email's subject.
  put the message into the email's message.
  send the email.

to send a string to a socket and receive a response string:
  clear the response string.
  send the string to the socket.
  if the i/o error is not blank, exit.
  receive the response string from the socket.

a sender is a string.

to set the colorref of a canvas given a color:
  convert the color to a colorref.
  call "gdi32.dll" "SetTextColor" with the canvas and the colorref.

to set the drawing origin to a spot:
  call "gdi32.dll" "GetDeviceCaps" with the current canvas and 112 [physicaloffsetx] returning a pair's x.
  call "gdi32.dll" "GetDeviceCaps" with the current canvas and 113 [physicaloffsety] returning the pair's y.
  negate the pair.
  if the current canvas is not the printer canvas, clear the pair.
  call "gdi32.dll" "SetViewportOrgEx" with the current canvas and the pair's x and the pair's y and nil.
  privatize the spot.
  call "gdi32.dll" "LPtoDP" with the current canvas and the spot's whereabouts and 1.
  call "gdi32.dll" "SetViewportOrgEx" with the current canvas and the spot's x and the spot's y and nil.

to set a flag:
  put yes into the flag.

to set a path to read-write mode:
  privatize the path.
  null terminate the path.
  call "kernel32.dll" "GetFileAttributesA" with the path's first returning a number.
  bitwise and the number with -2 [everything except file_attribute_readonly].
  call "kernel32.dll" "SetFileAttributesA" with the path's first and the number.

a sheet is a box.

to shift a byte left some bits:
  intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the bits
  intel $8B09.         \ mov ecx,[ecx]
  intel $8B8508000000. \ mov eax,[ebp+8] \ the byte
  intel $D220.         \ shl byte pointer [eax],ecx

to shift a byte right some bits:
  intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the bits
  intel $8B09.         \ mov ecx,[ecx]
  intel $8B8508000000. \ mov eax,[ebp+8] \ the byte
  intel $D228.         \ shr byte pointer [eax],ecx

to shift a number left some bits:
  intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the bits
  intel $8B09.         \ mov ecx,[ecx]
  intel $8B8508000000. \ mov eax,[ebp+8] \ the number
  intel $D320.         \ shl [eax],ecx

to shift a number right some bits:
  intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the bits
  intel $8B09.         \ mov ecx,[ecx]
  intel $8B8508000000. \ mov eax,[ebp+8] \ the number
  intel $D328.         \ shr [eax],ecx

to shift a wyrd left some bits:
  intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the bits
  intel $8B09.         \ mov ecx,[ecx]
  intel $8B8508000000. \ mov eax,[ebp+8] \ the wyrd
  intel $66D320.       \ shl word ptr [eax],ecx

to shift a wyrd right some bits:
  intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the bits
  intel $8B09.         \ mov ecx,[ecx]
  intel $8B8508000000. \ mov eax,[ebp+8] \ the wyrd
  intel $66D328.       \ shr word ptr [eax],ecx

to show a cursor:
  call "user32.dll" "SetCursor" with the cursor.
  call "user32.dll" "ShowCursor" with 1 returning a number.
  if the number is greater than 0, exit.
  repeat.

to shut down:
\  destroy the bible.
  destroy the lexicon.
  destroy the console.
\  destroy the terminal.
  finalize the canvases.
  finalize the mouse.
  finalize the cursors.
  finalize the fonts.
  finalize the window.
  finalize the screen.
  finalize the colors.
  finalize the module.
  finalize the talker.
  finalize gdi+.
  finalize winsock.
  finalize com.

to shut down the cgi:
  finalize the cgi.
  finalize the module.
  finalize winsock.

the silent flag is a flag.

a size is some twips.

to skip any leading linefeed byte in a substring:
  if the substring is blank, exit.
  if the substring's first's target is not the linefeed byte, exit.
  add 1 to the substring's first.

to skip any leading noise in a substring:
  if the substring is blank, exit.
  if the substring's first's target is not noise, exit.
  add 1 to the substring's first.
  repeat.

to skip any non-alphanumeric bytes in a substring:
  if the substring is blank, exit.
  if the substring's first's target is alphanumeric, exit.
  add 1 to the substring's first.
  repeat.

to skip word characters in a substring:
  if the substring is blank, exit.
  if the substring is on any contraction, add 1 to the substring's first; repeat.
  if the substring's first's target is not alphanumeric, exit.
  add 1 to the substring's first.
  repeat.

to slap a rider on another rider:
  slap the rider's source on the other rider's source.
  position the rider's token on the rider's source.

to slap a rider on a string:
  slap the rider's original on the string.
  slap the rider's source on the string.
  position the rider's token on the rider's source.

to slap a substring on the first byte of a string:
  slap the substring on the string.
  if the string is blank, exit.
  put the string's first into the substring's last.

to slap a substring on the last byte of a string:
  slap the substring on the string.
  if the string is blank, exit.
  put the string's last into the substring's first.

to slap a substring on a string:
  intel $8B8508000000. \ mov eax,[ebp+8]  \ the substring
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the string
  \ put the string's first into the substring's first
  intel $8B8B00000000. \ mov ecx,[ebx+0]  \ the string's first
  intel $898800000000. \ mov [eax+0],ecx  \ the substring's first
  \ put the string's last into the substring's last
  intel $8B8B04000000. \ mov ecx,[ebx+4]  \ the string's last
  intel $898804000000. \ mov [eax+4],ecx  \ the substring's last

the small letter height is a letter height.

the smallest number is -2147483648.

to smooth a polygon:
  if the polygon is nil, exit.
  if the polygon's vertices' count is less than 3, exit.
  if the polygon is closed,
    append the polygon's first vertex's next's spot to the polygon; set a flag.
  put the polygon's first vertex into a left vertex.
  loop.
    if the left vertex's next is nil, break.
    put the left vertex's next into a right vertex.
    get a center spot given the left vertex's spot and the right vertex's spot.
    insert the center into the polygon after the left vertex.
    put the left vertex's next into a new vertex.
    if the left vertex's previous is nil, put the right vertex into the left vertex; repeat.
    get another center spot given the left vertex's previous' spot and the new vertex's spot.
    get a difference between the other center and the left vertex's spot.
    divide the difference by 2.
    add the difference to the left vertex's spot.
    put the right vertex into the left vertex.
  repeat.
  if the flag is not set, exit.
  destroy the polygon's first vertex given the polygon.
  destroy the polygon's last vertex given the polygon.

to smooth a polygon some times:
  privatize the times.
  loop.
    if the times is 0, exit.
    smooth the polygon.
    subtract 1 from the times.
  repeat.

an smtp server is a string.

a sockaddr is a record with
  a wyrd called sin_family,
  a big-endian unsigned wyrd called sin_port,
  a in_addr called sin_addr,
  8 bytes called sin_zero.

a sockaddrptr is a pointer to a sockaddr.

a socket is a pointer.

to sort some string things:
  if the string things' first is the string things' last, exit.
  split the string things
    into some left string things and some right string things.
  sort the left string things.
  sort the right string things.
  loop.
    put the left string things' first into a left string thing.
    put the right string things' first into a right string thing.
    if the left string thing is nil,
      append the right string things to the string things; exit.
    if the right string thing is nil,
      append the left string things to the string things; exit.
    if the left string thing's string is greater than the right string thing's string,
      move the right string thing from the right string things to the string things; repeat.
    move the left string thing from the left string things to the string things.
  repeat.

to split a buffer into some dyads:
  destroy the dyads.
  if the buffer is blank, exit.
  slap a rider on the buffer.
  loop.
    move the rider given the ampersand byte.
    if the rider's token is blank, exit.
    create a dyad.
    append the dyad to the dyads.
    split the rider's token into a name substring and a query substring given the equal-sign byte.
    put the name substring into the dyad's name.
    convert the query substring as a query string into the dyad's value.
  repeat.

to split a byte into a nibble and another nibble:
  put the byte into the nibble.
  shift the nibble right 4 bits.
  put the byte into the other nibble.
  bitwise and the other nibble with 15.

to split a line into another line and a third line:
  privatize the line.
  put the line's center into a center spot.
  put the line's start and the center into the other line.
  put the center and the line's end into the third line.

to split a number into a wyrd and another wyrd:
  privatize the number.
  shift the number right 16 bits.
  put the number into the wyrd.
  put the original number into the other wyrd.

to split a string into a left substring and a right substring given a separator byte:
  clear the left.
  clear the right.
  if the string is blank, exit.
  put the string's first into a substring's first.
  put the substring's first minus 1 into the substring's last.
  loop.
    if the substring's last is greater than the string's last, exit.
    add 1 to the substring's last.
    if the substring's last's target is the separator byte, break.
  repeat.
  put the substring's first into the left's first.
  put the substring's last minus 1 into the left's last.
  put the substring's last plus 1 into the right's first.
  put the string's last into the right's last.

to split a string into some string things given a separator byte:
  destroy the string things.
  if the string is blank, exit.
  privatize the string.
  slap a rider on the string.
  loop.
    move the rider given the separator byte.
    add the rider's token to the string things.
    if the rider's source is blank, break.
  repeat.
  if the string's last's target is not the separator byte, exit.
  add "" to the string things.

to split some things into some left things and some right things:
  if the things are empty, clear the left things; clear the right things; exit.
  put the things' count divided by 2 into a count.
  loop.
    get a thing from the things.
    if the count is 0, break.
    subtract 1 from the count.
  repeat.
  split the things into the left things and the right things at the thing.

to split some things into some left things and some right things at a thing:
  clear the left things.
  clear the right things.
  if the thing is nil, swap the things with the left things; exit.
  if the thing's previous is nil, swap the things with the left things; exit.
  \ set up the left chain
  put the things' first into the left things' first.
  put the thing's previous into the left things' last.
  void the thing's previous' next.
  \ set up the right chain
  put the thing into the right things' first.
  void the thing's previous.
  put the things' last into the right things' last.
  \ fix the original chain
  clear the things.

to split a wyrd into a byte and another byte:
  privatize the wyrd.
  shift the wyrd right 8 bits.
  put the wyrd into the byte.
  put the original wyrd into the other byte.

a spot is a pair with an x coord and a y coord.

a spot pointer is a pointer to a spot.

a square root is a number.

a standard handle is a handle.  \ to standard in, standard out, or standard error.

to start a process given a path and a string returning a thread handle and another thread handle:
  privatize the string.
  if the string's first is not 0,
    null terminate the string.
  clear the i/o error.
  if the process is not 0,
    put "I'm sorry, but that process is already running." into the i/o error; exit.
  put a startupinfo's magnitude into the startupinfo's cb.
  extract a directory from the path. null terminate the directory.
  privatize the path. null terminate the path.
  call "kernel32.dll" "CreateProcessA" with the path's first
    and the string's first
    and 0 and 0 and 0
    and 67108904 [create_default_error_mode + normal_priority_class + detached_process]
    and 0 and the directory's first
    and the startupinfo's whereabouts
    and a processinfo's whereabouts
    returning a number.
  if the number is 0, put "I'm unable to run the program." into the i/o error; exit.
  put the processinfo's hprocess into the process.
  put the processinfo's hthread into the thread handle.
\  call "kernel32.dll" "CloseHandle" with the processinfo's hthread.
  point a pointer to routine wait for a process pointer.
  call "kernel32.dll" "CreateThread" with 0 and 0 and the pointer and the process's whereabouts
    and 0 and another number's whereabouts returning the other thread handle.
\  call "kernel32.dll" "CloseHandle" with the other thread handle.
\  \does not end the thread, just dumps the handle

to start a process given a path returning a thread handle and another thread handle: \ must be called with a global variable
  void a string.
  start the process given the path and the string
    returning the thread handle and the other thread handle.

to start a timer:
  reset the timer.
  restart the timer.

to start up:
  initialize com.
  initialize winsock.
  initialize gdi+.
  initialize the talker.
  initialize the module.
  initialize the colors.
  initialize the screen.
  initialize the window.
  initialize the fonts.
  initialize the cursors.
  initialize the mouse.
  initialize the canvases.
\  initialize the terminal.
  create the console.

to start up the cgi:
  initialize winsock.
  initialize the module.
  initialize the cgi.

to start with nothing in a pointer:
  void the pointer.

a startupinfo is a record with
  a number called cb,
  a pointer called lpreserved,
  a pointer called lpdesktop,
  a pointer called lptitle,
  a number called dwx,
  a number called dwy,
  a number called dwxsize,
  a number called dwysize,
  a number called dwxcountchars,
  a number called cwycountchars,
  a number called dwfillattribute,
  a number called dwflags,
  a wyrd called wshowwindow,
  a wyrd called cbreserved2,
  a pointer called lpreserved2,
  a handle called hstdinput,
  a handle called hstdoutput,
  a handle called hstderror.

to stash a string in some string things:
  privatize the string.
  trim the string.
  add the string to the string things.

to stash a string in some string things given a byte called splitter:
  privatize the string.
  if the string's first's target is the splitter,
    remove the first byte from the string.
  trim the string.
  add the string to the string things.

the stdin handle is a handle.

the stdout handle is a handle.

to stop a process:
  if the process is 0, exit.
  call "kernel32.dll" "TerminateProcess" with the process and 0.
  put 0 into the process.

to stop a timer:
  if the timer's count is 0, exit.
  subtract 1 from the timer's count. 
  if the timer's count is not 0, exit.
  put the system's tick count into some ticks.
  subtract the timer's start ticks from the ticks.
  add the ticks to the timer's total ticks.

to store a buffer in a file;
to write a buffer to a file:
  clear the i/o error.
  call "kernel32.dll" "SetFilePointer" with the file and 0 and 0 and 0 [file_begin] returning a result number.
  if the result number is -1, put "Error positioning file pointer." into the i/o error; exit.
  call "kernel32.dll" "WriteFile" with the file and the buffer's first and the buffer's length
    and a number's whereabouts and 0 returning the result number.
  if the result number is 0, put "Error writing file." into the i/o error; exit.

to store a buffer in a path;
to write a buffer to a path:
  clear the i/o error.
  extract a directory from the path.
  if the directory is not in the file system,
    put "Directory '" then the directory then "' doesn't exist."
      into the i/o error;
    exit.
\  set the path to read-write mode.
  privatize the path.
  null terminate the path.
  call "kernel32.dll" "CreateFileA"
    with the path's first and 1073741824 [generic_write] 
    and 0 and 0 and 2 [create_always]
    and -2147483520 [file_attribute_normal   =      0x100]
                 [or file_flag_write_through = 0x80000000]
    and 0 returning a handle.
  if the handle is -1 [invalid_handle_value],
    put "Error opening file '" then the path then "'." into the i/o error; exit.
  call "kernel32.dll" "WriteFile"
    with the handle and the buffer's first and the buffer's length
    and a number's whereabouts and 0 returning the number.
  call "kernel32.dll" "CloseHandle" with the handle.
  if the number is not 0, exit.
  put "Error writing file '" then the path then "'." into the i/o error.

a string has a first byte pointer and a last byte pointer.

a string thing is a thing with a string.

a string# is a number.

a subject is a string.

a substring is a string.

to subtract a number and another number from a pair:
  subtract the number from the pair's x.
  subtract the other number from the pair's y.

to subtract a number from a byte:
  intel $8B8508000000. \ mov eax,[ebp+8]  \ the number
  intel $8B00.         \ mov eax,[eax]
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the byte
  intel $0FB60B.       \ movzx ecx,[ebx]
  intel $2BC8.         \ sub ecx,eax
  intel $880B.         \ mov [ebx],cl

to subtract a number from a pair:
  subtract the number from the pair's x.
  subtract the number from the pair's y.

to subtract a number from a pointer;
to subtract a pointer from another pointer;
to subtract a number from another number:
  intel $8B8508000000. \ mov eax,[ebp+8]  \ the number
  intel $8B00.         \ mov eax,[eax]
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the other number
  intel $2903.         \ sub [ebx],eax

to subtract a number from a ratio:
  subtract the number / 1 from the ratio.

to subtract a pair from another pair:
  subtract the pair's x from the other pair's x.
  subtract the pair's y from the other pair's y.

to subtract a ratio from another ratio:
  privatize the ratio.
  normalize the ratio and the other ratio.
  subtract the ratio's numerator from the other ratio's numerator.
  reduce the other ratio.

to summarize some number things returning a string (tersely):
  put "" in the string.
  loop.
    get a number thing from the number things.
    if the number thing is nil, exit.
    if the string is not "",
      append ", " then the number thing's number to the string.
    if the string is "",
      append the number thing's number to the string.
  repeat.

to summarize some string things returning a string:
  put "" in the string.
  loop.
    get a string thing from the string things.
    if the string thing is nil, exit.
    if the string is not "",
      append " before '" then the string thing's string then "'" to the string.
    if the string is "",
      append "'" then the string thing's string then "'" to the string.
  repeat.

to summarize some string things returning a string (tersely):
  put "" in the string.
  loop.
    get a string thing from the string things.
    if the string thing is nil, exit.
    if the string is not "",
      append ", " then the string thing's string to the string.
    if the string is "",
      append the string thing's string to the string.
  repeat.

to swap a pair with another pair:
  swap the pair's x with the other pair's x.
  swap the pair's y with the other pair's y.

to swap a pointer with another pointer;
to swap a number with another number:
  put the number into a third number.
  put the other number into the number.
  put the third number into the other number.

to swap some things with some other things:
  swap the things' first with the other things' first.
  swap the things' last with the other things' last.

a systemtime is a record with
  a wyrd called wyear,
  a wyrd called wmonth,
  a wyrd called wdayofweek,
  a wyrd called wday,
  a wyrd called whour,
  a wyrd called wminute,
  a wyrd called wsecond,
  a wyrd called wmilliseconds.

a talker is a pointer to a talker object.

the talker is a talker.

a talker object is a record with a talker vtable called vtable.

a talker vtable is a pointer to a talker vtable record.

a talker vtable record is a record with
  \ iunknown
  a pointer called queryinterface,
  a pointer called addref,
  a pointer called release, \ IN this:pspvoice OUT number
  \ italker
  a pointer called setnotifysink,
  a pointer called setnotifywindowmessage,
  a pointer called setnotifycallbackfunction,
  a pointer called setnotifycallbackinterface,
  a pointer called setnotifywin32event,
  a pointer called waitfornotifyevent,
  a pointer called getnotifyeventhandle,
  a pointer called setinterest,
  a pointer called getevents,
  a pointer called getinfo,
  a pointer called setoutput,
  a pointer called getoutputobjecttoken,
  a pointer called getoutputstream,
  a pointer called pause,
  a pointer called resume,
  a pointer called setvoice,
  a pointer called getvoice,
  a pointer called speak, \ IN this:pspvoice; pwcs:pwchar; dwflags:number; pulStreamnumber:pnumber OUT number
  a pointer called speakstream,
  a pointer called getstatus,
  a pointer called skip,
  a pointer called setpriority,
  a pointer called getpriority,
  a pointer called setalertboundary,
  a pointer called getalertboundary,
  a pointer called setrate,
  a pointer called getrate,
  a pointer called setvolume,
  a pointer called getvolume,
  a pointer called waituntildone,
  a pointer called setsyncspeaktimeout,
  a pointer called getsyncspeaktimeout,
  a pointer called speakcompleteevent,
  a pointer called isuisupported,
  a pointer called displayui.

the temp path is a path.

to test (basic math - 6 plus 0/1):
  create a test result about "the noodle" and "6 plus 0/1"
    and expecting "6".
  put 0 / 1 in a ratio.
  add 6 to the ratio.
  convert the ratio to a string.
  stash the test result given the string.

to test (basic math - 6 plus 0/1866240000):
  create a test result about "the noodle" and "6 plus 0/1866240000"
    and expecting "6".
  put 0/1866240000 in a ratio.
  add 6 to the ratio.
  convert the ratio to a string.
  stash the test result given the string.

to test (basic math - add numbers):
  create a test result about "the noodle" and "3 plus 7" and expecting "10".
  put 7 in a number.
  add 3 to the number.
  stash the test result given the number.

to test (basic math - copy number):
  create a test result about "the noodle" and "copy number"
    and expecting "5".
  put 5 in a number.
  put the number in another number.
  stash the test result given the other number.

to test (basic math - divide 0 by 3 with remainder):
  create a test result about "the noodle" and "0 over 3" and expecting "0".
  put 0 in a number.
  divide the number by 3 giving a quotient and a remainder.
  convert the quotient into an actual string.
  if the remainder is not 0,
    append " remainder " then the remainder to the actual.
  stash the test result given the actual.

to test (basic math - divide 0 by 3):
  create a test result about "the noodle" and "0 over 3" and expecting "0".
  put 0 in a number.
  divide the number by 3.
  stash the test result given the number.

to test (basic math - divide 1 by 3 with remainder):
  create a test result about "the noodle" and "1 over 3"
    and expecting "0 remainder 1".
  put 1 in a number.
  divide the number by 3 giving a quotient and a remainder.
  convert the quotient into an actual string.
  if the remainder is not 0,
    append " remainder " then the remainder to the actual.
  stash the test result given the actual.

to test (basic math - divide 1 by 3):
  create a test result about "the noodle" and "1 over 3"
    and expecting "0".
  put 1 in a number.
  divide the number by 3.
  stash the test result given the number.

to test (basic math - divide 24 by 3 with remainder):
  create a test result about "the noodle" and "24 over 3" and expecting "8".
  put 24 in a number.
  divide the number by 3 giving a quotient and a remainder.
  convert the quotient into an actual string.
  if the remainder is not 0,
    append " remainder " then the remainder to the actual.
  stash the test result given the actual.

to test (basic math - divide 24 by 3):
  create a test result about "the noodle" and "24 over 3" and expecting "8".
  put 24 in a number.
  divide the number by 3.
  stash the test result given the number.

to test (basic math - divide 25 by 3 with remainder):
  create a test result about "the noodle" and "25 over 3" and expecting "8 remainder 1".
  put 25 in a number.
  divide the number by 3 giving a quotient and a remainder.
  convert the quotient into an actual string.
  if the remainder is not 0,
    append " remainder " then the remainder to the actual.
  stash the test result given the actual.

to test (basic math - divide 25 by 3):
  create a test result about "the noodle" and "25 over 3" and expecting "8".
  put 25 in a number.
  divide the number by 3.
  stash the test result given the number.

to test (basic math - fractions and ratios):
  create a test result about "the noodle" and "fractions and ratios"
    and expecting "1-1/2; 5/6; 2; 2".
                                    \ r1  r2   f1   f2
  put 1/2 into a ratio.             \ 1/2 0/0  0/0  0/0
  put 1/3 into another ratio.       \     1/3
  add the ratio to the other ratio. \     5/6
  put 1/4 into a fraction.          \          1/4
  put the ratio into the fraction.  \          1/2
  put the fraction into the ratio.  \ 1/2
  add the fraction to the ratio.    \ 1/1
  add the ratio to the fraction.    \          3/2
  add 1/2 to the fraction.          \          2/1
  add 1/2 to the ratio.             \ 3/2
  clear another fraction.           \               0/1
  add the fraction to the other fraction. \         2/1
  convert the ratio to a string.
  append "; " then the other ratio then "; "
    then the fraction then "; " then the other fraction
    to the string.
  stash the test result given the string.

to test (basic math - leftshift number):
  create a test result about "the noodle" and "1543 leftshifted 3 bits"
    and expecting "12344".
  put 1543 in a number.
  shift the number left 3 bits.
  stash the test result given the number.

to test (basic math - multiply numbers):
  create a test result about "the noodle" and "3 times 7" and expecting "21".
  put 7 in a number.
  multiply the number by 3.
  stash the test result given the number.

to test (basic math - negate negative number):
  create a test result about "the noodle" and "negate -5"
    and expecting "5".
  put -5 in a number.
  negate the number.
  stash the test result given the number.

to test (basic math - negate number):
  create a test result about "the noodle" and "negate 5"
    and expecting "-5".
  put 5 in a number.
  negate the number.
  stash the test result given the number.

to test (basic math - reduce 0 trifles):
  create a test result about "the noodle" and "reduce 0 trifles"
    and expecting "0/1".
  put 0/1866240000 in a ratio.
  reduce the ratio.
  put the ratio's numerator then "/"
    then the ratio's denominator in a string.
  stash the test result given the string.

to test (basic math - rightshift number):
  create a test result about "the noodle" and "12345 rightshifted 3 bits"
    and expecting "1543".
  put 12345 in a number.
  shift the number right 3 bits.
  stash the test result given the number.

to test (basic math - round 31 up to 32):
  create a test result about "the noodle" and "round 31 up to power of two"
    and expecting "32".
  put 31 in a number.
  round the number up to the nearest power of two.
  stash the test result given the number.

to test (basic math - round 32 up to 32):
  create a test result about "the noodle" and "round 32 up to power of two"
    and expecting "32".
  put 32 in a number.
  round the number up to the nearest power of two.
  stash the test result given the number.

to test (basic math - subtract numbers):
  create a test result about "the noodle" and "10 minus 3" and expecting "7".
  put 10 in a number.
  subtract 3 from the number.
  stash the test result given the number.

to test (basic math - unterminated string length):
  create a test result about "the noodle" and "unterminated string length"
    and expecting "5".
  put "12345" in a string.
  stash the test result given the string's length.

to test (basic math):
  test (basic math - add numbers).
  test (basic math - subtract numbers).
  test (basic math - rightshift number).
  test (basic math - leftshift number).
  test (basic math - round 31 up to 32).
  test (basic math - round 32 up to 32).
  test (basic math - unterminated string length).
  test (basic math - copy number).
  test (basic math - negate number).
  test (basic math - negate negative number).
  test (basic math - multiply numbers).
  test (basic math - divide 0 by 3).
  test (basic math - divide 1 by 3).
  test (basic math - divide 24 by 3).
  test (basic math - divide 25 by 3).
  test (basic math - divide 0 by 3 with remainder).
  test (basic math - divide 1 by 3 with remainder).
  test (basic math - divide 24 by 3 with remainder).
  test (basic math - divide 25 by 3 with remainder).
  test (basic math - 6 plus 0/1).
  test (basic math - reduce 0 trifles).
  test (basic math - 6 plus 0/1866240000).
  test (basic math - fractions and ratios).

to test (command line - get missing parameter):
  create a test result about "the noodle" and "get missing parameter"
    and expecting "".
  put "mycommand arg1 arg2= arg3=""another value""" in a command line.
  get a string called actual from the command line given "arg2".
  stash the test result given the actual.

to test (command line - get non-parameter from simple argument):
  create a test result about "the noodle" and "get non-parameter from simple argument"
    and expecting "".
  put "mycommand arg1 arg2= arg3=""another value""" in a command line.
  get a string called actual from the command line given "arg1".
  stash the test result given the actual.

to test (command line - get program name):
  create a test result about "the noodle" and "get program name"
    and expecting "mycommand".
  put "mycommand arg1 arg2=value arg3=""another value""" in a command line.
  get a string called actual from the command line.
  stash the test result given the actual.

to test (command line - get quoted parameter):
  create a test result about "the noodle" and "get quoted parameter"
    and expecting """another value""".
  put "mycommand arg1 arg2=value arg3=""another value""" in a command line.
  get a string called actual from the command line given "arg3".
  stash the test result given the actual.

to test (command line - get unquoted parameter):
  create a test result about "the noodle" and "get unquoted parameter"
    and expecting "value".
  put "mycommand arg1 arg2=value arg3=""another value""" in a command line.
  get a string called actual from the command line given "arg2".
  stash the test result given the actual.

to test (command line - missing argument is not important):
  create a test result about "the noodle" and "missing argument is not important"
    and expecting "arg4 is not an argument".
  put "mycommand arg1 arg2= arg3=""another value""" in a command line.
  put "arg4 is not an argument" in a string called actual.
  if "arg4" is important in the command line,
    put "arg4 is an argument" in the actual.
  stash the test result given the actual.

to test (command line - missing parameter is important):
  create a test result about "the noodle" and "missing parameter is important"
    and expecting "arg2 is an argument".
  put "mycommand arg1 arg2= arg3=""another value""" in a command line.
  put "arg2 is not an argument" in a string called actual.
  if "arg2" is important in the command line,
    put "arg2 is an argument" in the actual.
  stash the test result given the actual.

to test (command line - parsing):
  create a test result about "the noodle" and "parsing"
    and expecting "fred, ""jane  kate"", 'lil, min', /tt, /right, /left".
  put "fred ""jane  kate""   'lil  min' /tt /right /left" in a command line.
  parse the command line returning some string things.
  summarize the string things returning a string called actual (tersely).
  stash the test result given the actual.
  destroy the string things.
\
\ CAL interprets a pair of double-quotes
\   (in the source code that defines a string)
\   as one double-quote (in the defined string).
\ When parsing command lines in the Windows NT shell scripting language:
\  * One or more consecutive unquoted white-space characters
\    are treated as a single token delimiter.
\  * Treats single-quotes as ordinary characters.
\  * Does not eat double quotes.
\  * If an even number of double-quotes have been handled,
\    treats white space normally.
\  * If an odd number of double-quotes have been handled,
\    treats white space as ordinary characters.
\ The preceding test verifies that CAL has the same behavior.

to test (command line - quoted parameter is important):
  create a test result about "the noodle" and "quoted parameter is important"
    and expecting "arg3 is an argument".
  put "mycommand arg1 arg2=value arg3=""another value""" in a command line.
  put "arg3 is not an argument" in a string called actual.
  if "arg3" is important in the command line,
    put "arg3 is an argument" in the actual.
  stash the test result given the actual.

to test (command line - simple argument is important):
  create a test result about "the noodle" and "simple argument is important"
    and expecting "arg1 is an argument".
  put "mycommand arg1 arg2= arg3=""another value""" in a command line.
  put "arg1 is not an argument" in a string called actual.
  if "arg1" is important in the command line,
    put "arg1 is an argument" in the actual.
  stash the test result given the actual.

to test (command line - unquoted parameter is important):
  create a test result about "the noodle" and "unquoted parameter is important"
    and expecting "arg2 is an argument".
  put "mycommand arg1 arg2=value arg3=""another value""" in a command line.
  put "arg2 is not an argument" in a string called actual.
  if "arg2" is important in the command line,
    put "arg2 is an argument" in the actual.
  stash the test result given the actual.

to test (command line):
  test (command line - parsing).
  test (command line - missing argument is not important).
  test (command line - simple argument is important).
  test (command line - missing parameter is important).
  test (command line - quoted parameter is important).
  test (command line - unquoted parameter is important).
  test (command line - get program name).
  test (command line - get non-parameter from simple argument).
  test (command line - get missing parameter).
  test (command line - get quoted parameter).
  test (command line - get unquoted parameter).

to test (square root of 0 is 0):
  create a test result about "the noodle"
    and "square root of 0 is 0" and expecting "0".
  put the square root of 0 in a number called actual.
  stash the test result given the actual.

to test (square root of 1 is 1):
  create a test result about "the noodle"
    and "square root of 1 is 1" and expecting "1".
  put the square root of 1 in a number called actual.
  stash the test result given the actual.

to test (square root of 100 is 10):
  create a test result about "the noodle"
    and "square root of 100 is 10" and expecting "10".
  put the square root of 100 in a number called actual.
  stash the test result given the actual.

to test (square root of 1000000 is 1000):
  create a test result about "the noodle"
    and "square root of 1000000 is 1000" and expecting "1000".
  put the square root of 1000000 in a number called actual.
  stash the test result given the actual.

to test (square root of 1002000 is 1000):
  create a test result about "the noodle"
    and "square root of 1002000 is 1000" and expecting "1000".
  put the square root of 1002000 in a number called actual.
  stash the test result given the actual.

to test (square root of 1002001 is 1001):
  create a test result about "the noodle"
    and "square root of 1002001 is 1001" and expecting "1001".
  put the square root of 1002001 in a number called actual.
  stash the test result given the actual.

to test (square root of 121 is 11):
  create a test result about "the noodle"
    and "square root of 121 is 11" and expecting "11".
  put the square root of 121 in a number called actual.
  stash the test result given the actual.

to test (square root of 1866239999 is 43199):
  create a test result about "the noodle"
    and "square root of 1866239999 is 43199" and expecting "43199".
  put the square root of 1866239999 in a number called actual.
  stash the test result given the actual.

to test (square root of 1866240000 is 43200):
  create a test result about "the noodle"
    and "square root of 1866240000 is 43200" and expecting "43200".
  put the square root of 1866240000 in a number called actual.
  stash the test result given the actual.

to test (square root of 2147395599 is 46339):
  create a test result about "the noodle"
    and "square root of 2147395599 is 46339" and expecting "46339".
  put the square root of 2147395599 in a number called actual.
  stash the test result given the actual.

to test (square root of 2147395600 is 46340):
  create a test result about "the noodle"
    and "square root of 2147395600 is 46340" and expecting "46340".
  put the square root of 2147395600 in a number called actual.
  stash the test result given the actual.

to test (square root of 2147483647 is 46340):
  create a test result about "the noodle"
    and "square root of 2147483647 is 46340" and expecting "46340".
  put the square root of 2147483647 in a number called actual.
  stash the test result given the actual.

to test (square root of 3 is 1):
  create a test result about "the noodle"
    and "square root of 3 is 1" and expecting "1".
  put the square root of 3 in a number called actual.
  stash the test result given the actual.

to test (square root of 81 is 9):
  create a test result about "the noodle"
    and "square root of 81 is 9" and expecting "9".
  put the square root of 81 in a number called actual.
  stash the test result given the actual.

to test (square root of 99 is 9):
  create a test result about "the noodle"
    and "square root of 99 is 9" and expecting "9".
  put the square root of 99 in a number called actual.
  stash the test result given the actual.

to test (square root of 999999 is 999):
  create a test result about "the noodle"
    and "square root of 999999 is 999" and expecting "999".
  put the square root of 999999 in a number called actual.
  stash the test result given the actual.

to test (square root):
  test (square root of 0 is 0).
  test (square root of 1 is 1).
  test (square root of 3 is 1).
  test (square root of 81 is 9).
  test (square root of 99 is 9).
  test (square root of 100 is 10).
  test (square root of 121 is 11).
  test (square root of 999999 is 999).
  test (square root of 1000000 is 1000).
  test (square root of 1002000 is 1000).
  test (square root of 1002001 is 1001).
  test (square root of 1866239999 is 43199).
  test (square root of 1866240000 is 43200).
  test (square root of 2147395599 is 46339).
  test (square root of 2147395600 is 46340).
  test (square root of 2147483647 is 46340).

to test (the noodle - 200021 is not prime):
  create a test result about "the noodle" and "200021 is not prime"
    and expecting "200021 is not prime".
  put "200021 is not prime" in an actual string.
  if 200021 is prime,
    put "200021 is prime" in the actual string.
  stash the test result given the actual.

to test (the noodle - 200023 is prime):
  create a test result about "the noodle" and "200023 is prime"
    and expecting "200023 is prime".
  put "200023 is not prime" in an actual string.
  if 200023 is prime,
    put "200023 is prime" in the actual string.
  stash the test result given the actual.

to test (the noodle - deduplication):
  create a test result about "the noodle" and "deduplication"
    and expecting "al, betsy, betty, carl".
  add "al" to some string things called nametags.
  add "carl" to the nametags.
  add "betty" to the nametags.
  add "al" to the nametags.
  add "betsy" to the nametags.
  add "al" to the nametags.
  add "betsy" to the nametags.
  add "carl" to the nametags.
  sort the nametags.
  deduplicate the nametags.
  summarize the nametags returning a string called actual (tersely).
  stash the test result given the actual.
  destroy the nametags.

to test (the noodle - dll found):
  create a test result about "the noodle" and "dll found"
    and expecting "'kernel32.dll' found".
  put "kernel32.dll" in a library.
  put "'kernel32.dll' not found" in a string called actual.
  if the library is loadable, put "'kernel32.dll' found" in the actual.
  stash the test result using the actual.

to test (the noodle - dll not found):
  create a test result about "the noodle" and "dll not found"
    and expecting "'bogus.dll' not found".
  put "bogus.dll" in a library.
  put "'bogus.dll' not found" in a string called actual.
  if the library is loadable, put "'bogus.dll' found" in the actual.
  stash the test result using the actual.

to test (the noodle - dll procedure found):
  create a test result about "the noodle" and "dll procedure found"
    and expecting "'WriteFile' found in 'kernel32.dll'".
  put "'WriteFile' not found in 'kernel32.dll'" in a string called actual.
  put "kernel32.dll" in a library.
  put "WriteFile" in a library procedure.
  if can find the library procedure in the library,
    put "'WriteFile' found in 'kernel32.dll'" in the actual.
  stash the test result using the actual.

to test (the noodle - dll procedure not found):
  create a test result about "the noodle" and "dll procedure not found"
    and expecting "'BogusProcedure' not found in 'kernel32.dll".
  put the test result's expectation in a string called actual.
  put "kernel32.dll" in a library.
  put "BogusProcedure" in a library procedure.
  if can find the library procedure in the library,
    put "'BogusProcedure' found in 'kernel32.dll" in the actual.
  stash the test result using the actual.

to test (the noodle - find parent of non-existent folder):
  get an environment variable called user profile given "USERPROFILE".
  put the user profile in a path.
  if the path is not directory-format,
    append the backslash byte to the path.
  create a test result about "the noodle" and "find parent of non-existent folder"
    and expecting the path.
  put the path then "non-existent-item-123456890" in a path called bogus path.
  put "cal.exe /folder=""" then the bogus path then """" in a command line.
  get requested leaf directory path given the command line returning a string called actual.
  stash the test result given the actual.

to test (the noodle - prepend things):
  create a test result about "the noodle" and "prepend things"
    and expecting "a, b, 1, 2, 3".
  add "1" to some string things.
  add "2" to the string things.
  add "3" to the string things.
  add "a" to some other string things.
  add "b" to the other string things.
  prepend the other string things to the string things.
  summarize the string things returning an actual string (tersely).
  stash the test result given the actual.
  destroy the string things.
  destroy the other string things.

to test (the noodle - primes through 47):
  put "2, 3, 5, 7, 11, 13, 17, 19, 23, " 
    then "29, 31, 37, 41, 43, 47" in a prefix string.
  put "cached early primes start with " then the prefix string
    in an expected string.
  create a test result about "the noodle" and "primes through 47"
    and expecting the expected string.
  \ The early primes might not be cached yet,
  \ or might already be cached through any prime number
  \ less than or equal to the largest square root.
  \ In case they have not already been cached through 47,
  \ cache the early primes through the square root of 2500:
  if 2500 is prime,
    put "2500 is prime" in an actual string;
    stash the test result given the actual;
    exit.
  summarize the cached early primes returning a string (tersely).
  if the string starts with the prefix,
    put the expected string in the actual string;
    stash the test result given the actual;
    exit.
  put "cached early primes are " then the string in the actual.
  stash the test result given the actual.    

to test (the noodle - replace substring):
  create a test result about "the noodle" and "replace substring"
    and expecting "wowRACADwowRA wowracadwowra".
  put "ABRACADABRA abracadabra" in a string called actual.
  replace "ab" with "wow" in the actual (throughout).
  stash the test result given the actual.

to test (the noodle - sorting):
  create a test result about "the noodle" and "sorting"
    and expecting "al, al, al, betsy, betsy, betty, carl, carl".
  add "al" to some string things called nametags.
  add "carl" to the nametags.
  add "betty" to the nametags.
  add "al" to the nametags.
  add "betsy" to the nametags.
  add "al" to the nametags.
  add "betsy" to the nametags.
  add "carl" to the nametags.
  sort the nametags.
  summarize the nametags returning a string called actual (tersely).
  stash the test result given the actual.
  destroy the nametags.

to test (the noodle - trim complete length from end of string):
  create a test result about "the noodle" and "trim complete length from end of string"
    and expecting "".
  put "trim length" in a string called actual.
  put 11 in a length.
  trim the length from the actual.
  stash the test result given the actual.

to test (the noodle - trim excess length from end of string):
  create a test result about "the noodle" and "trim excess length from end of string"
    and expecting "".
  put "trim length" in a string called actual.
  put 12 in a length.
  trim the length from the actual.
  stash the test result given the actual.

to test (the noodle - trim length from end of string):
  create a test result about "the noodle" and "trim length from end of string"
    and expecting "trim l".
  put "trim length" in a string called actual.
  put 5 in a length.
  trim the length from the actual.
  stash the test result given the actual.

to test (the noodle - user profile is a directory path):
  get an environment variable called user profile given "USERPROFILE".
  put the user profile in a path.
  if the path is not directory-format,
    append the backslash byte to the path.
  create a test result about "the noodle" and "user profile is a directory path"
    and expecting the path.
  put "cal.exe /folder=""" then the user profile then """" in a command line.
  get requested leaf directory path given the command line returning a path called actual.
  stash the test result given the actual.

to test (the noodle - user profile is not blank):
  create a test result about "the noodle" and "user profile is not blank"
    and expecting "user profile is not blank".
  put "user profile is blank" in a string called actual.
  get an environment variable called user profile given "USERPROFILE".
  if the user profile is not "", put "user profile is not blank" in the actual.
  stash the test result given the actual.

to test (the noodle):
  test (the talker).
  test (basic math).
  test (command line).
  test (square root).
  test (the noodle - primes through 47).
  test (the noodle - 200021 is not prime).
  test (the noodle - 200023 is prime).
  test (the noodle - dll not found).
  test (the noodle - dll found).
  test (the noodle - dll procedure not found).
  test (the noodle - dll procedure found).
  test (the noodle - sorting).
  test (the noodle - deduplication).
  test (the noodle - trim complete length from end of string).
  test (the noodle - trim excess length from end of string).
  test (the noodle - trim length from end of string).
  test (the noodle - user profile is not blank).
  test (the noodle - user profile is a directory path).
  test (the noodle - find parent of non-existent folder).
  test (the noodle - replace substring).
  test (the noodle - prepend things).

to test (the talker - find PlaySound):
  create a test result about "the noodle" and "find PlaySound"
    and expecting "'PlaySound' found in 'winmm.dll'".
  put "'PlaySound' not found in 'winmm.dll'" in a string called actual.
  put "winmm.dll" in a library.
  put "PlaySound" in a library procedure.
  if can find the library procedure in the library,
    put "'PlaySound' found in 'winmm.dll'" in the actual.
  stash the test result using the actual.

to test (the talker - find sapi):
  \ SAPI is the Speech Application Protocol Interface.
  create a test result about "the noodle" and "find sapi.dll"
    and expecting "'sapi.dll' found".
  put "sapi.dll" in a library.
  put "'sapi.dll' not found" in a string called actual.
  if the library is loadable, put "'sapi.dll' found" in the actual.
  stash the test result using the actual.

to test (the talker - find winmm):
  create a test result about "the noodle" and "find winmm.dll"
    and expecting "'winmm.dll' found".
  put "winmm.dll" in a library.
  put "'winmm.dll' not found" in a string called actual.
  if the library is loadable, put "'winmm.dll' found" in the actual.
  stash the test result using the actual.
\
\to test (the talker - get winmm clsid):
\  \ winmm.dll includes "PlaySound".
\  create a test result about "the noodle" and "get winmm.dll's clsid"
\    and expecting "the winmm clsid".
\  \ try to get the dll's clsid using the Windows guid:
\  put "{96749377-3391-11D2-9EE3-00C04F797396}" in a string called clsid_spvoice.
\  convert the clsid_spvoice to a clsid.
\  transcribe the clsid into a string called actual.
\  stash the test result given the actual.

to test (the talker):
\  test (the talker - get winmm clsid).
  test (the talker - find winmm).
  test (the talker - find sapi).

a test result is a thing with
  a string called context,
  a string called test name,
  an expectation,
  a string called actual value, and
  an interpretation.

the text cutoff is a number equal to 500.

a textmetric is a record with
  a number called tmheight,
  a number called tmascent,
  a number called tmdescent,
  a number called tminternalleading,
  a number called tmexternalleading,
  a number called tmavecharwidth,
  a number called tmmaxcharwidth,
  a number called tmweight,
  a number called tmoverhang,
  a number called tmdigitizedaspectx,
  a number called tmdigitizedaspecty,
  a byte called tmfirstchar,
  a byte called tmlastchar,
  a byte called tmdefaultchar,
  a byte called tmbreakchar,
  a byte called tmitalic,
  a byte called tmunderlined,
  a byte called tmstruckout,
  a byte called tmpitchandfamily,
  a byte called tmcharset.

a thing is a pointer to a thing record.

a thing record has a next thing and a previous thing.

some things has a first thing and a last thing.

a thousand is 10 hundreds.

a thread handle is a handle.

a tick is a number.

a timer has a count, some start ticks and some total ticks.

some times is a number.

a top is some twips.

the tpi is some twips equal to 1440.

the tpp is some twips.

to transcribe a uuid to a string:
  put the uuid's d1 then " " then the uuid's d2 then " " then
      the uuid's d3 then " " then the uuid's d4 into the string.

to trim a length from a string:
  slap a substring on the string.
  put the substring's first plus the string's length minus 1 minus the length into the substring's last.   
  if the substring's first is greater than the substring's last,
    put "" in the string; exit.
  put the substring in the string.

to trim a string:
  remove any leading noise from the string.
  remove any trailing noise from the string.

a twip is a number.

to unassign a pointer:
  if the pointer is nil, exit.
  call "kernel32.dll" "HeapFree"
    with the heap pointer and 0 [no options] and the pointer returning a number.
  if the number is 0, exit.
  void the pointer.
  subtract 1 from the heap count.

to uncache a library:
  uncache the library from the cached found library procedures.
  uncache the library from the cached missing library procedures.

to uncache a library from some string things:
  put the library then ";" in a string.
  loop.
    get a string thing from the string things.
    if the string thing is nil, exit.
    if the string thing's string starts with the string,
      remove the string thing from the cached found library procedures.
  repeat.

to uncache a library procedure in a library:
  uncache the library procedure in the library
    from the cached found library procedures.
  uncache the library procedure in the library
    from the cached missing library procedures.

to uncache a library procedure in a library from some string things:
  put the library then ";" then the library procedure in a string.
  loop.
    get a string thing from the string things.
    if the string thing is nil, exit.
    if the string thing's string is the string,
      remove the string thing from the cached found library procedures.
  repeat.

a unit is a number.

to unlock a gpbitmap given a bitmapdata:
  call "gdiplus.dll" "GdipBitmapUnlockBits"
    with the gpbitmap and the bitmapdata's whereabouts.

to unmask everything:
  call "gdi32.dll" "SelectClipRgn" with the current canvas and 0.

to unmask inside a box:
  create an hrgn given the box.
  unmask inside the hrgn.
  destroy the hrgn.

to unmask inside an ellipse:
  create an hrgn given the ellipse.
  unmask inside the hrgn.
  destroy the hrgn.

to unmask inside an hrgn:
  call "gdi32.dll" "ExtSelectClipRgn"
    with the current canvas and the hrgn and 2 [rgn_or].

to unmask inside a polygon:
  create an hrgn given the polygon.
  unmask inside the hrgn.
  destroy the hrgn.

to unmask inside a roundy box:
  create an hrgn given the roundy box.
  unmask inside the hrgn.
  destroy the hrgn.

to unmask outside a box:
  create an hrgn given the box.
  unmask outside the hrgn.
  destroy the hrgn.

to unmask outside an ellipse:
  create an hrgn given the ellipse.
  unmask outside the hrgn.
  destroy the hrgn.

to unmask outside an hrgn:
  create an old hrgn given the zero box.
  call "gdi32.dll" "GetClipRgn" with the current canvas and the old hrgn returning a number.
  if the number is not 1, clear the old hrgn.
  call "gdi32.dll" "SelectClipRgn" with the current canvas and 0.
  call "gdi32.dll" "ExtSelectClipRgn" with the current canvas and the hrgn and 4 [rgn_diff].
  call "gdi32.dll" "ExtSelectClipRgn" with the current canvas and the old hrgn and 2 [rgn_or].
  destroy the old hrgn.

to unmask outside a polygon:
  create an hrgn given the polygon.
  unmask outside the hrgn.
  destroy the hrgn.

to unmask outside a roundy box:
  create an hrgn given the roundy box.
  unmask outside the hrgn.
  destroy the hrgn.

to unquote a string:
  slap a substring on the string.
  if the substring is blank, break.
  if the substring's first's target is not the double-quote byte, exit.
  add 1 to the substring's first.
  loop.
    if the substring is blank, break.
    if the substring's first is the substring's last, break.
    append the substring's first's target to another string.
    if the substring's first's target is the double-quote byte,
      add 1 to the substring's first.
    add 1 to the substring's first.
  repeat.
  put the other string into the string.

to update the screen;
to show it;
to show it all;
to show reveal the canvas;
to refresh the screen:
  refresh the screen given the screen's box.

to uppercase the character under a finger and put it into a string:
  if the finger is nil, exit.
  put the finger's target into the string.
  uppercase the string.

to uppercase a string:
  slap a substring on the string.
  loop.
    if the substring is blank, exit.
    uppercase the substring's first's target.
    add 1 to the substring's first.
  repeat.

a url is a string.

a url record has
  a scheme string,
  a host name string,
  a path string,
  an extra string,
  a port number.

a urlcomponents is a record with
  a number called dwstructsize,
  a pchar called lpszscheme,
  a number called dwschemelength,
  a number called nscheme,
  a pchar called lpszhostname,
  a number called dwhostnamelength,
  a number called nport,
    \ this is typed as a wyrd in windows documentation, but doesn't work
  a pchar called lpszusername,
  a number called dwusernamelength,
  a pchar called lpszpassword,
  a number called dwpasswordlength,
  a pchar called lpszurlpath,
  a number called dwurlpathlength,
  a pchar called lpszextrainfo,
  a number called dwextrainfolength.

a uuid is a record with
  a number called d1,
  a wyrd called d2,
  a wyrd called d3,
  8 bytes called d4.

a vertex array is a pointer to a vertex array record.

a vertex array record has a count and a spot pointer.

a vertex is a thing with an x coord, a y coord, a spot at the x.

a w-param is a number.

to wait for an event;
to deque an event:
  yield to windows.
  put the event queue's first into the event.
  if the event is nil, repeat.
  remove the event from the event queue.
  if the event's kind is "done", destroy the event; exit.
  destroy the current event.
  put the event into the current event.

to wait for some grains of sand;
to wait for some grains of sand to fall;
to wait for some grains of sand to fall in the hourglass;
to wait some milliseconds;
to wait for some milliseconds:
  if the milliseconds are at most 0, exit.
  call "kernel32.dll" "Sleep" with the milliseconds.

to wait until speaking is done:
  if the talker is nil, exit.
  call the talker's vtable's waituntildone with the talker and -1.

a wave file is a path.

a wave is a hex string.

a wide string is a string.
\
\to widen a window:
\  initialize a window placement.
\  call "User32.dll" "GetWindowPlacement"
\    with the window and the window placement's whereabouts
\    returning a flag.
\  if the flag is no, exit.
\  put the window placement's boxWhenRestored in a box.
\  put the box's right plus 100 in the box's right.
\  put the box in the window placement's boxWhenRestored.
\  call "User32.dll" "SetWindowPlacement"
\    with the window and the window placement's whereabouts
\    returning another flag.

a width is some twips.

a win32finddata is a record with
  a number called dwfileattributes,
  a filetime called ftcreationtime,
  a filetime called ftlastaccesstime,
  a filetime called ftlastwritetime,
  a number called nfilesizehigh,
  a number called nfilesizelow,
  a number called dwreserved0,
  a number called dwreserved1,
  260 bytes called cfilename,
  14 bytes called calternatefilename.

a window class is a record with
  a number called cbsize,
  a number called style,
  a pointer called lpfnwndproc,
  a number called cbclsextra,
  a number called cbwndextra,
  a handle called hinstance,
  a hicon called hicon,
  a cursor called hcursor,
  an hbrush called hbrbackground,
  a pointer called lpszmenuname,
  a pointer called lpszclassname,
  a hicon called hiconsm.

the window class is a window class.

a window is a handle.

a window placement has
  a number called length,
  a number called flags,
  a number called showCmd,
  a spot called upperLeftCornerWhenMinimized,
  a spot called upperLeftCornerWhenMaximized,
  a box called boxWhenRestored.

a winhttp request is a thing with
  a session handle,
  a connection handle,
  a request handle.

a word is a substring.

to write a buffer to stderr:
  clear the i/o error.
  get stderr returning a standard handle.
  if the i/o error is not blank, exit.
  call "kernel32.dll" "WriteFile" with the standard handle
    and the buffer's first and the buffer's length
    and a number's whereabouts and 0 returning the number.
  call "kernel32.dll" "CloseHandle" with the standard handle.
  if the number is not 0, exit.
  put "Error writing to the standard error stream." into the i/o error.

to write a byte:
  put the byte into a string.
  write the string.

to write a byte to stdout:
  call "kernel32.dll" "WriteFile" with the stdout handle
    and the byte's whereabouts and 1 and a number's whereabouts and nil.

to write a byte without advancing:
  put the byte into a string.
  write the string without advancing.

to write a flag:
  convert the flag to a string.
  write the string.

to write a flag without advancing:
  convert the flag to a string.
  write the string without advancing.

to write a number:
  convert the number to a string.
  write the string.

to write a number without advancing:
  convert the number to a string.
  write the string without advancing.

to write a ratio:
  convert the ratio to a string.
  write the string.

to write a ratio without advancing:
  convert the ratio to a string.
  write the string without advancing.

to write a string to stdout:
  call "kernel32.dll" "WriteFile" with the stdout handle
    and the string's first and the string's length
    and a number's whereabouts and nil.

to write a string with a font and a size and a color and a spot:
  put the size into the font's height.
  put the string's width into a width.
  put the spot and the spot into a box.
  subtract the width divided by 2 from the box's left.
  add the width divided by 2 to the box's right.
  subtract the size divided by 2 from the box's top.
  add the size divided by 2 to the box's bottom.
  draw the string in the box with the color and the font and "center".
  refresh the screen.

a wsadata is a record with
  a wyrd called wversion,
  a wyrd called whighversion,
  257 bytes called szdescription,
  127 bytes called szsystemstatus,
  a wyrd [unsigned] called imaxsockets,
  a wyrd [unsigned] called imaxudpdg,
  a pointer called lpvendorinfo.

a wyrd has a low byte and a high byte.

an xor-mask is a mask.

to yield to windows:
  if the event queue is not empty, exit.
  call "user32.dll" "GetMessageA"
    with an msg's whereabouts and 0 and 0 and 0 returning a number.
  if the number is 0, exit.
  call "user32.dll" "TranslateMessage" with the msg's whereabouts.
  call "user32.dll" "DispatchMessageA" with the msg's whereabouts.

the zero box is a box.

to zero fill a number given a count and append it to a string:
  convert the number to another string.
  zero fill the other string given the count.
  append the other string to the string.

to zero fill a string given a count:
  if the string's length is greater than or equal to the count, exit.
  prepend the zero byte to the string.
  repeat.

the zero spot is a spot.

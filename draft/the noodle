\ copyright © 2006 the osmosian order (3040)

\ here are the text rules:
\   in a non-wrapped text, the rows end with a return byte.
\   in a wrapped text, the rows end with either a return byte or a space.
\   when text is converted to a string, linefeed bytes are added after return bytes.
\   when a string is converted to text, linefeed bytes are removed.
\   there is always at least one row.
\   there is always a return byte at the end of the last row.

the a-key is a key equal to 65. 

an abc is a record with
  a number called abca,
  a number called abcb,
  a number called abcc.

an abc pointer is a pointer to an abc.

an abca is a number.

an abcc is a number.

an absolute position is a number.

the accent byte is a byte equal to 96.

the accent key is a key equal to 192.

the acknowledge byte is a byte equal to 6.

the acute-accent byte is a byte equal to 180.

to add a byte to another byte:
  intel $8B8508000000. \ mov eax,[ebp+8] \ the byte
  intel $0FB600. \ movzx eax,[eax]
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the other byte
  intel $0003. \ add [ebx],al

to add a byte to a number:
  intel $8B8508000000. \ mov eax,[ebp+8] \ the byte
  intel $0FB600. \ movzx eax,[eax]
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the number
  intel $0103. \ add [ebx],eax

to add a number and another number to a pair:
  add the number to the pair's x.
  add the other number to the pair's y.

to add a number to another number:
  intel $8B8508000000. \ mov eax,[ebp+8] \ the number
  intel $8B00. \ mov eax,[eax]
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the other number
  intel $0103. \ add [ebx],eax

to add a number to a byte:
  intel $8B8508000000. \ mov eax,[ebp+8] \ the number
  intel $8B00. \ mov eax,[eax]
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the byte
  intel $0FB60B. \ movzx ecx,[ebx]
  intel $03C8. \ add ecx,eax
  intel $880B. \ mov [ebx],cl

to add a number to a pair:
  add the number to the pair's x.
  add the number to the pair's y.

to add a number to a pointer: employ add a number to another number.

to add a number to a ratio:
  add the number / 1 to the ratio.

to add a pair to another pair:
  add the pair's x to the other pair's x.
  add the pair's y to the other pair's y.

to add a pdf object given a kind:
  create the pdf object given the kind.
  append the pdf object to the pdf state's objects.
  add 1 to the pdf state's object number.
  put the pdf state's object number into the pdf object's number.

to add a ratio to another ratio:
  privatize the ratio.
  normalize the ratio and the other ratio.
  add the ratio's numerator to the other ratio's numerator.
  reduce the other ratio.

to add a string to some string things:
  create a string thing given the string.
  append the string thing to the string things.

an addrinfo is a record with
  a number called ai_flags,
  a number called ai_family,
  a number called ai_sockettype,
  a number called ai_protocol,
  a number called ai_addrlen,
  a pchar called ai_canonname,
  a sockaddrptr called ai_addr,
  a addrinfoptr called ai_next.

some addrinfo routines is a record with
  a getaddrinfo pointer,
  a freeaddrinfo pointer.

an addrinfoptr is a pointer to an addrinfo.

to adjust a box given a number and another number and a third number and a fourth number:
  add the number to the box's left.
  add the other number to the box's top.
  add the third number to the box's right.
  add the fourth number to the box's bottom.

to adjust an item:
  put the item's win32finddata's dwfileattributes into a number.
  bitwise and the number with 16 [file_attribute_directory].
  if the number is 0, put "file" into the item's kind.
  if the number is not 0, put "directory" into the item's kind.
  put the item's win32finddata's cfilename's whereabouts into a pchar.
  convert the pchar to the item's designator.
  if the item's kind is "directory", append "\" to the item's designator.
  put the item's directory then the item's designator into the item's path.
  extract the item's extension from the item's designator as a path.
  put the item's win32finddata's nfilesizelow into the item's size.
  if the item's designator's first's target is not the period byte, exit.
  get the item (not first time).

to adjust a line with a number and another number and a third number and a fourth number:
  add the number to the line's start's x.
  add the other number to the line's start's y.
  add the third number to the line's end's x.
  add the fourth number to the line's end's y.

to adjust a picture (extract boxes from gpbitmap):
  if the picture is nil, exit.
  put 0 into the picture's box's left.
  put 0 into the picture's box's top.
  put the picture's gpbitmap's width minus 1 times the tpp into the picture's box's right.
  put the picture's gpbitmap's height minus 1 times the tpp into the picture's box's bottom.
  put the picture's box into the picture's uncropped box.

to adjust spacing given a string:
  if the current canvas is not the printer canvas, exit.
  call "gdi32.dll" "SetTextCharacterExtra" with the printer canvas and 0.
  call "gdi32.dll" "GetCurrentObject" with the printer canvas and 6 [obj_font] returning a handle.
  call "gdi32.dll" "SelectObject" with the memory canvas and the handle.
  get a width given the string and the memory canvas.
  call "gdi32.dll" "SelectObject" with the memory canvas and the null hfont.
  get another width given the string and the printer canvas.
  put the width minus the other width divided by the string's length into a number.
  call "gdi32.dll" "SetTextCharacterExtra" with the printer canvas and the number.

to align a text given an alignment:
  put the alignment into the text's alignment.

an alignment is a string [center, left, or right].

the alt key is a key equal to 18.

an amount is a number.

the ampersand byte is a byte equal to 38.

an anchor is a position.

an and-mask is a mask.

an angle is a number [0 to 3600].

to append a buffer to a file:
  clear the i/o error.
  call "kernel32.dll" "SetFilePointer" with the file and 0 and 0 and 2 [file_end] returning a result number.
  if the result number is -1, put "Error positioning file pointer." into the i/o error; exit.
  call "kernel32.dll" "WriteFile" with the file and the buffer's first and the buffer's length and a number's whereabouts and 0 returning the result number.
  if the result number is 0, put "Error writing file." into the i/o error; exit.

to append a byte to a string:
  put the string's length into a saved length.
  reassign the string's first given the string's length plus 1.
  put the string's first plus the saved length into the string's last.
  put the byte into the string's last's target.

to append a byte to a string given a count:
  privatize the count.
  loop.
  if the count is less than 1, exit.
  append the byte to the string.
  subtract 1 from the count.
  repeat.

to append a flag to a string:
  convert the flag to another string.
  append the other string to the string.

to append a number to a string:
  convert the number to another string.
  append the other string to the string.

to append a pointer to a string:
  convert the pointer to another string.
  append the other string to the string.

to append a ratio to a string:
  convert the ratio to another string.
  append the other string to the string.

to append a spot to a polygon:
  if the polygon is nil, exit.
  create a vertex given the spot.
  append the vertex to the polygon's vertices.

to append a string to another string:
  if the string is blank, exit.
  put the string's length into a combined length.
  put the other string's length into a saved length.
  add the saved length to the combined length.
  reassign the other string's first given the combined length.
  put the other string's first plus the saved length into a pointer.
  copy bytes from the string's first to the pointer for the string's length.
  put the other string's first plus the combined length minus 1 into the other string's last.

to append a string to another string (handling email transparency):
  if the string is blank, exit.
  slap a rider on the string.
  loop.
  move the rider (text file rules).
  if the rider's token is blank, exit.
  if the rider's token starts with ".", append "." to the other string.
  append the rider's token to the other string.
  repeat.

to append a string to another string given a count:
  privatize the count.
  loop.
  if the count is less than 1, exit.
  append the string to the other string.
  subtract 1 from the count.
  repeat.

to append a string to a pdf object: \ this guys adds CRLF
  append the string to the pdf object's data.
  append the crlf string to the pdf object's data.

to append a string to a pdf object without advancing:
  append the string to the pdf object's data.

to append a thing to some things:
  if the thing is nil, exit.
  put the things' last into the thing's previous.
  if the things are not empty, put the thing into the things' last's next.
  if the things are empty, put the thing into the things' first.
  put the thing into the things' last.

to append some things to some other things:
  put the things' first into a thing.
  if the thing is nil, exit.
  remove the thing from the things.
  append the thing to the other things.
  repeat.

to append a timer to a string:
  convert the timer to another string.
  append the other string to the string.

to append a vertex to a polygon:
  if the polygon is nil, exit.
  append the vertex to the polygon's vertices.

to append an x coord and a y coord to a polygon:
  if the polygon is nil, exit.
  create a vertex given the x and the y.
  append the vertex to the polygon's vertices.

to append zeros to a string until its length is a number:
  if the string's length is greater than or equal to the number, exit.
  append "0" to the string.
  repeat.

the arrow cursor is a cursor.

to assign a pointer given a byte count:
  if the byte count is 0, void the pointer; exit.
  privatize the byte count.
  round the byte count up to the nearest power of two.
  call "kernel32.dll" "HeapAlloc" with the heap pointer and 8 [heap_zero_memory] and the byte count returning the pointer.
  if the pointer is not nil, add 1 to the heap count; exit.

the asterisk byte is a byte equal to 42.

the at-sign byte is a byte equal to 64.

to autoscroll a text given a spot and a flag:
  if the text is nil, clear the flag; exit.
  put the text's font's height into a number.
  clear a difference.
  put the text's box into a box.
  indent the box given the tpp.
  if the spot's y is less than the box's top, put the number into the difference's y.
  if the spot's y is greater than the box's bottom, put the number into the difference's y; negate the difference's y.
  if the spot's x is less than the box's left, put the number into the difference's x.
  if the spot's x is greater than the box's right, put the number into the difference's x; negate the difference's x.
  if the text's horizontal scroll flag is not set, put 0 into the difference's x.
  if the text's vertical scroll flag is not set, put 0 into the difference's y.
  if the difference is 0, clear the flag; exit.
  set the flag.
  scroll the text given the difference.
  wait for 50 milliseconds.

the b-key is a key equal to 66.

the backslash byte is a byte equal to 92.

the backspace key is a key equal to 8.

the bar byte is a byte equal to 124.

a baseline is a number.

to beep: 
  call "user32.dll" "MessageBeep" with 0.

to begin a landscape sheet:
  make the landscape sheet 11 inches by 8-1/2 inches.
  begin a sheet with the landscape sheet.

to begin a landscape sheet given a title string:
  if the pdf document flag is not set, clear the landscape sheet; exit.
  make the landscape sheet 11 inches by 8-1/2 inches.
  begin the sheet given the box and the title (pdf style).

to begin a portrait sheet:
  make the portrait sheet 8-1/2 inches by 11 inches.
  begin a sheet with the portrait sheet.

to begin a portrait sheet given a title string:
  if the pdf document flag is not set, clear the portrait sheet; exit.
  make the portrait sheet 8-1/2 inches by 11 inches.
  begin the sheet given the box and the title (pdf style).

to begin printing:
  initialize the printer canvas.
  put a docinfo's magnitude into the docinfo's cbsize.
  put the module's name's first into the docinfo's lpszdocname.
  call "gdi32.dll" "StartDocA" with the printer canvas and the docinfo's whereabouts.

to begin printing a pdf:
  set the pdf state's document flag.
  put 0 into the pdf state's object number.
  create the pdf state's font index given 113.
  begin printing the pdf (start the root).
  begin printing the pdf (start the parent).

to begin printing a pdf (start the parent):
  add a parent pdf object given "parent".
  put the parent into the pdf state's parent.
  append the parent's number then " 0 obj" to the parent.
  append "<<" to the parent.
  append "/Type /Pages" to the parent.

to begin printing a pdf (start the root):
  add a root pdf object given "root".
  put the root into the pdf state's root.
  append the root's number then " 0 obj" to the root.
  append "<<" to the root.
  append "/Type /Catalog" to the root.

to begin a sheet:
  begin the sheet as a portrait sheet.

to begin a sheet given a box:
  if the pdf state's document flag is set, begin the sheet given the box (pdf style); exit.
  call "kernel32.dll" "GlobalLock" with the printer device mode handle returning a pdevmode.
  if the pdevmode is nil, exit.
  bitwise or the pdevmode's dmfields with 1 [dm_orientation].
  put 1 [dmorient_portrait] into the pdevmode's dmorientation.
  if the box's width is greater than the box's height, put 2 [dmorient_landscape] into the pdevmode's dmorientation.
  call "gdi32.dll" "ResetDCA" with the printer canvas and the pdevmode.
  call "kernel32.dll" "GlobalUnlock" with the printer device mode handle.
  call "gdi32.dll" "SetGraphicsMode" with the printer canvas and 2 [gm_advanced].
  call "gdi32.dll" "SetBkMode" with the printer canvas and 1 [transparent].
  call "gdi32.dll" "SetMapMode" with the printer canvas and 8 [mm_anisotropic].
  call "gdi32.dll" "GetDeviceCaps" with the printer canvas and 112 [physicaloffsetx] returning a pair's x.
  call "gdi32.dll" "GetDeviceCaps" with the printer canvas and 113 [physicaloffsety] returning the pair's y.
  negate the pair.
  call "gdi32.dll" "SetViewportOrgEx" with the printer canvas and the pair's x and the pair's y and nil.
  call "gdi32.dll" "GetDeviceCaps" with the printer canvas and 88 [logpixelsx] returning the pair's x.
  call "gdi32.dll" "GetDeviceCaps" with the printer canvas and 90 [logpixelsy] returning the pair's y.
  call "gdi32.dll" "SetViewportExtEx" with the printer canvas and the pair's x and the pair's y and nil.
  call "gdi32.dll" "SetWindowOrgEx" with the printer canvas and 0 and 0 and nil.
  call "gdi32.dll" "SetWindowExtEx" with the printer canvas and the tpi and the tpi and nil.
  call "gdi32.dll" "StartPage" with the printer canvas.
  put the printer canvas into the current canvas.
  call "gdi32.dll" "GetDeviceCaps" with the printer canvas and 88 [logpixelsx] returning a number.
  put the tpp into the saved tpp.
  put the tpi divided by the number into the tpp.

to begin a sheet given a box (pdf style):
  begin the sheet given the box and "" (pdf style).

to begin a sheet given a box and a title string:
  begin the sheet given the box and the title (pdf style).

to begin a sheet given a box and a title string (pdf style - start the current page):
  add the pdf state's current page given "page".
  append the pdf state's current page's number then " 0 obj" to the pdf state's current page.
  append "<<" to the pdf state's current page.  
  append "/Type /Page" to the pdf state's current page.
  append "/Parent " then the pdf state's parent's number then " 0 R" to the pdf state's current page.
  put the box's width minus the tpp times 72 / the tpi into a width.
  put the box's height minus the tpp times 72 / the tpi into a height.
  append "/MediaBox [0 0 " then the width then " " then the height then "]" to the pdf state's current page.
  put the box's height minus the tpp into the pdf state's current height.
  add the pdf state's current contents given "contents".
  append "/Contents " then the pdf state's current contents' number then " 0 R" to the pdf state's current page.
  append "0.05 0 0 0.05 1 1 cm" to the pdf state's current contents. \ set matrix to scale 72/1440
  append "13 w 0 J 0 j 0 i" to the pdf state's current contents. \ penwidth, linecap, linejoin, flatness \ 15 w on penwidth comes out to wide

to begin a sheet given a box and a title string (pdf style):
  set the pdf state's page flag.
  put the clear color into the pdf state's current border.
  put the clear color into the pdf state's current fill.
  begin the sheet given the box and the title (pdf style - start the current page).
  if the title is blank, exit.
  create a pdf outline entry given the title and the pdf state's current height and the pdf state's current page's number.
  append the pdf outline entry to the pdf state's outline entries.

to begin a sheet given a title string:
  begin a portrait sheet given the title.

the bell byte is a byte equal to 7.

the big-a byte is a byte equal to 65.

the big-a-acute byte is a byte equal to 193.

the big-a-circumflex byte is a byte equal to 194.

the big-a-diaeresis byte is a byte equal to 196.

the big-a-grave byte is a byte equal to 192.

the big-a-ring byte is a byte equal to 197.

the big-a-tilde byte is a byte equal to 195.

the big-ae byte is a byte equal to 198.

the big-b byte is a byte equal to 66.

the big-c byte is a byte equal to 67.

the big-c-cedilla byte is a byte equal to 199.

the big-d byte is a byte equal to 68.

the big-e byte is a byte equal to 69.

the big-e-acute byte is a byte equal to 201.

the big-e-circumflex byte is a byte equal to 202.

the big-e-diaeresis byte is a byte equal to 203.

the big-e-grave byte is a byte equal to 200.

a big-endian unsigned wyrd is a record with 2 bytes.

the big-eth byte is a byte equal to 208.

the big-f byte is a byte equal to 70.

the big-g byte is a byte equal to 71.

the big-h byte is a byte equal to 72.

the big-i byte is a byte equal to 73.

the big-i-acute byte is a byte equal to 205.

the big-i-circumflex byte is a byte equal to 206.

the big-i-diaeresis byte is a byte equal to 207.

the big-i-grave byte is a byte equal to 204.

the big-j byte is a byte equal to 74.

the big-k byte is a byte equal to 75.

the big-l byte is a byte equal to 76.

the big-m byte is a byte equal to 77.

the big-n byte is a byte equal to 78.

the big-n-tilde byte is a byte equal to 209.

the big-o byte is a byte equal to 79.

the big-o-acute byte is a byte equal to 211.

the big-o-circumflex byte is a byte equal to 212.

the big-o-diaeresis byte is a byte equal to 214.

the big-o-grave byte is a byte equal to 210.

the big-o-stroke byte is a byte equal to 216.

the big-o-tilde byte is a byte equal to 213.

the big-oe byte is a byte equal to 140.

the big-p byte is a byte equal to 80.

the big-q byte is a byte equal to 81.

the big-r byte is a byte equal to 82.

the big-s byte is a byte equal to 83.

the big-s-caron byte is a byte equal to 138.

the big-t byte is a byte equal to 84.

the big-thorn byte is a byte equal to 222.

the big-u byte is a byte equal to 85.

the big-u-acute byte is a byte equal to 218.

the big-u-circumflex byte is a byte equal to 219.

the big-u-diaeresis byte is a byte equal to 220.

the big-u-grave byte is a byte equal to 217.

the big-v byte is a byte equal to 86.

the big-w byte is a byte equal to 87.

the big-x byte is a byte equal to 88.

the big-y byte is a byte equal to 89.

the big-y-acute byte is a byte equal to 221.

the big-y-diaeresis byte is a byte equal to 159.

the big-z byte is a byte equal to 90.

the big-z-caron byte is a byte equal to 142.

a billion is 1000 millions.

a bit is a unit.

a bitmapdata is a record with
  a width,
  a height,
  a number called stride,
  a number called pixelformat,
  a pointer called scan0,
  a number called reserved.

to bitwise and a byte with another byte:
  intel $8B850C000000. \ mov eax,[ebp+12] \ the other byte
  intel $8A00. \ mov al,[eax]
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the byte
  intel $2003. \ and [ebx],al

to bitwise and a byte with a number:
  intel $8B850C000000. \ mov eax,[ebp+12] \ the number
  intel $8B00. \ mov eax,[eax]
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the byte
  intel $2003. \ and [ebx],al

to bitwise and a number with another number:
  intel $8B850C000000. \ mov eax,[ebp+12] \ the other number
  intel $8B00. \ mov eax,[eax]
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the number
  intel $2103. \ and [ebx],eax

to bitwise or a byte with another byte:
  intel $8B850C000000. \ mov eax,[ebp+12] \ the other byte
  intel $8A00. \ mov al,[eax]
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the byte
  intel $0803. \ or [ebx],al

to bitwise or a byte with a number:
  intel $8B850C000000. \ mov eax,[ebp+12] \ the number
  intel $8B00. \ mov eax,[eax]
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the byte
  intel $0803. \ or [ebx],al

to bitwise or a number with another number:
  intel $8B850C000000. \ mov eax,[ebp+12] \ the other number
  intel $8B00. \ mov eax,[eax]
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the number
  intel $0903. \ or [ebx],eax

to bitwise xor a byte with another byte:
  intel $8B850C000000. \ mov eax,[ebp+12] \ the other byte
  intel $8A00. \ mov al,[eax]
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the byte
  intel $3003. \ xor [ebx],al

to bitwise xor a byte with a number:
  intel $8B850C000000. \ mov eax,[ebp+12] \ the number
  intel $8B00. \ mov eax,[eax]
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the byte
  intel $3003. \ or [ebx],al

to bitwise xor a number with another number:
  intel $8B850C000000. \ mov eax,[ebp+12] \ the other number
  intel $8B00. \ mov eax,[eax]
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the number
  intel $3103. \ xor [ebx],eax

the black color is a color.

the blue color is a color.

a box has
  a left coord, a top coord, a right coord, a bottom coord,
  a left-top spot at the left, and a right-bottom spot at the right.

the broken-bar byte is a byte equal to 166.

a bucket count is a count.

a bucket is a pointer to a bucket record.

a bucket record has some refers.

a bucket# is a number.

a buffer is a string.

the bullet byte is a byte equal to 149.

to bump a rider:
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the rider
  intel $FF8314000000. \ inc [ebx+20] \ the rider's token's last
  intel $FF8308000000. \ inc [ebx+8] \ the rider's source's first

to bump a rider by a number:
  add the number to the rider's token's last.
  add the number to the rider's source's first.  

to buzz: 
  call "kernel32.dll" "Beep" with 220 and 200.

a byte count is a count.

a byte pointer is a pointer to a byte.

a byte# is a number.

the c-key is a key equal to 67.

the cancel byte is a byte equal to 24.

a canvas is an hdc.

to capitalize any selected rows in a text:
  if the text is nil, exit.
  loop.
  get a row from the text's rows.
  if the row is nil, exit.
  if the row of the text is not selected, repeat.
  if the row is blank, repeat.
  capitalize the row's string.
  repeat.

to capitalize a string:
  slap a substring on the string.
  loop.
  if the substring is blank, exit.
  if the substring's first's target is not noise, break.
  add 1 to the substring's first.
  repeat.
  uppercase the substring's first's target.

to capitalize a text:
  if the text is nil, exit.
  loop.
  get a row from the text's rows.
  if the row is nil, break.
  capitalize the row's string.
  repeat.
  wrap the text.

the caps key is a key equal to 20.

the caret byte is a byte equal to 94.

a caret is a position.

the cedilla byte is a byte equal to 184.

the cent-sign byte is a byte equal to 162.

to center a box in another box:
  center the box in the other box (horizontally).
  center the box in the other box (vertically).

to center a box in another box (horizontally):
  put the other box's center's x minus the box's center's x into a number.
  round the number to the nearest multiple of the tpp.
  move the box given the number and 0.

to center a box in another box (vertically):
  put the other box's center's y minus the box's center's y into a number.
  round the number to the nearest multiple of the tpp.
  move the box given 0 and the number.

to center a box on a spot:
  get a difference between the spot and the box's center.
  round the difference to the nearest multiple of the tpp.
  move the box given the difference.

to center an ellipse in a box:
  center the ellipse in the box (horizontally).
  center the ellipse in the box (vertically).

to center an ellipse in a box (horizontally):
  center the ellipse's box in the box (horizontally).

to center an ellipse in a box (vertically):
  center the ellipse's box in the box (vertically).

to center an ellipse on a spot:
  center the ellipse's box on the spot.

to center a line in a box:
  center the line in the box (horizontally).
  center the line in the box (vertically).

to center a line in a box (horizontally):
  put the box's center's x minus the line's center's x into a number.
  round the number to the nearest multiple of the tpp.
  move the line given the number and 0.

to center a line in a box (vertically):
  put the box's center's y minus the line's center's y into a number.
  round the number to the nearest multiple of the tpp.
  move the line given 0 and the number.

to center a line on a spot:
  get a difference between the spot and the line's center.
  round the difference to the nearest multiple of the tpp.
  move the line given the difference.

to center a picture in a box:
  if the picture is nil, exit.
  center the picture in the box (horizontally).
  center the picture in the box (vertically).

to center a picture in a box (horizontally):
  if the picture is nil, exit.
  put the box's center's x minus the picture's box's center's x into a number.
  round the number to the nearest multiple of the tpp.
  move the picture given the number and 0.

to center a picture in a box (vertically):
  if the picture is nil, exit.
  put the box's center's y minus the picture's box's center's y into a number.
  round the number to the nearest multiple of the tpp.
  move the picture given 0 and the number.

to center a picture on a spot:
  if the picture is nil, exit.
  get a difference between the spot and the picture's box's center.
  round the difference to the nearest multiple of the tpp.
  move the picture given the difference.

to center a polygon in a box:
  if the polygon is nil, exit.
  center the polygon in the box (horizontally).
  center the polygon in the box (vertically).

to center a polygon in a box (horizontally):
  if the polygon is nil, exit.
  put the box's center's x minus the polygon's box's center's x into a number.
  round the number to the nearest multiple of the tpp.
  move the polygon given the number and 0.

to center a polygon in a box (vertically):
  if the polygon is nil, exit.
  put the box's center's y minus the polygon's box's center's y into a number.
  round the number to the nearest multiple of the tpp.
  move the polygon given 0 and the number.

to center a polygon on a spot:
  if the polygon is nil, exit.
  get a difference between the spot and the polygon's box's center.
  round the difference to the nearest multiple of the tpp.
  move the polygon given the difference.

to center a spot in a box:
  center the spot in the box (horizontally).
  center the spot in the box (vertically).

to center a spot in a box (horizontally):
  put the box's center's x minus the spot's x into a number.
  round the number to the nearest multiple of the tpp.
  move the spot given the number and 0.

to center a spot in a box (vertically):
  put the box's center's y minus the spot's y into a number.
  round the number to the nearest multiple of the tpp.
  move the spot given 0 and the number.

to center a text in a box:
  if the text is nil, exit.
  center the text in the box (horizontally).
  center the text in the box (vertically).

to center a text in a box (horizontally):
  if the text is nil, exit.
  put the box's center's x minus the text's box's center's x into a number.
  round the number to the nearest multiple of the tpp.
  move the text given the number and 0.

to center a text in a box (vertically):
  if the text is nil, exit.
  put the box's center's y minus the text's box's center's y into a number.
  round the number to the nearest multiple of the tpp.
  move the text given 0 and the number.

to center a text on a spot:
  if the text is nil, exit.
  get a difference between the spot and the text's box's center.
  round the difference to the nearest multiple of the tpp.
  move the text given the difference.

to change a roundy box given a radius:
  put the radius into the roundy box's radius.

to change a text given a box:
  if the text is nil, exit.
  put the box into the text's box.
  wrap the text.

to change a text given a font height:
  if the text is nil, exit.
  subtract the text's margin from the text's x.
  put the text's origin divided by the text's grid into a pair.
  put the font height into the text's font's height.
  scale the text's font's height given the text's scale.
  put the pair times the text's grid into the text's origin.
  add the text's margin to the text's x.
  limit the origin of the text.
  wrap the text.

to change a text given a font name:
  if the text is nil, exit.
  put the font name into the text's font's name.
  wrap the text.

a character is a byte.

the circumflex byte is a byte equal to 136.

to clear a box:
  put 0 into the box's left.
  put 0 into the box's top.
  put 0 into the box's right.
  put 0 into the box's bottom.

to clear a byte:
  put the null byte into the byte.

to clear a color:
  put 0 and 0 and 0 into the color.

the clear color is a color.

to clear an ellipse:
  clear the ellipse's box.

to clear a flag:
  put no into the flag.

to clear a font:
  put "" and 0 into the font.

to clear an ip address:
  clear the ip address' number.
  clear the ip address' string.

the clear key is a key equal to 12.

to clear a line:
  clear the line's start.
  clear the line's end.

to clear a number:
  put 0 into the number.

to clear a pair:
  put 0 and 0 into the pair.

to clear a ratio:
  put 0 and 1 into the ratio.

to clear a rider:
  clear the rider's original.
  clear the rider's source.
  clear the rider's token.

to clear a selection:
  clear the selection's anchor.
  clear the selection's caret.

to clear a string:
  unassign the string's first.
  void the string's last.

to clear a substring:
  void the substring's first.
  void the substring's last.

to clear some things:
  void the things' first.
  void the things' last.

to clear a wyrd:
  put 0 into the wyrd.

to close a file:
  call "kernel32.dll" "CloseHandle" with the file.

a clsid is a uuid.

to cluck:
  play the cluck sound.

the cluck sound is a wave equal to $524946463A02000057415645666D74201200000001000100401F0000401F000001000800000066616374040000000702000064617461070200007F7F807F7F807F7F808080807F807F7F80817F81817E7E827E7D847C79877D5F6D99B2A25D608269A5979869667F7D8D738C7D8C5E7E878F767A75868D84797278829A7D7E857A73929271657492907D7E7D787E8B887C758388827E817F7C7B89897C7A7E84838183827E7A8488877D7E8181808484817C7F84838181807E7F8283807E8081808182807F7F81818081807F7F8081818080807F7F808180807F80808080807F8080807F8080808080807F7F7F7F7F8080807F7F7F7C7B8182817C7B7D7E8082807D7D7C7F8281807F7C7D808082807E7E7E7D7E807D7B7C7B7D7D7B7A7979797875727269797A490F4571FFF4FF0C001297FBF492525BB0F5B26A001C69BEE5BA76476F9EBD953C3757BAC9BB705C7F9AA883645D7897AA9B806977959588696976999B83766F828C907F7375828E91877B757D868B837A757C858D8880787B8187847B7A7D8788807B79808486817D7C7F8384817D7C7F8484817B7B7D83847F7C7B7E8182827D7C7C8082817D7C7D7F81807F7D7D7F82817F7B7B7E8081807E7D7D7F80807E7D7D7E80807E7D7D7E7F807F7D7D7E7F807F7E7D7E7E80807F7E7D7E80807F7E7E7E7F7F7E7E7E7F7F7F7F7E7E7F7F807F7F7E7E7E7F8080807E7E7E80807F7E7E7F8081807F7F7E7F7F80807F7E7F8081807F7E7E7E80808080807F807F7F7F7F7F7F7F80808080807F7F7F808080807F80808180807F80808100.

the colon byte is a byte equal to 58.

a color has a hue, a saturation, and a lightness.

a colorref is a number [like $00BBGGRR].

a column# is a number.

the comma byte is a byte equal to 44.

to compare a string to another string given a length and another length (equal only):
  intel $8BB508000000. \ mov esi,[ebp+8] \ the string
  intel $8B36. \ mov esi,[esi] \ the string's first
  intel $8BBD0C000000. \ mov edi,[ebp+12] \ the other string
  intel $8B3F. \ mov edi,[edi] \ the other string's first
  intel $8B8510000000. \ mov eax,[ebp+16] \ the string's length
  intel $8B00. \ mov eax,[eax]
  intel $8B9514000000. \ mov edx,[ebp+20] \ the other string's length
  intel $8B12. \ mov edx,[edx]
  intel $3BD0. \ cmp eax,edx \ if the length's differ, say no
  intel $0F8548000000. \ jne sayno
  intel $8BC8. \ mov ecx,eax \ put length into ecx
  \L3: \ loop:
  intel $85C9. \ test ecx,ecx
  intel $0F8449000000. \ jz say yes
  \ uppercase current byte in the string
  intel $8A1E. \ mov bl,[esi]
  intel $80FB61. \ cmp bl,'a'
  intel $0F820C000000. \ jb L4
  intel $80FB7A. \ cmp bl,'z'
  intel $0F8703000000. \ ja L4
  intel $80EB20. \ sub bl,$20
  \L4: \ uppercase current byte in the other string
  intel $8A3F. \ mov bh,[edi]
  intel $80FF61. \ cmp bh,'a'
  intel $0F820C000000. \ jb L5
  intel $80FF7A. \ cmp bh,'z'
  intel $0F8703000000. \ ja L5
  intel $80EF20. \ sub bh,$20
  \L5: \ compare the two uppercased bytes
  intel $3ADF. \ cmp bl,bh
  intel $0F8508000000. \ jne say no
  intel $46. \ inc esi
  intel $47. \ inc edi
  intel $49. \ dec ecx
  intel $E9BAFFFFFF. \ jmp L3
  \SAY NO:
  intel $C7C000000000. \ mov eax,0
  intel $E906000000. \ jmp end
  \SAY YES:
  intel $C7C001000000. \ mov eax,1

to compare a string to another string given a length and another length returning a number:
  intel $8BB508000000. \ mov esi,[ebp+8] \ the string
  intel $8B36. \ mov esi,[esi] \ the string's first
  intel $8BBD0C000000. \ mov edi,[ebp+12] \ the other string
  intel $8B3F. \ mov edi,[edi] \ the other string's first
  intel $8B8510000000. \ mov eax,[ebp+16] \ the string's length
  intel $8B00. \ mov eax,[eax]
  intel $8B9514000000. \ mov edx,[ebp+20] \ the other string's length
  intel $8B12. \ mov edx,[edx]
  \ get the minimum length
  intel $8BC8. \ mov ecx,eax
  intel $3BCA. \ cmp ecx,edx
  intel $0F8602000000. \ jbe L2
  intel $8BCA. \ mov ecx,edx
  \L3: \ loop:
  intel $85C9. \ test ecx,ecx
  intel $0F8444000000. \ jz L6
  \ uppercase current byte in the string
  intel $8A1E. \ mov bl,[esi]
  intel $80FB61. \ cmp bl,'a'
  intel $0F820C000000. \ jb L4
  intel $80FB7A. \ cmp bl,'z'
  intel $0F8703000000. \ ja L4
  intel $80EB20. \ sub bl,$20
  \L4: \ uppercase current byte in the other string
  intel $8A3F. \ mov bh,[edi]
  intel $80FF61. \ cmp bh,'a'
  intel $0F820C000000. \ jb L5
  intel $80FF7A. \ cmp bh,'z'
  intel $0F8703000000. \ ja L5
  intel $80EF20. \ sub bh,$20
  \L5: \ compare the two uppercased bytes
  intel $3ADF. \ cmp bl,bh
  intel $0F8508000000. \ jne L5a
  intel $46. \ inc esi
  intel $47. \ inc edi
  intel $49. \ dec ecx
  intel $E9BAFFFFFF. \ jmp L3
  \L5a: \ load bytes into eax and edx for final compare
  intel $0FB6C3. \ movzx eax,bl
  intel $0FB6D7. \ movzx edx,bh
  \L6: \ subtract either the lengths or the last two bytes to set the eax to <0, =0, >0
  intel $2BC2. \ sub eax,edx
  intel $8B9D18000000. \ mov ebx,[ebp+24] \ the number
  intel $8903. \ mov [ebx],eax

to compatibly handle any message with a window a message number a w-param and an l-param:
  if the message is 006, handle any wm-activate with the w-param; put 0 into eax; exit.
  if the message is 258, handle any wm-char with the w-param and the l-param; put 0 into eax; exit.
  if the message is 001, handle any wm-create with the window; put 0 into eax; exit.
  if the message is 002, handle any wm-destroy; put 0 into eax; exit.
  if the message is 256, handle any wm-keydown with the w-param and the l-param; put 0 into eax; exit.
  if the message is 513, handle any wm-lbuttondown with the l-param; put 0 into eax; exit.
  if the message is 515, handle any wm-lbuttondblclk with the l-param; put 0 into eax; exit.
  if the message is 015, handle any wm-paint with the window; put 0 into eax; exit.
  if the message is 516, handle any wm-rbuttondown with the l-param; put 0 into eax; exit.
  if the message is 518, handle any wm-rbuttondblclk with the l-param; put 0 into eax; exit.
  if the message is 032, handle any wm-setcursor; put 1 into eax; exit.
  if the message is 260, handle any wm-syskeydown with the w-param and the l-param; put 0 into eax; exit.
  call "user32.dll" "DefWindowProcA" with the window and the message and the w-param and the l-param.

to compatibly wait for a process pointer:
  call "kernel32.dll" "WaitForSingleObject" with the process pointer's target and -1 [infinite].
  call "kernel32.dll" "CloseHandle" with the process pointer's target.
  put 0 into the process pointer's target.
  call "user32.dll" "GetForegroundWindow" returning a window.
  if the window is the main window, put 0 into eax; exit.
  call "user32.dll" "ShowWindow" with the main window and 6 [sw_minimize].
  call "user32.dll" "ShowWindow" with the main window and 9 [sw_restore].
  put 0 into eax. \ set return value of thread

a console is a thing with 
  a box,
  a border color,
  a fill color,
  a text,
  a grid,
  a reply string.

to convert an absolute position to a position given a text:
  if the text is nil, clear the position; exit.
  privatize the absolute position.
  loop.
  get a row from the text's rows.
  if the row is nil, clear the position; exit.
  put the row's row# into the position's row#.
  put the absolute position into the position's column#.
  subtract the row's string's length from the absolute position.
  if the absolute position is less than 1, exit.
  repeat.

to convert a box to a string:
  clear the string.
  append the box's left to the string.
  append " " to the string.
  append the box's top to the string.
  append " " to the string.
  append the box's right to the string.
  append " " to the string.
  append the box's bottom to the string.

to convert a byte to a nibble:
  put the byte into the nibble as a byte.
  uppercase the nibble.
  if the nibble is greater than the nine byte, subtract 7 from the nibble.
  subtract 48 from the nibble.

to convert a byte to a nibble string:
  split the byte into a nibble and another nibble.
  convert the nibble to the nibble string.
  convert the other nibble to another nibble string.
  append the other nibble string to the nibble string.

to convert a byte to a query byte:
  if the byte is between 48 and 57, put the byte into the query byte; exit. \ 0-9
  if the byte is between 65 and 90, put the byte into the query byte; exit. \ A-Z
  if the byte is between 97 and 122, put the byte into the query byte; exit. \ a-z
  if the byte is 32, put "+" into the query byte; exit. \ space
  convert the byte to a nibble string.
  put "%" then the nibble string into the query byte.

to convert a color to a colorref:
  if the color is clear, put 16777215 [$00FFFFFF] into the colorref; exit. \ clear pen becomes white
  privatize the color.
  scale the color's saturation given 240/1000.
  limit the color's saturation to 1 and 239.
  scale the color's lightness given 240/1000.
  limit the color's lightness to 1 and 239.
  scale the color's hue given 240/3600.
  limit the color's hue to 1 and 239.
  call "shlwapi.dll" "ColorHLSToRGB" with the color's hue and the color's lightness and the color's saturation returning the colorref.

to convert a color to a rgb:
  convert the color to a colorref.
  convert the colorref to the rgb. 

to convert a colorref to a color:
  call "shlwapi.dll" "ColorRGBToHLS" with the colorref and a wyrd's whereabouts and another wyrd's whereabouts and a third wyrd's whereabouts.
  put the wyrd into the color's hue.
  put the other wyrd into the color's  lightness.
  put the third wyrd into the color's saturation.
  scale the color's hue given 3600/240.
  limit the color's hue to 0 and 3600.
  scale the color's saturation given 1000/240.
  limit the color's saturation to 0 and 1000.
  scale the color's lightness given 1000/240.
  limit the color's lightness to 0 and 1000.

to convert a colorref to a rgb:
  privatize the colorref.
  shift the colorref right 0 bits.
  put the colorref into the rgb's red byte.
  shift the colorref right 8 bits.
  put the colorref into the rgb's green byte.
  shift the colorref right 8 bits.
  put the colorref into the rgb's blue byte.

to convert a flag to a hex string:
  reassign the hex string's first given the flag's magnitude.
  copy bytes from the flag's whereabouts to the hex string's first for the flag's magnitude.
  put the hex string's first plus the flag's magnitude minus 1 into the hex string's last.

to convert a flag to a string:
  if the flag is set, put "yes" into the string; exit.
  put "no" into the string.

to convert a font to an hfont:
  privatize the font.
  null terminate the font's name.
  call "gdi32.dll" "CreateFontA" with - the font's height times 3 divided by 4 and 0 and 0 and 0 and 0 and 0 and 0 and 0 
    and 1 [default_charset] and 0 and 0 and 5 [cleartype_quality] and 4 [truetype_fonttype] and the font's name's first returning the hfont.

to convert a font info to pdf em units:
  if the font info is nil, exit.
  convert the font info's internal leading to pdf em units given the font info's emsquare and the font info's font.
  convert the font info's ascent to pdf em units given the font info's emsquare and the font info's font.
  convert the font info's descent to pdf em units given the font info's emsquare and the font info's font.
  convert the font info's capheight to pdf em units given the font info's emsquare and the font info's font.
\  convert the font info's italicangle to pdf em units given the font info's emsquare and the font info's font.
  convert the font info's stemv to pdf em units given the font info's emsquare and the font info's font.
  convert the font info's font box's left to pdf em units given the font info's emsquare and the font info's font.
  convert the font info's font box's top to pdf em units given the font info's emsquare and the font info's font.
  convert the font info's font box's right to pdf em units given the font info's emsquare and the font info's font.
  convert the font info's font box's bottom to pdf em units given the font info's emsquare and the font info's font.
  swap the font info's font box's top with the font info's font box's bottom.
  convert the font info's font widths to pdf em units.

to convert some font widths to pdf em units:
  get an outlinetextmetric given the font widths' font.
  put the font widths' data into a number pointer.
  loop.
  if a counter is past the font widths' count, break.
  convert the number pointer's target to pdf em units given the outlinetextmetric's otmemsquare and the font widths' font.
  add a number's magnitude to the number pointer.
  repeat.

to convert a gpbitmap to a buffer (pdf style):
  clear the buffer.
  if the gpbitmap is nil, exit.
  lock the gpbitmap given a bitmapdata (24-bit rgb).
  put 1 into a row#.
  put 1 into a column#.
  loop.
  if the column# is greater than the bitmapdata's width, put 1 into the column#; add 1 to the row#.
  if the row# is greater than the bitmapdata's height, break.
  get a rgb pointer from the bitmapdata at the row# and the column#.
  append the rgb pointer's red byte to the buffer.
  append the rgb pointer's green byte to the buffer.
  append the rgb pointer's blue byte to the buffer.
  add 1 to the column#.
  repeat.
  unlock the gpbitmap given the bitmapdata.

to convert a hex string to a number:
  if the hex string's length is not the number's magnitude, clear the number; exit.
  copy bytes from the hex string's first to the number's whereabouts for the number's magnitude.

to convert a hex string to a ratio:
  if the hex string's length is not the ratio's magnitude, put 0 and 1 into the ratio; exit.
  copy bytes from the hex string's first to the ratio's whereabouts for the ratio's magnitude.

to convert an l-param to a key: \ assumes l-param from wm_char message
  put the l-param into the key.
  shift the key right 16 bits.
  bitwise and the key with 255.
  call "user32.dll" "MapVirtualKeyA" with the key and 1 returning the key.
  if the numlock key was not toggled, exit.
  if the key is the insert key, put the numpad-zero key into the key; exit.
  if the key is the delete key, put the numpad-period key into the key; exit.
  if the key is the home key, put the numpad-seven key into the key; exit.
  if the key is the end key, put the numpad-one key into the key; exit.
  if the key is the page-up key, put the numpad-nine key into the key; exit.
  if the key is the page-down key, put the numpad-three key into the key; exit.
  if the key is the left-arrow key, put the numpad-four key into the key; exit.
  if the key is the up-arrow key, put the numpad-eight key into the key; exit.
  if the key is the right-arrow key, put the numpad-six key into the key; exit.
  if the key is the down-arrow key, put the numpad-two key into the key; exit.
  if the key is the clear key, put the numpad-five key into the key; exit.

to convert an l-param to a spot:
  split the l-param into a wyrd and another wyrd.
  put the wyrd into the spot's y.
  put the other wyrd into the spot's x.
  multiply the spot by the tpp.

to convert a mixed to a ratio:
  put the mixed's ratio into the ratio.
  add the mixed's whole number times the ratio's denominator to the ratio's numerator.

to convert a nibble to a nibble string:
  privatize the nibble.
  if the nibble is greater than 9, add 7 to the nibble.
  add 48 to the nibble.
  put the nibble into the nibble string.

to convert a nibble string to a hex string:
  privatize the nibble string.
  clear the hex string.
  if the nibble string's length is odd, prepend the zero byte to the nibble string.
  slap a substring on the nibble string.
  loop.
  if the substring is blank, exit.
  convert the substring's first's target to a nibble.
  shift the nibble left 4 bits.
  add 1 to the substring's first.
  convert the substring's first's target to another nibble.
  bitwise or the nibble with the other nibble.
  append the nibble to the hex string.
  add 1 to the substring's first.
  repeat.

to convert a number to a hex string:
  reassign the hex string's first given the number's magnitude.
  copy bytes from the number's whereabouts to the hex string's first for the number's magnitude.
  put the hex string's first plus the number's magnitude minus 1 into the hex string's last.

to convert a number to a nibble string:
  split the number into a wyrd and another wyrd.
  convert the wyrd to the nibble string.
  convert the other wyrd to another nibble string.
  append the other nibble string to the nibble string.

to convert a number to pdf em units given an emsquare number and a font:
  multiply the number by the emsquare / the font's adjusted height.
  multiply the number by 1000 / the emsquare.

to convert a number to a string:
  clear the string.
  privatize the number.
  de-sign the number.
  loop.
  divide the number by 10 giving a quotient and a remainder.
  add 48 to the remainder.
  put the remainder into a byte.
  prepend the byte to the string.
  if the quotient is 0, break.
  put the quotient into the number.
  repeat.
  if the original number is less than 0, prepend the dash byte to the string.

to convert a pchar to a string:
  clear the string.
  if the pchar is nil, exit.
  privatize the pchar.
  loop.
  if the pchar's target is the null byte, exit.
  append the pchar's target to the string.
  add 1 to the pchar.
  repeat.

to convert a pointer and a length to a string:
  clear the string.
  if the pointer is nil, exit.
  if the length is 0, exit.
  reassign the string's first given the length.
  copy bytes from the pointer to the string's first for the length.
  put the string's first plus the length minus 1 into the string's last.

to convert a pointer to a hex string: employ convert a number to a hex string.

to convert a pointer to a nibble string: employ convert a number to a nibble string.

to convert a pointer to a string:
  convert the pointer to the string as a nibble string.

to convert a position to an absolute position given a text:
  if the text is nil, clear the absolute position; exit.
  put 0 into the absolute position.
  loop.
  get a row from the text's rows.
  if the row is nil, exit.
  if the row's row# is less than the position's row#, add the row's string's length to the absolute position; repeat.
  add the position's column# to the absolute position.

to convert a query string to a string:
  clear the string.
  if the query string is blank, exit.
  slap a substring on the query string.
  loop.
  if the substring is blank, exit.
  if the substring's first's target is the cross byte, append " " to the string; add 1 to the substring's first; repeat.
  if the substring's first's target is not the percent-sign byte, append the substring's first's target to the string; add 1 to the substring's first; repeat.
  if the substring's length is less than 3, exit.
  add 1 to the substring's first.
  convert the substring's first's target to a nibble.
  shift the nibble left 4 bits.
  add 1 to the substring's first.
  convert the substring's first's target to another nibble.
  bitwise or the nibble with the other nibble.
  add 1 to the substring's first.
  append the nibble to the string.
  repeat.

to convert a ratio to a hex string:
  reassign the hex string's first given the ratio's magnitude.
  copy bytes from the ratio's whereabouts to the hex string's first for the ratio's magnitude.
  put the hex string's first plus the ratio's magnitude minus 1 into the hex string's last.

to convert a ratio to a mixed:
  if the ratio's denominator is 0, put 0 into the mixed's whole number; put 0 into the mixed's ratio; exit.
  divide the ratio's numerator by the ratio's denominator giving the mixed's whole number and a remainder.
  put the remainder and the ratio's denominator into the mixed's ratio.

to convert a ratio to a string:
  clear the string.
  privatize the ratio.
  if the ratio is negative, put "-" into the string; de-sign the ratio.
  reduce the ratio.
  convert the ratio to a mixed.
  if the mixed is 0, append "0" to the string; exit.
  if the mixed's whole number is not 0, append the mixed's whole number to the string.
  if the mixed's ratio is 0, exit.
  if the string is not blank, append the dash byte to the string.
  append the mixed's numerator then "/" then the mixed's denominator to the string.

to convert a ratio to a string given a number: \ converts to a decimal representation with "the number" of places
  clear the string.
  if the number is less than 1, exit.
  put 10 into a value number.
  raise the value to the number.
  privatize the ratio.
  if the ratio is negative, set a flag; de-sign the ratio.
  multiply the value by the ratio.
  zero fill the value given the number and append it to the string.
  put the string's length minus the number plus 1 into a byte#.
  insert "." into the string before the byte#.
  if the string's first's target is the period byte, prepend "0" to the string.
  if the flag is set, prepend "-" to the string.

to convert some rows to a string:
  clear the string.
  loop.
  get a row from the rows.
  if the row is nil, exit.
  append the row's string to the string.
  if the string's last's target is the return byte, append the linefeed byte to the string; repeat.
  repeat.

to convert some rows to a string (no linefeed additions):
  clear the string.
  loop.
  get a row from the rows.
  if the row is nil, exit.
  append the row's string to the string.
  repeat.

to convert a string and an actual font info and an original font info into a buffer for pdf output:
  clear the buffer.
  put 0 into a current byte#.
  slap a substring on the first byte of the string.
  loop.
  if the substring's first is greater than the string's last, break.
  if the substring's last is the string's last, break.
  get a current width given the current byte# and the actual font info's font widths.
  get an original width given the substring's last's target and the original font info's font widths.
  put the original width minus the current width into an offset.
  if the offset is 0, add 1 to the substring's last; add 1 to the current byte#; repeat.
  convert the substring to a pdf string.
  append the pdf string then " " then the offset then " " to the buffer.
  put the substring's last plus 1 into the substring's last.
  put the substring's last into the substring's first.
  add 1 to the current byte#.
  repeat.
  if the substring's first is greater than the string's last, exit.
  convert the substring to another pdf string.
  append the other pdf string to the buffer.

to convert a string to a flag:
  if the string is "y", set the flag; exit.
  if the string is "yes", set the flag; exit.
  clear the flag.

to convert a string to a nibble string:
  clear the nibble string.
  slap a substring on the string.
  loop.
  if the substring is blank, exit.
  convert the substring's first's target to another nibble string.
  append the other nibble string to the nibble string.
  add 1 to the substring's first.
  repeat.

to convert a string to a number:
  put 0 into the number.
  slap a substring on the string.
  if the substring is blank, exit.
  if the substring's first's target is any sign, add 1 to the substring's first.
  loop.
  if the substring is blank, break.
  multiply the number by 10.
  put the substring's first's target into another number.
  subtract 48 from the other number.
  add the other number to the number.
  add 1 to the substring's first.
  repeat.
  if the string's first's target is the dash byte, negate the number.

to convert a string to a number between another number and a third number:
  convert the string to the number.
  limit the number to the other number and the third number.

to convert a string to a pdf string:
  put "(" into the pdf string.
  slap a substring on the string.
  subtract 1 from the substring's first.
  loop.
  add 1 to the substring's first.
  if the substring is blank, break.
  if the substring's first's target is the left-paren byte, append "\(" to the pdf string; repeat.
  if the substring's first's target is the right-paren byte, append "\)" to the pdf string; repeat.
  if the substring's first's target is the backslash byte, append "\\" to the pdf string; repeat.
  append the substring's first's target to the pdf string.
  repeat.
  append ")" to the pdf string.

to convert a string to a pointer: \ assumes pointer is in nibble format
  convert the string as a nibble string to a hex string.
  void the pointer.
  slap a substring on the hex string.
  put 24 into a shift count.
  loop.
  if the substring is blank, exit.
  if the shift count is less than 0, exit.
  put the substring's first's target into a number.
  shift the number left the shift count.
  bitwise or the pointer as a number with the number.
  add 1 to the substring's first.
  subtract 8 from the shift count.
  repeat.

to convert a string to a query string:
  clear the query string.
  slap a substring on the string.
  loop.
  if the substring is blank, break.
  convert the substring's first's target to a query byte.
  append the query byte to the query string.
  add 1 to the substring's first.
  repeat.

to convert a string to a ratio:
  clear the ratio.
  if the string is blank, exit.
  if the string is any integer, convert the string to the ratio's numerator; exit.
  slap a substring on the string.
  if the substring's first's target is any sign, add 1 to the substring's first.
  if the substring is blank, exit.
  split the substring into an integer substring and a ratio substring given the dash byte.
  if the integer substring is blank, put the substring into the ratio substring.
  split the ratio substring into a numerator substring and a denominator substring given the slash byte.
  convert the integer substring to a whole number.
  convert the numerator substring to a numerator number.
  convert the denominator substring to a denominator number.
  if the whole number is negative, exit.
  if the numerator number is negative, exit.
  if the denominator number is negative, exit.
  if the denominator number is 0, exit.
  if the whole number is not 0, add the denominator number times the whole number to the numerator number.
  put the numerator number into the ratio's numerator.
  put the denominator number into the ratio's denominator.
  if the string's first's target is the dash byte, negate the ratio.

to convert a string to some rows:
  slap a rider on the string.
  loop.
  move the rider (text file rules).
  if the rider's token is blank, break.
  create a row given the rider's token.
  append the row to the rows.
  if the row's string's last's target is the linefeed byte, put the return byte into the row's string's last's target. \ *dahn new to handle lines terminated by just linefeed
  repeat.
  renumber the rows.

to convert a string to a uuid:
  convert the string to a wide string and null terminate.
  call "ole32.dll" "CLSIDFromString" with the wide string's first and the uuid's whereabouts.

to convert a string to a wide string:
  clear the wide string.
  slap a substring on the string.
  loop.
  if the substring is blank, exit.
  append the substring's first's target to the wide string.
  append the null byte to the wide string.
  add 1 to the substring's first.
  repeat.

to convert a string to a wide string and null terminate:
  convert the string to the wide string.
  null terminate the wide string.

to convert a timer to a string:
  convert the timer's ticks to the string.

to convert a url to a url record:
  privatize the url.
  null terminate the url.
  put a urlcomponents' magnitude into the urlcomponents' dwstructsize.
  put 1 into the urlcomponents' dwschemelength.
  put 1 into the urlcomponents' dwhostnamelength.
  put 1 into the urlcomponents' dwurlpathlength.
  put 1 into the urlcomponents' dwextrainfolength.
  call "wininet.dll" "InternetCrackUrlA" with the url's first and 0 and 0 and the urlcomponents' whereabouts returning a number.
  convert the urlcomponents' lpszscheme and the urlcomponents' dwschemelength to the url record's scheme.
  convert the urlcomponents' lpszhostname and the urlcomponents' dwhostnamelength to the url record's host name.
  convert the urlcomponents' lpszurlpath and the urlcomponents' dwurlpathlength to the url record's path.
  convert the urlcomponents' lpszextrainfo and the urlcomponents' dwextrainfolength to the url record's extra.
  put the urlcomponents' nport into the url record's port number.

to convert a wyrd to a nibble string:
  split the wyrd into a byte and another byte.
  convert the byte to the nibble string.
  convert the other byte to another nibble string.
  append the other nibble string to the nibble string.

a coord is some twips.

to copy bytes from a pointer to another pointer for a byte count: \ copy handling overlap with 1 byte moves
  intel $8BB508000000. \ mov esi,[ebp+8] \ the pointer
  intel $8B36. \ mov esi,[esi]
  intel $8BBD0C000000. \ mov edi,[ebp+12] \ the other pointer
  intel $8B3F. \ mov edi,[edi]
  intel $8B8D10000000. \ mov ecx,[ebp+16] \ the number
  intel $8B09. \ mov ecx,[ecx]
  \ check for something to copy
  intel $81F900000000. \ cmp ecx,0
  intel $0F8E39000000. \ jle end
  \ check for no overlap
  intel $3BF7. \ cmp esi,edi
  intel $0F8D24000000. \ jge forward
  intel $8BC6. \ mov eax,esi
  intel $03C1. \ add eax,ecx
  intel $3BC7. \ cmp eax,edi
  intel $0F8E18000000. \ jle forward
  \ copy backward
  intel $03F1. \ add esi,ecx
  intel $4E. \ dec esi
  intel $03F9. \ add edi,ecx
  intel $4F. \ dec esi
  \ backward
  intel $8A16. \ mov dl,[esi]
  intel $8817. \ mov [edi],dl
  intel $4E. \ dec esi
  intel $4F. \ dec edi
  intel $49. \ dec ecx
  intel $0F85F3FFFFFF. \ jnz backward
  intel $E90D000000. \ jmp end
  \ forward: copy forward
  intel $8A16. \ mov dl,[esi]
  intel $8817. \ mov [edi],dl
  intel $46. \ inc esi
  intel $47. \ inc edi
  intel $49. \ dec ecx
  intel $0F85F3FFFFFF. \ jnz forward

to copy an event into another event:
  if the event is nil, void the other event; exit.
  create the other event.
  put the event's kind into the other event's kind.
  put the event's shift flag into the other event's shift flag.
  put the event's ctrl flag into the other event's ctrl flag.
  put the event's alt flag into the other event's alt flag.
  put the event's spot into the other event's spot.
  put the event's key into the other event's key.
  put the event's byte into the other event's byte.

to copy a gpbitmap into another gpbitmap:
  if the gpbitmap is nil, void the other gpbitmap; exit.
  call "gdiplus.dll" "GdipCloneBitmapAreaI" with 0 and 0 and the gpbitmap's width and the gpbitmap's height and 0 [pixelformatdontcare] and
    the gpbitmap and the other gpbitmap's whereabouts.

to copy the guts of a text into another text:
  if the text is nil, exit.
  if the other text is nil, exit.
  put the text's box into the other text's box.
  put the text's origin into the other text's origin.
  put the text's pen into the other text's pen.
  put the text's font into the other text's font.
  put the text's alignment into the other text's alignment.
  copy the text's rows into the other text's rows.
  put the text's margin into the other text's margin.
  put the text's scale into the other text's scale.
  put the text's wrap flag into the other text's wrap flag.
  put the text's horizontal scroll flag into the other text's horizontal scroll flag.
  put the text's vertical scroll flag into the other text's vertical scroll flag.
  put the text's selection into the other text's selection.
  put the text's modified flag into the other text's modified flag.
  put the text's last operation into the other text's last operation.
  \ don't copy undos and redos

a copy is a number.

to copy a picture into another picture:
  if the picture is nil, void the other picture; exit.
  allocate memory for the other picture.
  put the picture's box into the other picture's box.
  put the picture's uncropped box into the other picture's uncropped box.
  put the picture's grayscale flag into the other picture's grayscale flag.
  put the picture's mirror flag into the other picture's mirror flag.
  put the picture's rotate angle into the other picture's rotate angle.
  put the picture's data into the other picture's data.
  copy the picture's gpbitmap into the other picture's gpbitmap.

to copy a polygon into another polygon:
  if the polygon is nil, void the other polygon; exit.
  allocate memory for the other polygon.
  copy the polygon's vertices into the other polygon's vertices.

to copy a row into another row:
  if the row is nil, void the other row; exit.
  allocate memory for the other row.
  put the row's row# into the other row's row#.
  put the row's string into the other row's string.

to copy some rows into some other rows:
  destroy the other rows.
  loop.
  get a row from the rows.
  if the row is nil, exit.
  copy the row into another row.
  append the other row to the other rows.
  repeat.

to copy a text into another text:
  if the text is nil, void the other text; exit.
  allocate memory for the other text.
  copy the guts of the text into the other text.

to copy a vertex into another vertex:
  if the vertex is nil, void the other vertex; exit.
  allocate memory for the other vertex.
  put the vertex's x into the other vertex's x.
  put the vertex's y into the other vertex's y.

to copy some vertices into some other vertices:
  destroy the other vertices.
  loop.
  get a vertex from the vertices.
  if the vertex is nil, exit.
  copy the vertex into another vertex.
  append the other vertex to the other vertices.
  repeat.

the copyright byte is a byte equal to 169.

a count is a number.

a counter is an number.

to create the connect handle of a winhttp request using  a url record:
  if the winhttp request is nil, exit.
  convert the url record's host name into a wide string called wide host name and null terminate.
  call "winhttp.dll" "WinHttpConnect"
    with the winhttp request's session
    and the wide host name's first
    and the url record's port
    and 0
    returning the winhttp request's connection.
  if the winhttp request's connection is 0, put "Could not connect." into the i/o error; exit.

to create a console:
  allocate memory for the console.
  put the lighter gray color into the console's border.
  put the lighter gray color into the console's fill.
  put the screen's box into the console's box.
  put the screen's box into a box.
  subtract the default font's height from the box's bottom.
  put the box's height divided by the default font's height times the default font's height into a height.
  put the box's top plus the height into the box's bottom.
  center the box in the screen's box (vertically).
  put the box's top into the box's left.
  subtract the box's top from the box's right.
  create the console's text.
  put the box into the console's text's box.
  set the console's text's wrap flag.
  clear the console's text's horizontal scroll flag.
  set the console's text's vertical scroll flag.
  put the default font's height into the console's grid.
  multiply the console's grid's x by 2.

to create a crypt session with a passphrase string: \ sets i/o error if failure
  clear the i/o error.
  allocate memory for the crypt session.
  \ acquire context
  call "advapi32.dll" "CryptAcquireContextA" with the crypt session's hcryptprov's whereabouts and 0 and "Microsoft Enhanced Cryptographic Provider v1.0"'s first 
    and 1 [prov_rsa_full] and -268435456 [crypt_verifycontext] returning a result number.
  if the result is 0, put "Could not acquire context." into the i/o error; destroy the crypt session; exit.
  \ create hash
  call "advapi32.dll" "CryptCreateHash" with the crypt session's hcryptprov and 32771 [calg_md5] and 0 and 0 
    and the crypt session's hcrypthash's whereabouts returning the result number.
  if the result is 0, put "Could not create hash." into the i/o error; destroy the crypt session; exit.
  \ hash passphrase
  call "advapi32.dll" "CryptHashData" with the crypt session's hcrypthash and the passphrase's first and the passphrase's length and 0 returning the result number.
  if the result is 0, put "Could not hash password." into the i/o error; destroy the crypt session; exit.
  \ derive session key
  call "advapi32.dll" "CryptDeriveKey" with the crypt session's hcryptprov and 26625 [calg_rc4 stream cipher] and the crypt session's hcrypthash 
    and 8388608 [128 bit] and the crypt session's hcryptkey's whereabouts returning the result number.
  if the result is 0, put "Could not derive session key." into the i/o error; destroy the crypt session; exit.

to create a dyad:
  allocate memory for the dyad.

to create an event:
  allocate memory for the event.

to create a font info given a font:
  create the font info given the font (basic data).
  create the font info's font widths given the font.

to create a font info given a font (basic data):
  allocate memory for the font info.
  put the font into the font info's font.
  get an outlinetextmetric given the font.
  put 32 into the font info's flags. \ could be updated with a more information
  put the outlinetextmetric's otmtextmetrics' tminternalleading into the font info's internal leading.
  put the outlinetextmetric's otmemsquare into the font info's emsquare.
  put the outlinetextmetric's otmtextmetrics' tmascent into the font info's ascent.
  put - the outlinetextmetric's otmtextmetrics' tmdescent into the font info's descent.
  put the outlinetextmetric's otmscapemheight into the font info's capheight.
  put the outlinetextmetric's otmitalicangle into the font info's italicangle.
  put 0 into the font info's stemv. \ don't know where to get this from
  put the outlinetextmetric's otmrcfontbox into the font info's font box.

to create a font info given a font and a string: \ creates widths based on characters in string
  create the font info given the font (basic data).
  create the font info's font widths given the font and the string.

to create some font widths given a font:
  allocate memory for the font widths.
  put the font into the font widths' font.
  put 256 into the font widths' count.
  assign the font widths' data given the font widths' count times a number's magnitude.
  create the hfont of the memory canvas given the font.
  assign an original abc pointer given 256 times an abc's magnitude.
  call "gdi32.dll" "GetCharABCWidthsA" with the memory canvas and 0 and 255 and the original abc pointer.
  destroy the hfont of the memory canvas.
  put the original abc pointer into an abc pointer.
  put the font widths' data into a number pointer.
  loop.
  if a counter is past 256, break.
  put the abc pointer's abca into the number pointer's target.
  add the abc pointer's abcb to the number pointer's target.
  add the abc pointer's abcc to the number pointer's target.
  add the abc's magnitude to the abc pointer.
  add the number's magnitude to the number pointer.
  repeat.
  unassign the original abc pointer.

to create some font widths given a font and a string:
  allocate memory for the font widths.
  put the font into the font widths' font.
  put the string's length into the font widths' count.
  if the string is blank, exit.
  put a gcpresults' magnitude into the gcpresults' lstructsize.
  put the string's length into the gcpresults' nglyphs.
  assign the gcpresults' lpdx given the string's length times a number's magnitude.
  create the hfont of the memory canvas given the font.
  call "gdi32.dll" "GetCharacterPlacementA" with the memory canvas and the string's first
    and the string's length and 0 and the gcpresults' whereabouts and 0.
  destroy the hfont of the memory canvas.
  put the gcpresults' lpdx into the font widths' data.

to create a gpbitmap given a buffer:
  clear the i/o error.
  call "kernel32.dll" "GlobalAlloc" with 2 [gmem_moveable] and the buffer's length returning a handle.
  call "kernel32.dll" "GlobalLock" with the handle returning a pointer.
  copy bytes from the buffer's first to the pointer for the buffer's length.
  call "kernel32.dll" "GlobalUnlock" with the handle.
  call "ole32.dll" "CreateStreamOnHGlobal" with the handle and 1 [true] and an istream's whereabouts.
  call "gdiplus.dll" "GdipCreateBitmapFromStream" with the istream and the gpbitmap's whereabouts returning a number.
  if the number is not 0, put "I don't know how to process this kind of picture." into the i/o error; void the gpbitmap.
  call the istream's vtable's release with the istream.

to create a gpimageattributes (grayscale):
  call "gdiplus.dll" "GdipCreateImageAttributes" with the gpimageattributes' whereabouts.
  call "gdiplus.dll" "GdipSetImageAttributesColorMatrix" with the gpimageattributes and 0 [coloradjusttypedefault] and 1 
    and the grayscale color matrix's first and 0 and 0 [colormatrixflagsdefault].

to create the hbrush of a canvas given a color:
  convert the color to a colorref.
  if the color is clear, put the null hbrush into an hbrush. 
  if the color is not clear, call "gdi32.dll" "CreateSolidBrush" with the colorref returning the hbrush.
  call "gdi32.dll" "SelectObject" with the canvas and the hbrush.

to create the hfont of a canvas given a font:
  convert the font to an hfont.
  call "gdi32.dll" "SelectObject" with the canvas and the hfont.

to create the hpen of a canvas given a color:
  convert the color to a colorref.
  if the color is clear, put the null hpen into an hpen.
  put the tpp into a number. \ one pixel on screen always
  if the canvas is the printer canvas, put 1/96 inch into the number.
  if the color is not clear, call "gdi32.dll" "CreatePen" with 0 [ps_solid] and the number and the colorref returning the hpen. 
  call "gdi32.dll" "SelectObject" with the canvas and the hpen.

to create an hrgn given a box:
  privatize the box.
  add the tpp to the box's right-bottom.
  call "gdi32.dll" "BeginPath" with the current canvas.
  call "gdi32.dll" "Rectangle" with the current canvas and the box's left and the box's top and the box's right and the box's bottom.
  call "gdi32.dll" "EndPath" with the current canvas.
  call "gdi32.dll" "PathToRegion" with the current canvas returning the hrgn.

to create an hrgn given an ellipse:
  put the ellipse's box into a box.
  call "gdi32.dll" "BeginPath" with the current canvas.
  call "gdi32.dll" "Ellipse" with the current canvas and the box's left and the box's top and the box's right and the box's bottom.
  call "gdi32.dll" "EndPath" with the current canvas.
  call "gdi32.dll" "PathToRegion" with the current canvas returning the hrgn.

to create an hrgn given a polygon:
  if the polygon is nil, put 0 into the hrgn; exit.
  create a vertex array given the polygon's vertices.
  call "gdi32.dll" "LPtoDP" with the current canvas and the vertex array's spot pointer and the vertex array's count.
  call "gdi32.dll" "CreatePolygonRgn" with the vertex array's spot pointer and the vertex array's count and 2 [winding] returning the hrgn.
  destroy the vertex array.

to create an hrgn given a roundy box:
  if the roundy box's radius is 0, create the hrgn given the roundy box as a box; exit.
  put the roundy box into a box.
  put the roundy box's radius times 2 into a diameter number.
  call "gdi32.dll" "BeginPath" with the current canvas.
  call "gdi32.dll" "RoundRect" with the current canvas and the box's left and the box's top and the box's right and the box's bottom and the diameter and the diameter.
  call "gdi32.dll" "EndPath" with the current canvas.
  call "gdi32.dll" "PathToRegion" with the current canvas returning the hrgn.

to create an index given a bucket count:
  allocate memory for the index.
  put the bucket count into the index's bucket count.
  put a bucket record's magnitude into a width.
  put the index's bucket count times the width into a number.
  assign the index's first bucket given the number.
  put the index's first bucket plus the number minus the width into the index's last bucket.

to create the lexicon:
  allocate memory for the lexicon.
  create the lexicon's index given 4027.

to create the open handle of a winhttp request:
  if the winhttp request is nil, exit.
  convert the module's name to a wide string called wide module name and null terminate.
  call "winhttp.dll" "WinHttpOpen"
    with the wide module name's first
    and 0 [winhttp_access_type_default_proxy] 
    and 0 [winhttp_no_proxy_name] 
    and 0 [winhttp_no_proxy_bypass] 
    and 0 
    returning the winhttp request's session.
  if the winhttp request's session is 0, put "Could not open connection." into the i/o error; exit.

to create a path in the file system:
  if the path is directory-format, create the path in the file system (directory); exit.
  if the path is file-format, create the path in the file system (file); exit.

to create a path in the file system (directory):
  privatize the path.
  remove any trailing backslash from the path.
  null terminate the path.
  call "kernel32.dll" "CreateDirectoryA" with the path's first and 0 returning a number.
  clear the i/o error.
  if the number is not 0, exit.
  put "Error creating directory '" then the path then "'." into the i/o error.

to create a path in the file system (file):
  privatize the path.
  null terminate the path.
  call "kernel32.dll" "CreateFileA" with the path's first and 1073741824 [generic_write] and 0 and 0 and 1 [create_new] and 128 [file_attribute_normal] and 0 returning a handle.
  call "kernel32.dll" "CloseHandle" with the handle.
  clear the i/o error.
  if the handle is not -1 [invalid_handle_value], exit.
  put "Error creating file '" then the path then "'." into the i/o error.

to create a pdf object given a kind:
  allocate memory for the pdf object.
  put the kind into the pdf object's kind.

to create a pdf outline entry given a title string and a page height and a destination number:
  allocate memory for the pdf outline entry.
  put the title string into the pdf outline entry's title.
  put the page height into the pdf outline entry's page height.
  put the destination into the pdf outline entry's destination.

to create a picture:
  allocate memory for the picture.

to create a picture given a buffer:
  create a gpbitmap given the buffer.
  if the gpbitmap is nil, void the picture; exit.
  allocate memory for the picture.
  put the buffer into the picture's data.
  put the gpbitmap into the picture's gpbitmap.
  adjust the picture (extract boxes from gpbitmap).

to create a picture given a gpbitmap:
  if the gpbitmap is nil, void the picture; exit.
  allocate memory for the picture.
  put the gpbitmap into the picture's gpbitmap.
  adjust the picture (extract boxes from gpbitmap).

to create a picture given a url:
  read the url into a buffer.
  create the picture given the buffer.

to create a polygon:
  allocate memory for the polygon.

to create a refer:
  allocate memory for the refer.

to create the request handle of a winhttp request using a url record:
  if the winhttp request is nil, exit.
  convert the url record's path into a wide string called wide path and null terminate.
  convert "POST" to a wide string called wide post string and null terminate.
  if the url record's scheme is "https", put 8388608 [winhttp_flag_secure] into a secure number.
  call "winhttp.dll" "WinHttpOpenRequest"
    with the winhttp request's connection
    and the wide post string's first
    and the wide path's first
    and 0 [L"HTTP/1.1"] 
    and 0 [winhttp_no_referer]
    and 0 [winhttp_default_accept_types]
    and the secure number
    returning the winhttp request's request.
  if the winhttp request's request is 0, put "Could not open request." into the i/o error; exit.

to create a row given a byte:
  allocate memory for the row.
  put the byte into the row's string.

to create a row given a string:
  allocate memory for the row.
  put the string into the row's string.

to create a socket given a host string and a port number: \ this guy creates and connects, sets i/o error if there is a problem
  clear the i/o error.
  \ get sockaddr
  get a sockaddr given the host.
  if the i/o error is not blank, exit.
  put 2 [af_inet] into the sockaddr's sin_family.
  put the port into the sockaddr's sin_port.
  \ create socket  
  call "ws2_32.dll" "socket" with 2 [af_inet] and 1 [sock_stream] and 0 [ipproto_ip] returning the socket.
  if the socket is -1, put "Could not create socket." into the i/o error; exit.
  \ connect socket
  call "ws2_32.dll" "connect" with the socket and the sockaddr's whereabouts and the sockaddr's magnitude returning a result number.
  if the result is not 0, put "Could not connect to socket." into the i/o error; exit.
  \ set send timeout 30 seconds
  call "ws2_32.dll" "setsockopt" with the socket and 65535 and 4101 [so_sndtimo] and 30 seconds' whereabouts and 4 returning the result number.
  if the result is not 0, put "Could not set receive timeout." into the i/o error; exit.
  \ set receive timeout 30 seconds
  call "ws2_32.dll" "setsockopt" with the socket and 65535 and 4102 [so_rcvtimeo] and 30 seconds' whereabouts and 4 returning the result number.
  if the result is not 0, put "Could not set receive timeout." into the i/o error; exit.

to create a string thing given a string:
  allocate memory for the string thing.
  put the string into the string thing's string.

to create a text:
  allocate memory for the text.
  put the black color into the text's pen.
  put the default font into the text's font.
  put "left" into the text's alignment.
  put 1/1 into the text's scale.
  guarantee one row in the text.
  reset the origin of the text.
  reset the caret of the text.
  deselect the text.

to create a vertex:
  allocate memory for the vertex.

to create a vertex array given a count:
  privatize the count.
  allocate memory for the vertex array.
  put the count into the vertex array's count.
  multiply the count by a spot's magnitude.
  assign the vertex array's spot pointer given the count.

to create a vertex array given some vertices:
  create the vertex array given the vertices' count.
  put the vertex array's spot pointer into a spot pointer.
  loop.
  get a vertex from the vertices.
  if the vertex is nil, exit.
  put the vertex's spot into the spot pointer's target.
  add the vertex's spot's magnitude to the spot pointer.
  repeat.

to create a vertex given a spot:
  allocate memory for the vertex.
  put the spot into the vertex's spot.

to create a vertex given an x coord and a y coord:
  allocate memory for the vertex.
  put the x into the vertex's x.
  put the y into the vertex's y.

to create a winhttp request for posting to a url:
  allocate memory for the winhttp request.
  convert the url to a url record.
  create the open handle of the winhttp request.
  if the i/o error is not blank, destroy the winhttp request; exit.
  create the connect handle of the winhttp request using the url record.
  if the i/o error is not blank, destroy the winhttp request; exit.
  create the request handle of the winhttp request using the url record.
  if the i/o error is not blank, destroy the winhttp request; exit.

the crlf string is a string equal to $0D0A.

the cross byte is a byte equal to 43.

a crypt session is a thing with
  an hcryptprov pointer,
  an hcrypthash pointer,
  an hcryptkey pointer.

the ctrl key is a key equal to 17.

the currency-sign byte is a byte equal to 164.

the current canvas is a canvas.

the current event is an event.

a cursor is a handle.

the cyan color is a color.

the d-key is a key equal to 68.

the dagger byte is a byte equal to 134.

the dark blue color is a color.

the dark cyan color is a color.

the dark gray color is a color.

the dark green color is a color.

the dark lime color is a color.

the dark magenta color is a color.

the dark orange color is a color.

the dark purple color is a color.

the dark red color is a color.

the dark sky color is a color.

the dark teal color is a color.

the dark violet color is a color.

the dark yellow color is a color.

the darker blue color is a color.

the darker cyan color is a color.

the darker gray color is a color.

the darker green color is a color.

the darker lime color is a color.

the darker magenta color is a color.

the darker orange color is a color.

the darker purple color is a color.

the darker red color is a color.

the darker sky color is a color.

the darker teal color is a color.

the darker violet color is a color.

the darker yellow color is a color.

the darkest blue color is a color.

the darkest cyan color is a color.

the darkest gray color is a color.

the darkest green color is a color.

the darkest lime color is a color.

the darkest magenta color is a color.

the darkest orange color is a color.

the darkest purple color is a color.

the darkest red color is a color.

the darkest sky color is a color.

the darkest teal color is a color.

the darkest violet color is a color.

the darkest yellow color is a color.

the dash byte is a byte equal to 45.

the dash key is a key equal to 189.

the data-link-escape byte is a byte equal to 16.

a date/time has
  a year number,
  a month number,
  a week day number,
  a day number,
  an hour number,
  a minute number,
  a second number,
  a millisecond number.

to de-sign a number:
  if the number is the smallest number, put the largest number into the number; exit.
  if the number is less than 0, negate the number.

to de-sign a pair:
  de-sign the pair's x.
  de-sign the pair's y.

to de-sign a ratio:
  de-sign the ratio's numerator.
  de-sign the ratio's denominator.

to de-sign a string:
  if the string is blank, exit.
  if the string's first's target is any sign, remove the first byte from the string.

to debug a box:
  clear a string.
  append "left=" to the string.
  append the box's left to the string.
  append ", top=" to the string.
  append the box's top to the string.
  append ", right=" to the string.
  append the box's right to the string.
  append ", bottom=" to the string.
  append the box's bottom to the string.
  debug the string.

to debug a byte:
  put the byte into a number.
  convert the number to a string.
  debug the string.

to debug a color:
  clear a string.
  append "hue=" to the string.
  append the color's hue to the string.
  append ", saturation=" to the string.
  append the color's saturation to the string.
  append ", lightness=" to the string.
  append the color's lightness to the string.
  debug the string.

to debug a flag:
  convert the flag to a string.
  debug the string.

to debug a font:
  clear a string.
  append "name='" to the string then "'".
  append the font's name to the string.
  append ", height=" to the string.
  append the font's height to the string.
  debug the string.

to debug a line:
  clear a string.
  append "start=" to the string.
  append the line's start's x to the string.
  append "," to the string.
  append the line's start's y to the string.
  append " end=" to the string.
  append the line's end's x to the string.
  append "," to the string.
  append the line's end's y to the string.
  debug the string.

to debug a number:
  convert the number to a string.
  debug the string.

to debug a number and another number:
  debug the number then ", " then the other number.

to debug a pair:
  clear a string.
  append "x=" to the string.
  append the pair's x to the string.
  append ", y=" to the string.
  append the pair's y to the string.
  debug the string.

to debug a pointer:
  convert the pointer to a nibble string.
  debug "$" then the nibble string.

to debug a ratio:
  clear a string.
  append "numerator=" to the string.
  append the ratio's numerator to the string.
  append ", denominator=" to the string.
  append the ratio's denominator to the string.
  debug the string.

to debug a rgb:
  clear a string.
  append "red=" to the string.
  put the rgb's red byte into a number.
  append the number to the string.
  append ", green=" to the string.
  put the rgb's green byte into the number.
  append the number to the string.
  append ", blue=" to the string.
  put the rgb's blue byte into the number.
  append the number to the string.
  debug the string.

to debug a string:
  privatize the string.
  null terminate the string.
  call "user32.dll" "MessageBoxA" with 0 and the string's first and "debug"'s first and 0.

to debug a string (quoted):
  privatize the string.
  prepend the double-quote byte to the string.
  append the double-quote byte to the string.
  debug the string.

to debug a wyrd:
  put the wyrd into a number.
  convert the number to a string.
  debug the string.

to decide if a box is another box:
  if the box's left is not the other box's left, say no.
  if the box's top is not the other box's top, say no.
  if the box's right is not the other box's right, say no.
  if the box's bottom is not the other box's bottom, say no.
  say yes.

to decide if a box is inside another box:
  if the box's left is less than the other box's left, say no.
  if the box's top is less than the other box's top, say no.
  if the box's right is greater than the other box's right, say no.
  if the box's bottom is greater than the other box's bottom, say no.
  say yes.

to decide if a box is touching another box:
  if the other box's right is less than the box's left, say no.
  if the other box's bottom is less than the box's top, say no.
  if the other box's left is greater than the box's right, say no.
  if the other box's top is greater than the box's bottom, say no.
  say yes.

to decide if a byte is alphanumeric:
  if the byte is any letter, say yes.
  if the byte is any digit, say yes.
  say no.

to decide if a byte is another byte:
  intel $C7C001000000. \ mov eax,1 \ assume true
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the byte
  intel $8A1B. \ mov bl,[ebx]
  intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the other byte
  intel $3A19. \ cmp bl,[ecx]
  intel $0F8406000000. \ je over the next 1 statement
  intel $C7C000000000. \ mov eax,0 \ now it's false

to decide if a byte is another byte or a third byte:
  if the byte is the other byte, say yes.
  if the byte is the third byte, say yes.
  say no.

to decide if a byte is any consonant:
  if the byte is in "bcdfghjklmnpqrstvwxyz", say yes.
  say no.

to decide if a byte is any digit:
  if the byte is less than the zero byte, say no.
  if the byte is greater than the nine byte, say no.
  say yes.

to decide if a byte is any letter:
  if the byte is between the big-a byte and the big-z byte, say yes.
  if the byte is between the little-a byte and the little-z byte, say yes.
  if the byte is 131 or 138, say yes. 
  if the byte is 140 or 142, say yes. 
  if the byte is 154 or 156, say yes. 
  if the byte is between 158 and 159, say yes.
  if the byte is between 192 and 214, say yes.
  if the byte is between 216 and 246, say yes.
  if the byte is between 248 and 255, say yes.
  say no.

to decide if a byte is any numeric starter:
  if the byte is any digit, say yes.
  if the byte is any sign, say yes.
  say no.

to decide if a byte is any sign:
  if the byte is the dash byte, say yes.
  if the byte is the cross byte, say yes.
  say no.

to decide if a byte is any valid drive:
  put the byte into a path.
  append ":\" to the path.
  get a drive kind for the path.
  if the drive kind is "", say no.
  say yes.

to decide if a byte is any vowel:
  if the byte is in "aeiou", say yes.
\  if the byte is "y", say sometimes. \ ha ha ha
  say no.

to decide if a byte is between another byte and a third byte:
  if the byte is less than the other byte, say no.
  if the byte is greater than the third byte, say no.
  say yes.

to decide if a byte is between a number and another number:
  if the byte is less than the number, say no.
  if the byte is greater than the other number, say no.
  say yes.

to decide if a byte is greater than another byte:
  intel $C7C001000000. \ mov eax,1 \ assume true
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the byte
  intel $8A1B. \ mov bl,[ebx]
  intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the other byte
  intel $3A19. \ cmp bl,[ecx]
  intel $0F8706000000. \ ja over the next 1 statement
  intel $C7C000000000. \ mov eax,0 \ now it's false

to decide if a byte is greater than a number:
  intel $C7C001000000. \ mov eax,1 \ assume true
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the byte
  intel $0FB61B. \ movzx ebx,byte ptr [ebx]
  intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the number
  intel $3B19. \ cmp ebx,[ecx]
  intel $0F8F06000000. \ jg over the next 1 statement
  intel $C7C000000000. \ mov eax,0 \ now it's false

to decide if a byte is greater than or equal to another byte:
  intel $C7C001000000. \ mov eax,1 \ assume true
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the byte
  intel $8A1B. \ mov bl,[ebx]
  intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the other byte
  intel $3A19. \ cmp bl,[ecx]
  intel $0F8306000000. \ ja over the next 1 statement
  intel $C7C000000000. \ mov eax,0 \ now it's false

to decide if a byte is in a string:
  privatize the byte.
  lowercase the byte.
  slap a substring on the string.
  loop.
  if the substring is blank, say no.
  put the substring's first's target into another byte.
  lowercase the other byte.
  if the other byte is the byte, say yes.
  add 1 to the substring's first.
  repeat.

to decide if a byte is less than another byte:
  intel $C7C001000000. \ mov eax,1 \ assume true
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the byte
  intel $8A1B. \ mov bl,[ebx]
  intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the other byte
  intel $3A19. \ cmp bl,[ecx]
  intel $0F8206000000. \ jb over the next 1 statement
  intel $C7C000000000. \ mov eax,0 \ now it's false

to decide if a byte is less than a number:
  intel $C7C001000000. \ mov eax,1 \ assume true
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the byte
  intel $0FB61B. \ movzx ebx,byte ptr [ebx]
  intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the number
  intel $3B19. \ cmp ebx,[ecx]
  intel $0F8C06000000. \ jl over the next 1 statement
  intel $C7C000000000. \ mov eax,0 \ now it's false

to decide if a byte is less than or equal to another byte:
  intel $C7C001000000. \ mov eax,1 \ assume true
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the byte
  intel $8A1B. \ mov bl,[ebx]
  intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the other byte
  intel $3A19. \ cmp bl,[ecx]
  intel $0F8606000000. \ jbe over the next 1 statement
  intel $C7C000000000. \ mov eax,0 \ now it's false

to decide if a byte is like another byte: \ used internally for word wrap
   if the byte is whitespace, set a flag.
   if the other byte is whitespace, set another flag.
   if the flag is the other flag, say yes.
   say no.

to decide if a byte is noise:
  if the byte is less than or equal to the space byte, say yes.
  if the byte is the delete byte, say yes.
  if the byte is the non-breaking-space byte, say yes.
  if the byte is 129, say yes.
  if the byte is 141, say  yes.
  if the byte is 143, say yes.
  if the byte is 144, say yes.
  if the byte is 157, say yes.
  say no.

to decide if a byte is a number:
  intel $C7C001000000. \ mov eax,1 \ assume true
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the byte
  intel $0FB61B. \ movzx ebx,byte ptr [ebx]
  intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the number
  intel $3B19. \ cmp ebx,[ecx]
  intel $0F8406000000. \ je over the next 1 statement
  intel $C7C000000000. \ mov eax,0 \ now it's false

to decide if a byte is a number or another number:
  if the byte is the number, say yes.
  if the byte is the other number, say yes.
  say no.

to decide if a byte is printable:
  if the byte is less than the space byte, say no.
  if the byte is the delete byte, say no.
  if the byte is 129, say no.
  if the byte is 141, say no.
  if the byte is 143, say no.
  if the byte is 144, say no.
  if the byte is 157, say no.
  say yes.

to decide if a byte is a string:
  if the string's length is not 1, say no.
  privatize the byte.
  lowercase the byte.
  put the string's first's target into another byte.
  lowercase the other byte.
  if the byte is the other byte, say yes.
  say no.

to decide if a byte is symbolic:
  if the byte is between the exclamation byte and the slash byte, say yes.
  if the byte is between the colon byte and the at-sign byte, say yes.
  if the byte is between the left-bracket byte and the accent byte, say yes.
  if the byte is between the left-brace byte and the tilde byte, say yes.
  if the byte is 128, say yes.
  if the byte is 130, say yes.
  if the byte is between 132 and 137, say yes.
  if the byte is 139, say yes.
  if the byte is between 145 and 153, say yes.
  if the byte is 155, say yes.
  if the byte is between 161 and 180, say yes.
  if the byte is between 183 and 191, say yes.
  if the byte is 215, say yes.
  if the byte is 247, say yes.
  say no.

to decide if a byte is whitespace:
  if the byte is the space byte, say yes.
  if the byte is the tab byte, say yes.
  if the byte is the return byte, say yes.
  if the byte is the linefeed byte, say yes.
  say no.

to decide if the caret of a text is at the beginning:
  if the text is nil, say no.
  if the text's caret row# is not 1, say no.
  if the text's caret column# is not 1, say no.
  say yes.

to decide if the caret of a text is at the end:
  if the text is nil, say no.
  if the text's caret row# is not the text's rows' count, say no.
  get a row given the text's caret row# and the text.
  if the text's caret column# is not the row's string's length, say no.
  say yes.

to decide if the caret of a text is on the first line:
  if the text is nil, say no.
  if the text's caret row# is not 1, say no.
  say yes.

to decide if the caret of a text is on the last line:
  if the text is nil, say  no.
  if the text's rows are empty, say no.
  if the text's caret row# is not the text's last row's row#, say no.
  say yes.

to decide if a color and another color are clear:
  if the color is not clear, say no.
  if the other color is not clear, say no.
  say yes.

to decide if a color is another color:
  if the color's hue is not the other color's hue, say no.
  if the color's saturation is not the other color's saturation, say no.
  if the color's lightness is not the other color's lightness, say no.
  say yes.

to decide if a color is clear:
  if the color's hue is less than 0, say yes.
  say no.

to decide if a color is dark:
  if the color's lightness is between 250 and 374, say yes.
  say no.

to decide if a color is light:
  if the color's lightness is between 625 and 749, say yes.
  say no.

to decide if a color is normal:
  if the color's lightness is between 375 and 624, say yes.
  say no.

to decide if a color is very dark:
  if the color's lightness is between 125 and 249, say yes.
  say no.

to decide if a color is very light:
  if the color's lightness is between 750 and 874, say yes.
  say no.

to decide if a color is very very dark:
  if the color's lightness is less than or equal to 124, say yes.
  say no.

to decide if a color is very very light:
  if the color's lightness is greater than or equal to 875, say yes.
  say no.

to decide if a counter is past a number:
  add 1 to the counter.
  if the counter is greater than the number, say yes.
  say no.

to decide if a difference is within a grid:
  privatize the difference.
  de-sign the difference.
  if the difference's x is greater than or equal to the grid's x, say no.
  if the difference's y is greater than or equal to the grid's y, say no.
  say yes.

to decide if an event is modified:
  if the event's ctrl flag is set, say yes.
  if the event's alt flag is set, say yes.
  say no.

to decide if a finger is past the end of a string:
  if the finger is nil, say yes.
  if the finger is greater than the string's last, say yes.
  say no.

to decide if a flag is another flag: employ a number is another number.

to decide if a flag is set:
  if the flag is yes, say yes.
  say no.

to decide if an index is empty:
\  if the index is nil, say yes. \ to make compiler faster
\  loop.
  get a bucket given the index.
  if the bucket is nil, say yes.
  if the bucket's refers are not empty, say no.
  repeat.

to decide if an item is found:
  if the item's kind is not blank, say yes.
  say no.

to decide if a key is any digit key:
  if the key is between 48 and 57, say yes.
  say no.

to decide if a key is any letter key:
  if the key is between 65 and 90, say yes.
  say no.

to decide if a key is any modifier key:
  if the key is the alt key, say yes.
  if the key is the ctrl key, say yes.
  if the key is the shift key ,say yes.
  say no.

to decide if a key is any pad key:
  if the key is between 96 and 111, say yes.
  say no.

to decide if a key is any printable key:
  if the key is the space key, say yes.
  if the key is any digit key, say yes.
  if the key is any letter key, say yes.
  if the key is any pad key, say yes.
  if the key is any symbol key, say yes.
  say no.

to decide if a key is any symbol key:
  if the key is between 186 and 192, say yes.
  if the key is between 219 and 222, say yes.
  say no.

to decide if a key is any wm-char key:
  if the key is not any printable key , say no.
  if the alt key was down, say no.
  if the ctrl key was down, say no.
  say yes.

to decide if a key is down:
  call "user32.dll" "GetAsyncKeyState" with the key returning a wyrd.
  put the wyrd into a number.
  if the number is less than 0, say yes.
  say no.

to decide if a key is up:
  if the key is down, say no.
  say yes.

to decide if a key was down:
  call "user32.dll" "GetKeyState" with the key returning a wyrd.
  put the wyrd into a number.
  if the number is less than 0, say yes.
  say no.

to decide if a key was toggled:
  call "user32.dll" "GetKeyState" with the key returning a wyrd.
  put the wyrd into a number.
  bitwise and the number with 1.
  if the number is 1, say yes.
  say no.

to decide if a key was up:
  if the key was down, say no.
  say yes.

to decide if a key with an l-param is any repeated escape or modifier key:
  put the l-param into a number.
  bitwise and the number with 1073741824 [$40000000].
  if the number is 0, say no.
  if the key is the escape key, say yes.
  if the key is any modifier key, say yes.
  say no.

to decide if a mixed is a number:
  convert the mixed to a ratio.
  if the ratio is the number, say yes.
  say no.

to decide if the mouse has been dragged from a spot given a grid:
  if the mouse's left button is up, say no.
  put the mouse's spot into another spot.
  get a difference between the other spot and the spot.
  if the difference is within the grid, repeat.
  say yes.

to decide if a number is another number:
  intel $C7C001000000. \ mov eax,1 \ assume true
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the number
  intel $8B1B. \ mov ebx,[ebx]
  intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the other number
  intel $3B19. \ cmp ebx,[ecx]
  intel $0F8406000000. \ je over the next 1 statement
  intel $C7C000000000. \ mov eax,0 \ now it's false

to decide if a number is another number and a string is another string:
  if the number is not the other number, say no.
  if the string is not the other string, say no.
  say yes.

to decide if a number is between another number and a third number:
  if the number is less than the other number, say no.
  if the number is greater than the third number, say no.
  say yes.

to decide if a number is even:
  if the number is odd, say no.
  say yes.

to decide if a number is evenly divisible by another number:
  privatize the number.
  divide the number by the other number giving a quotient and a remainder.
  if the remainder is 0, say yes.
  say no.

to decide if a number is greater than another number:
  intel $C7C001000000. \ mov eax,1 \ assume true
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the number
  intel $8B1B. \ mov ebx,[ebx]
  intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the other number
  intel $3B19. \ cmp ebx,[ecx]
  intel $0F8F06000000. \ jg over the next 1 statement
  intel $C7C000000000. \ mov eax,0 \ now it's false

to decide if a number is greater than or equal to another number:
  intel $C7C001000000. \ mov eax,1 \ assume true
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the number
  intel $8B1B. \ mov ebx,[ebx]
  intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the other number
  intel $3B19. \ cmp ebx,[ecx]
  intel $0F8D06000000. \ jge over the next 1 statement
  intel $C7C000000000. \ mov eax,0 \ now it's false

to decide if a number is less than another number:
  intel $C7C001000000. \ mov eax,1 \ assume true
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the number
  intel $8B1B. \ mov ebx,[ebx]
  intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the other number
  intel $3B19. \ cmp ebx,[ecx]
  intel $0F8C06000000. \ jl over the next 1 statement
  intel $C7C000000000. \ mov eax,0 \ now it's false

to decide if a number is less than or equal to another number:
  intel $C7C001000000. \ mov eax,1 \ assume true
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the number
  intel $8B1B. \ mov ebx,[ebx]
  intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the other number
  intel $3B19. \ cmp ebx,[ecx]
  intel $0F8E06000000. \ jle over the next 1 statement
  intel $C7C000000000. \ mov eax,0 \ now it's false

to decide if a number is negative:
  if the number is less than 0, say yes.
  say no.

to decide if a number is odd:
  privatize the number.
  bitwise and the number with 1.
  if the number is 0, say no.
  say yes.

to decide if a pair is another pair:
  if the pair's x is not the other pair's x, say no.
  if the pair's y is not the other pair's y, say no.
  say yes.

to decide if a pair is a number:
  if the pair's x is not the number, say no.
  if the pair's y is not the number, say no.
  say yes.

to decide if a pair is a number and another number:
  if the pair's x is not the number, say no.
  if the pair's y is not the other number, say no.
  say yes.

to decide if a path is directory-format:
  if the path is blank, say no.
  if the path's last's target is the backslash byte, say yes.
  say no.

to decide if a path is drive-format:
  if the path starts with "\\", say yes.
  if the path's length is not 3, say no.
  if the path ends with ":\", say yes.
  say no.

to decide if a path is empty in the file system:
  if the path is not in the file system, say yes.
  get a count of items in the path in the file system.
  if the count is 0, say yes.
  say no.

to decide if a path is file-format:
  if the path is blank, say no.
  if the path's last's target is the colon byte, say no.
  if the path's last's target is the backslash byte, say no.
  say yes.

to decide if a path is in the file system:
  privatize the path.
  null terminate the path.
  call "kernel32.dll" "GetFileAttributesA" with the path's first returning a number.
  if the number is less than 0, say no.
  say yes.

to decide if a path is read-only:
  privatize the path.
  null terminate the path.
  call "kernel32.dll" "GetFileAttributesA" with the path's first returning a number.
  bitwise and the number with 1 [file_attribute_readonly].
  if the number is not 0, say yes.
  say no.

to decide if a pointer is another pointer: employ a number is another number.

to decide if a pointer is greater than another pointer: employ a number is greater than another number.

to decide if a pointer is greater than or equal to another pointer: employ a number is greater than or equal to another number.

to decide if a pointer is less than another pointer: employ a number is less than another number.

to decide if a pointer is less than or equal to another pointer: employ a number is less than or equal to another number.

to decide if a pointer is a number: employ a number is another number.

to decide if a polygon is closed:
  if the polygon is nil, say no.
  if the polygon's vertices' count is less than 3, say no.
  if the polygon's first vertex's spot is the polygon's last vertex's spot, say yes.
  say no.

to decide if a ratio is another ratio:
  privatize the ratio.
  privatize the other ratio.
  normalize the ratio and the other ratio.
  if the ratio's numerator is the other ratio's numerator, say yes.
  say no.

to decide if a ratio is greater than another ratio:
  privatize the ratio.
  privatize the other ratio.
  normalize the ratio and the other ratio.
  if the ratio's numerator is greater than the other ratio's numerator, say yes.
  say no.

to decide if a ratio is greater than or equal to another ratio:
  privatize the ratio.
  privatize the other ratio.
  normalize the ratio and the other ratio.
  if the ratio's numerator is greater than or equal to the other ratio's numerator, say yes.
  say no.

to decide if a ratio is less than another ratio:
  privatize the ratio.
  privatize the other ratio.
  normalize the ratio and the other ratio.
  if the ratio's numerator is less than the other ratio's numerator, say yes.
  say no.

to decide if a ratio is less than or equal to another ratio:
  privatize the ratio.
  privatize the other ratio.
  normalize the ratio and the other ratio.
  if the ratio's numerator is less than or equal to the other ratio's numerator, say yes.
  say no.

to decide if a ratio is negative:
  if the ratio's numerator is less than 0, reverse a flag.
  if the ratio's denominator is less than 0, reverse the flag.
  say the flag.

to decide if a ratio is a number:
  if the ratio is the number / 1, say yes.
  say no.

to decide if a row is blank:
  if the row is nil, say yes.
  slap a substring on the row's string.
  loop.
  if the substring is blank, say yes.
  if the substring's first's target is not noise, say no.
  add 1 to the substring's first.
  repeat.

to decide if a row of a text is selected:
  if the text is nil, say no.
  if the row is nil, say no.
  if nothing is selected in the text, say no.
  put the text's normalized selection into a selection.
  if the row's row# is less than the selection's anchor row#, say no.
  if the row's row# is greater than the selection's caret row#, say no.
  if the row's row# is not the selection's caret row#, say yes.
  if the selection's caret column# is 1, say no.
  say yes.

to decide if a row of a text is visible:
  if the text is nil, say no.
  if the row is nil, say  no.
  get a box given the row and the text.
  put the text's box into another box.
  adjust the other box given 0 and the tpp and 0 and - the tpp.
  if the box is touching the other box, say yes.
  say no.

to decide if a selection is another selection:
  if the selection's anchor is not the other selection's anchor, say no.
  if the selection's caret is not the other selection's caret, say no.
  say yes.

to decide if something is selected in a text:
  if the text's anchor is the text's caret, say no.
  say yes.

to decide if a spot is in a box:
  if the spot's x is less than the box's left, say no.
  if the spot's y is less than the box's top, say no.
  if the spot's x is greater than the box's right, say no.
  if the spot's y is greater than the box's bottom, say no.
  say yes.

to decide if a spot is in an ellipse:
  create an hrgn given the ellipse.
  privatize the spot.
  divide the spot by the tpp.
  call "gdi32.dll" "PtInRegion" with the hrgn and the spot's x and the spot's y returning a number.
  destroy the hrgn.
  if the number is 0, say no.
  say yes.

to decide if a spot is in a picture:
  if the picture is nil, say no.
  if the spot is in the picture's box, say yes.
  say no.

to decide if a spot is in a polygon:
  if the polygon is nil, say no.
  create a vertex array given the polygon's vertices.
  call "gdi32.dll" "CreatePolygonRgn" with the vertex array's spot pointer and the vertex array's count and 2 [winding] returning an hrgn.
  call "gdi32.dll" "PtInRegion" with the hrgn and the spot's x and the spot's y returning a number.
  call "gdi32.dll" "DeleteObject" with the hrgn.
  destroy the vertex array.
  if the number is 0, say no.
  say yes.

to decide if a spot is in some polygons:
  get a polygon from the polygons.
  if the polygon is nil, say no.
  if the spot is in the polygon, say yes.
  repeat.

to decide if a spot is in a roundy box:
  privatize the roundy box.
  add the tpp to the roundy box's right-bottom.
  put the roundy box's radius times 2 into a diameter number.
  call "gdi32.dll" "CreateRoundRectRgn" with the roundy box's left and the roundy box's top and the roundy box's right and the roundy box's bottom 
    and the diameter and the diameter returning an hrgn.
  call "gdi32.dll" "PtInRegion" with the hrgn and the spot's x and the spot's y returning a number.
  call "gdi32.dll" "DeleteObject" with the hrgn.
  if the number is 0, say no.
  say yes.

to decide if a spot is in a text:
  if the text is nil, say no.
  if the spot is in the text's box, say yes.
  say no.

to decide if a spot is on a box:
  put the box into another box.
  put 2 times the tpp into a number.
  outdent the other box given the number.
  if the spot is not in the other box, say no.
  put the box into a third box.
  put 3 times the tpp into another number.
  indent the third box given the other number.
  if the spot is in the third box, say no.
  say yes.

to decide if a spot is on an ellipse:
  put the ellipse into another ellipse.
  put 2 times the tpp into a number.
  outdent the other ellipse's box given the number.
  if the spot is not in the other ellipse, say no.
  put the ellipse into a third ellipse.
  put 3 times the tpp into another number.
  indent the third ellipse's box given the other number.
  if the spot is in the third ellipse, say no.
  say yes.

to decide if a spot is on a line:
  privatize the line.
  put 3 times the tpp into a number.
  loop.
  get a distance between the spot and the line's center (chessboard).
  if the distance is less than or equal to the number, say yes.
  get the distance between the line's start and the line's end (chessboard).
  if the distance is less than or equal to the tpp, say no.
  split the line into the line and another line.
  get the distance between the spot and the line's center (chessboard).
  get another distance between the spot and the other line's center (chessboard).
  if the distance is greater than the other distance, put the other line into the line.
  repeat.

to decide if a spot is on a picture:
  if the picture is nil, say no.
  if the spot is on the picture's box, say yes.
  say no.

to decide if a spot is on a polygon:
  if the polygon is nil, say no.
  loop.
  get a vertex from the polygon's vertices.
  if the vertex is nil, say no.
  if the vertex's next is nil, say no.
  put the vertex's spot and the vertex's next's spot into a line.
  if the spot is on the line, say yes.
  repeat.

to decide if a spot is on a roundy box:
  put the roundy box into another roundy box.
  put 2 times the tpp into a number.
  outdent the other roundy box given the number.
  if the spot is not in the other roundy box, say no.
  put the roundy box into a third roundy box.
  put 3 times the tpp into another number.
  indent the third roundy box given the other number.
  if the spot is in the third roundy box, say no.
  say yes.

to decide if a spot is within a grid of another spot:
  get a difference between the other spot and the spot.
  if the difference is within the grid, say yes.
  say no.

to decide if a string does end with another string: employ a string ends with another string.

to decide if a string does start with another string: employ a string starts with another string.

to decide if a string does start with a byte: employ a string starts with a byte.

to decide if a string ends with another string:
  if the other string's length is greater than the string's length, say no.
  slap a substring on the string.
  put the substring's last minus the other string's length plus 1 into the substring's first.
  if the substring is the other string, say yes.
  say no.

to decide if a string is another string:
  compare the string to the other string given the string's length and the other string's length (equal only).

to decide if a string is another string or a third string:
  if the string is the other string, say yes.
  if the string is the third string, say yes.
  say no.

to decide if a string is any integer:
  slap a substring on the string.
  if the substring is blank, say no.
  if the substring's first's target is any sign, add 1 to the substring's first.
  if the substring is blank, say no.
  loop.
  if the substring's first's target is not any digit, say no.
  add 1 to the substring's first.
  if the substring is blank, say yes.
  repeat.

to decide if a string is any integer literal:
  slap a substring on the string.
  if the substring is blank, say no.
  if the substring's first's target is any sign, add 1 to the substring's first.
  if the substring is blank, say no.
  loop.
  if the substring's first's target is not any digit, say no.
  add 1 to the substring's first.
  if the substring is blank, say yes.
  repeat.

to decide if a string is any mixed literal:
  slap a substring on the string.
  if the substring is blank, say no.
  if the substring's first's target is not any numeric starter, say no.
  if the substring's first's target is any sign, add 1 to the substring's first.
  split the substring into an integer substring and a ratio substring given the dash byte.
  if the integer substring is not any integer literal, say no.
  if the ratio substring is not any ratio literal, say no.
  say yes.

to decide if a string is any numeric literal:
  if the string is blank, say no.
  if the string's first's target is not any numeric starter, say no.
  if the string is any integer literal, say yes.
  if the string is any ratio literal, say yes.
  if the string is any mixed literal, say yes.
  say no.

to decide if a string is any ratio literal:
  slap a substring on the string.
  if the substring is blank, say no.
  if the substring's first's target is not any numeric starter, say no.
  if the substring's first's target is any sign, add 1 to the substring's first.
  split the substring into a numerator substring and a denominator substring given the slash byte.
  if the numerator substring is not any integer literal, say no.
  if the denominator substring is not any integer literal, say no.
  say yes.

to decide if a string is any sign:
  if the string's length is not 1, say no.
  if the string's first's target is any sign, say yes.
  say no.

to decide if a string is any word:
  if the string's length is less than 2, say no.
  slap a substring on the string.
  subtract 1 from the substring's first.
  loop.
  add 1 to the substring's first.
  if the substring is blank, say yes.
  if the substring's first's target is any letter, repeat.
  if the substring's first's target is the single-quote byte, repeat.
  say no.

to decide if a string is blank:
  \ assume true
  intel $B801000000. \ mov eax,1
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the string
  \ if first is 0, exit
  intel $833B00. \ cmp [ebx],0
  intel $0F8410000000. \ je end
  \ if last is less than first, exit
  intel $8B5304. \ mov edx,[ebx+4] \ last pointer
  intel $3B13. \ cmp edx,[ebx]
  intel $0F8C05000000. \ jl end
  \ SAY NO:
  intel $B800000000. \ mov eax,0
  \ END:

to decide if a string is a byte:
  if the string's length is not 1, say no.
  if the string's first's target is the byte, say yes.
  say no.

to decide if a string is dos-compatible:
  if the string is blank, say no.
  if the string's first's target is the period byte, say no.
  slap a substring on the string.
  loop.
  if the substring is blank, say yes.
  if the substring's first's target is the slash byte, say no.
  if the substring's first's target is the backslash byte, say no.
  if the substring's first's target is the colon byte, say no.
  if the substring's first's target is the asterisk byte, say no.
  if the substring's first's target is the question-mark byte, say no.
  if the substring's first's target is the double-quote byte, say no.
  if the substring's first's target is the left-alligator byte, say no.
  if the substring's first's target is the right-alligator byte, say no.
  if the substring's first's target is the bar byte, say no.
  add 1 to the substring's first.
  repeat.

to decide if a string is greater than another string:
  compare the string to the other string given the string's length and the other string's length returning a number.
  if the number is greater than 0, say yes.
  say no.

to decide if a string is greater than or equal to another string:
  compare the string to the other string given the string's length and the other string's length returning a number.
  if the number is greater than or equal to 0, say yes.
  say no.

to decide if a string is in another string:
  slap a substring on the other string.
  put the substring's first plus the string's length minus 1 into the substring's last.
  loop.
  if the substring's last is greater than the other string's last, say no.
  if the substring is the string, say yes.
  move the substring given 1.
  repeat.

to decide if a string is in an index:
\  if the index is nil, say no. \ to make compiler faster
  if the string is blank, say no.
  find a refer given the string and the index.
  if the refer is nil, say no.
  say yes.

to decide if a string is less than another string:
  compare the string to the other string given the string's length and the other string's length returning a number.
  if the number is less than 0, say yes.
  say no.

to decide if a string is less than or equal to another string:
  compare the string to the other string given the string's length and the other string's length returning a number.
  if the number is less than or equal to 0, say yes.
  say no.

to decide if a string is misspelled:
  if the lexicon is nil, say no.
  if the string is not any word, say no.
  privatize the string.
  if the string ends with "'s", remove the last two bytes from the string.
  if the string is in the lexicon's index, say no.
  say yes.

to decide if a string is wider than a box: \ assumes font is selected on memory canvas
  get an abca and an abcc given the string and the memory canvas.
  get a width given the string and the memory canvas.
  subtract the abca from the width.
  subtract the abcc from the width.
  if the width is greater than the box's width, say yes.
  say no.

to decide if a string starts with another string:
  if the other string's length is greater than the string's length, say no.
  slap a substring on the string.
  put the substring's first plus the other string's length minus 1 into the substring's last.
  if the substring is the other string, say yes.
  say no.

to decide if a string starts with a byte:
  if the string is blank, say no.
  if the string's first's target is the byte, say yes.
  say no.

to decide if a substring is on any contraction:
  put the substring's first plus 1 into a byte pointer.
  if the byte pointer is greater than the substring's last, say no.
  if the substring's first's target is not the single-quote byte, say no.
  if the byte pointer's target is not any letter, say no.
  say yes.

to decide if a text can be redone:
  if the text is nil, say no.
  if the text's redos' last is nil, say no.
  say yes.

to decide if a text can be undone:
  if the text is nil, say no.
  if the text's undos' last is nil, say no.
  say yes.

to decide if a text is modified:
  if the text is nil, say no.
  if the text's modified flag is set, say yes.
  say no.

to decide if there is something to backspace in a text:
  if the text is nil, say no.
  if something is selected in the text, say yes.
  if the text's caret row# is not 1, say yes.
  if the text's caret column# is not 1, say yes.
  say no.

to decide if there is something to remove in a text:
  if the text is nil, say no.
  if something is selected in the text, say yes.
  if the text's caret row# is not the text's row count, say yes.
  get a row given the text's caret row# and the text.
  if the text's caret column# is not the row's string's length, say yes.
  say no.

to decide if there is text on the windows clipboard:
  call "user32.dll" "IsClipboardFormatAvailable" with 1 [cf_text] returning a number.
  if the number is 0, say no.
  say yes.

to decide if some things are empty:
  if the things' first is nil, say yes.
  say no.

to decrypt a buffer given a passphrase string: \ sets i/o error if failure
  clear the i/o error.
  create a crypt session given the passphrase.
  if the crypt session is nil, exit.
  convert the buffer as a nibble string to a hex string.
  put the hex string's length into a length.
  call "advapi32.dll" "CryptDecrypt" with the crypt session's hcryptkey and 0 and 1 and 0 and the hex string's first
    and the length's whereabouts returning a result number.
  if the result number is 0, put "Error decrypting data." into the i/o error; destroy the crypt session; exit.
  destroy the crypt session.
  put the hex string into the buffer.

the default console is a console.

the default font is a font.

the default smtp server is "localhost".

the degree-symbol byte is a byte equal to 176.

the delete byte is a byte equal to 127.

the delete key is a key equal to 46.

to deque an event:
  yield to windows.
  put the event queue's first into the event.
  if the event is nil, repeat.
  remove the event from the event queue.
  if the event's kind is "done", destroy the event; exit.
  destroy the current event.
  put the event into the current event.

to deselect a text:
  if the text is nil, exit.
  put the text's caret into the text's anchor.

a designator is a string. \ rightmost directory with slash = folder2\ OR after the last slash to end of path = file.ext

to destroy a crypt session:
  if the crypt session is nil, exit.
  call "advapi32.dll" "CryptDestroyKey" with the crypt session's hcryptkey.
  call "advapi32.dll" "CryptDestroyHash" with the crypt session's hcrypthash.
  call "advapi32.dll" "CryptReleaseContext" with the crypt session's hcryptprov and 0.
  deallocate the crypt session.

to destroy a gpimage:
  if the gpimage is nil, exit.
  call "gdiplus.dll" "GdipDisposeImage" with the gpimage.
  void the gpimage.

to destroy a gpimageattributes:
  if the gpimageattributes is nil, exit.
  call "gdiplus.dll" "GdipDisposeImageAttributes" with the gpimageattributes.
  void the gpimageattributes.

to destroy the hbrush of a canvas:
  call "gdi32.dll" "SelectObject" with the canvas and the null hbrush returning an hbrush.
  call "gdi32.dll" "DeleteObject" with the hbrush.

to destroy the hfont of a canvas:
  call "gdi32.dll" "SelectObject" with the canvas and the null hfont returning an hfont.
  call "gdi32.dll" "DeleteObject" with the hfont.

to destroy the hpen of a canvas:
  call "gdi32.dll" "SelectObject" with the canvas and the null hpen returning an hpen.
  call "gdi32.dll" "DeleteObject" with the hpen.

to destroy an hrgn:
    call "gdi32.dll" "DeleteObject" with the hrgn.

to destroy an index:
  if the index is nil, exit.
  loop.
  get a bucket given the index.
  if the bucket is nil, break.
  destroy the bucket's refers.
  repeat.
  unassign the index's first bucket.
  deallocate the index.

to destroy a path in the file system:
  set the path to read-write mode.
  if the path is directory-format, destroy the path in the file system (directory).
  if the path is file-format, destroy the path in the file system (file).

to destroy a path in the file system (directory):
  loop.
  get an item from the path.
  if the item is not found, break.
  put the path into another path.
  append the item's designator to the other path.
  destroy the other path in the file system.
  if the i/o error is not blank, exit.
  repeat.
  privatize the path.
  null terminate the path.
  call "kernel32.dll" "RemoveDirectoryA" with the path's first returning a number.
  clear the i/o error.
  if the number is not 0, exit.
  put "Error deleting directory '" then the path then "'." into the i/o error.

to destroy a path in the file system (file):
  privatize the path.
  null terminate the path.
  call "kernel32.dll" "DeleteFileA" with the path's first returning a number.
  clear the i/o error.
  if the number is not 0, exit.
  put "Error deleting file '" then the path then "'." into the i/o error.

to destroy a picture:
  if the picture is nil, exit.
  destroy the picture's gpbitmap.
  deallocate the picture.

to destroy a socket:
  call "ws2_32.dll" "closesocket" with the socket.

to destroy a vertex given a polygon:
  if the vertex is nil, exit.
  if the polygon is nil, exit.
  privatize the vertex.
  remove the vertex from the polygon's vertices.
  destroy the vertex.

to destroy a winhttp request:
  if the winhttp request is nil, exit.
  call "winhttp.dll" "WinHttpCloseHandle" with the winhttp request's request.
  call "winhttp.dll" "WinHttpCloseHandle" with the winhttp request's connection.
  call "winhttp.dll" "WinHttpCloseHandle" with the winhttp request's session.
  deallocate the winhttp request.

the device-control-four byte is a byte equal to 20.

the device-control-one byte is a byte equal to 17.

the device-control-three byte is a byte equal to 19.

the device-control-two byte is a byte equal to 18.

a devmode is a record with
  32 bytes called dmdevicename,
  a wyrd called dmspecversion,
  a wyrd called dmdriverversion,
  a wyrd called dmsize,
  a wyrd called dmdriverextra,
  a number called dmfields,
  a wyrd called dmorientation,
  a wyrd called dmpapersize,
  a wyrd called paperlength,
  a wyrd called paperwidth,
  a wyrd called dmscale,
  a wyrd called dmcopies,
  a wyrd called dmdefaultsource,
  a wyrd called dmprintquality,
  a wyrd called dmcolor,
  a wyrd called dmduplex,
  a wyrd called ydmresolution,
  a wyrd called dmttoption,
  a wyrd called dmcollate,
  32 bytes called dmformname,
  a wyrd called dmlogpixels,
  a number called dmbitsperpel,
  a number called dmpelswidth,
  a number called dmpelsheight,
  a number called dmdisplayflags,
  a number called dmdisplayfrequency,
  a number called dmicmmethod,
  a number called dmicmintent,
  a number called dmmediatype,
  a number called dmdithertype,
  a number called dmreserved1,
  a number called dmreserved2.

the diaeresis byte is a byte equal to 168.

a difference is a pair.

a directory is a path. \ start of path to last slash inclusive = c:\folder1\folder2\

a directory name is a string. \ rightmost directory with slash = folder2\

a directory name w/o slash is a string. \ rightmost directory without slash = folder2

a distance is a number.

to divide a number by another number:
  if the other number is 0, put the largest number into the number; exit.
  intel $8B8508000000. \ mov eax,[ebp+8] \ the number
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the other number
  intel $8B00. \ mov eax,[eax]
  intel $99. \ cdq
  intel $F73B. \ div [ebx] \ means div eax,[ebx] but is weird form
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the number
  intel $8903. \ mov [ebx],eax

to divide a number by another number giving a quotient and a remainder:
  if the other number is 0, put the largest number into the number; put 0 into the remainder; exit.
  intel $8B8508000000. \ mov eax,[ebp+8] \ the number
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the other number
  intel $8B00. \ mov eax,[eax]
  intel $99. \ cdq
  intel $F73B. \ idiv [ebx] \ means idiv eax,[ebx] but is weird form
  intel $8B9D10000000. \ mov ebx,[ebp+16] \ the quotient
  intel $8903. \ mov [ebx],eax
  intel $8B9D14000000. \ mov ebx,[ebp+20] \ the remainder
  intel $8913. \ mov [ebx],edx

to divide a number by a ratio:
  privatize the ratio.
  flip the ratio.
  multiply the number by the ratio.

to divide a pair by another pair:
  divide the pair's x by the other pair's x.
  divide the pair's y by the other pair's y.

to divide a pair by a number:
  divide the pair's x by the number.
  divide the pair's y by the number.

to divide a pair by a number and another number:
  divide the pair's x by the number.
  divide the pair's y by the other number.

to divide a pointer by a number: employ divide a number by another number.

to divide a pointer by a number giving a quotient and a remainder: employ to divide a number by another number giving a quotient and a remainder.

to divide a ratio by another ratio:
  privatize the other ratio.
  flip the other ratio.
  multiply the ratio by the other ratio.

to divide a ratio by a number:
  multiply the ratio's denominator by the number.
  reduce the ratio.

the division-symbol byte is a byte equal to 247.

a docinfo is a record with
  a number called cbsize,
  a pointer called lpszdocname,
  a pointer called lpszoutput,
  a pointer called lpszdatadtype,
  a number called fwtype.

the dollar-sign byte is a byte equal to 36.

the double-dagger byte is a byte equal to 135.

the double-quote byte is a byte equal to 34.

the down-arrow key is a key equal to 40.

to draw any visible rows of a text:
  if the text is nil, exit.
  loop.
  get a row from the text's rows.
  if the row is nil, exit.
  if the row of the text is not visible, repeat.
  draw the row of the text.
  repeat.

to draw any visible rows of a text (editing):
  if the text is nil, exit.
  loop.
  get a row from the text's rows.
  if the row is nil, exit.
  if the row of the text is not visible, repeat.
  draw the row of the text (editing).
  repeat.

to draw a box:
  draw the box with the black color and the clear color.

to draw a box (focus style):
  privatize the box.
  add the tpp to the box's right-bottom.
  call "gdi32.dll" "LPtoDP" with the current canvas and the box's whereabouts and 2.
  convert the white color to a colorref.
  call "gdi32.dll" "SetBkColor" with the current canvas and the colorref.
  convert the black color to another colorref.
  call "gdi32.dll" "SetTextColor" with the current canvas and the other colorref.
  call "gdi32.dll" "SetMapMode" with the current canvas and 1 [mm_text].
  call "user32.dll" "DrawFocusRect" with the current canvas and the box's whereabouts.
  normalize the current canvas.

to draw a box with a border color and a fill color:
  if the pdf state's page flag is set, draw the box with the border and the fill (pdf style); exit.
  privatize the box.
  create the hpen of the current canvas given the border.
  create the hbrush of the current canvas given the fill.
  if the border is clear, add the tpp to the box's left-top.
  call "gdi32.dll" "Rectangle" with the current canvas and the box's left and the box's top and the box's right and the box's bottom.
  destroy the hbrush of the current canvas.
  destroy the hpen of the current canvas.

to draw a box with a border color and a fill color (pdf style):
  if the border and the fill are clear, exit.
  output setcolor given the border and the fill.
  output the box's left-bottom without advancing.
  output the box's x-extent without advancing.
  output the box's y-extent without advancing.
  output "re".
  output stroke and fill given the border and the fill.

to draw a box with a color:
  draw the box with the color and the color.

to draw the caret in a text:
  if the text is nil, exit.
  get a box for the caret in the text.
  if the box is not touching the text's box, exit.
  put the box's left-top and the box's right-bottom into a line.
  draw the line with the black color.

to draw a console:
  if the console is nil, exit.
  save the current canvas.
  mask only outside the console's box.
  draw the console's box with the console's border and the console's fill.
  draw the console's text.
  restore the current canvas.

to draw an ellipse:
  draw the ellipse with the black color and the clear color.

to draw an ellipse with a border color and a fill color:
  if the pdf state's page flag is set, draw the ellipse with the border and the fill (pdf style); exit.
  privatize the ellipse.
  create the hpen of the current canvas given the border.
  create the hbrush of the current canvas given the fill.
  if the border is clear, add the tpp to the ellipse's left-top.
  call "gdi32.dll" "Ellipse" with the current canvas and the ellipse's left and the ellipse's top and the ellipse's right and the ellipse's bottom.
  destroy the hbrush of the current canvas.
  destroy the hpen of the current canvas.

to draw an ellipse with a border color and a fill color (pdf style):
  if the border and the fill are clear, exit.
  output setcolor given the border and the fill.
  put the ellipse's left and the ellipse's top into a spot.
  add the ellipse's y-extent divided by 2 to the spot's y.
  output moveto given the spot.
  output the arc of the ellipse given "left-top".
  output the arc of the ellipse given "right-top".
  output the arc of the ellipse given "right-bottom".
  output the arc of the ellipse given "left-bottom".
  output stroke and fill given the border and the fill.

to draw an ellipse with a color:
  draw the ellipse with the color and the color.

to draw a gpbitmap at a spot (pdf style):
  if the gpbitmap is nil, exit.
  \ add xobject
  add an xobject pdf object given "image object".
  put "I" then the xobject's number into a name.
  \  add to image resources in current page
  put "/" then the name then " " then the xobject's number then " 0 R" into a string.
  create a new string thing given the string.
  append the new string thing to the pdf state's current page's image strings.
  \ finish setting up xobject
  append the xobject's number then " 0 obj" to the xobject.
  append "<<" to the xobject.
  append "/Type /XObject" to the xobject.
  append "/Subtype /Image" to the xobject.
  append "/ColorSpace /DeviceRGB" to the xobject.
  append "/Width " then the gpbitmap's width to the xobject.
  append "/Height " then the gpbitmap's height to the xobject.
  append "/BitsPerComponent 8" to the xobject.
  convert the gpbitmap to a buffer (pdf style).
  convert the buffer to a nibble string.
  append "/Filter /ASCIIHexDecode" to the xobject.
  append "/Length " then the nibble string's length to the xobject.
  append ">>" to the xobject.
  append "stream" to the xobject.
  append the nibble string to the xobject.
  append "endstream" to the xobject.
  append "endobj" to the xobject.
  \ draw the image in the current contents
  put the gpbitmap's width times the tpp into a width.
  put the gpbitmap's height times the tpp into a height.
  put the spot's x into an x number.
  put the pdf state's current height minus the spot's y minus the height into a y number.
  output "q".
  output the width then " 0 0 " then the height then " " then the x then " " then the y then " cm".
  output "/" then the name then " Do".
  output "Q".

to draw a line:
  draw the line with the black color.

to draw a line with a color:
  if the pdf state's page flag is set, draw the line with the color (pdf style); exit.
  create the hpen of the current canvas given the color.
  call "gdi32.dll" "MoveToEx" with the current canvas and the line's start's x and the line's start's y and nil.
  call "gdi32.dll" "LineTo" with the current canvas and the line's end's x and the line's end's y.
  convert the color to a colorref.
  call "gdi32.dll" "SetPixelV" with the current canvas and the line's end's x and the line's end's y and the colorref.
  destroy the hpen of the current canvas.

to draw a line with a color (pdf style):
  if the color is clear, exit.
  output setcolor given the color and the clear color.
  output moveto given the line's start.
  output lineto given the line's end.
  output stroke and fill given the color and the clear color.

to draw a picture:
  if the pdf state's page flag is set, draw the picture (pdf style); exit.
  if the picture is nil, exit.
  save the current canvas.
  mask outside the picture's box.
  call "gdiplus.dll" "GdipCreateFromHDC" with the current canvas and a gpgraphic's whereabouts.
  call "gdiplus.dll" "GdipSetPageUnit" with the gpgraphic and 2 [pixels].
  draw the picture on the gpgraphic at the picture's uncropped box's left and the picture's uncropped box's top.
  call "gdiplus.dll" "GdipDeleteGraphics" with the gpgraphic.
  restore the current canvas.

to draw a picture (pdf style):
  if the picture is nil, exit.
  put the picture's box's left minus the picture's uncropped box's left divided by the tpp into an x number.
  put the picture's box's top minus the picture's uncropped box's top divided by the tpp  into an y number.
  put the picture's box's width divided by the tpp into a width.
  put the picture's box's height divided by the tpp into a height.
  call "gdiplus.dll" "GdipCreateBitmapFromScan0" with the width and the height and 0 and 137224 [pixelformat24bpprgb] and 0 and a gpbitmap's whereabouts.
  call "gdiplus.dll" "GdipGetImageGraphicsContext" with the gpbitmap and a gpgraphic's whereabouts.
  if the picture's grayscale flag is set, create a gpimageattributes (grayscale).
  call "gdiplus.dll" "GdipDrawImageRectRectI" with the gpgraphic and the picture's gpbitmap
    and 0 and 0 and the width and the height
    and the x and the y and the width and the height
    and 2 [unitpixel] and the gpimageattributes and nil and 0.
  if the gpimageattributes is not nil, destroy the gpimageattributes.
  call "gdiplus.dll" "GdipDeleteGraphics" with the gpgraphic.
  draw the gpbitmap at the picture's box's left-top (pdf style).
  call "gdiplus.dll" "GdipDisposeImage" with the gpbitmap.

to draw a picture on a gpgraphic at an x coord and a y coord:
  if the picture is nil, exit.
  if the picture's grayscale flag is set, create a gpimageattributes (grayscale).
  call "gdiplus.dll" "GdipDrawImageRectRectI" with the gpgraphic and the picture's gpbitmap
    and the x and the y and the picture's uncropped box's width and the picture's uncropped box's height
    and 0 and 0 and the picture's gpbitmap's width and the picture's gpbitmap's height
    and 2 [unitpixel] and the gpimageattributes and nil and 0.
  if the gpimageattributes is not nil, destroy the gpimageattributes.

to draw a polygon:
  draw the polygon with the black color and the clear color.

to draw a polygon with a border color and a fill color:
  if the pdf state's page flag is set, draw the polygon with the border and the fill (pdf style); exit.
  if the polygon is nil, exit.
  draw the polygon with the fill (fill only).
  draw the polygon with the border (border only).

to draw a polygon with a border color and a fill color (pdf style):
  if the polygon is nil, exit.
  if the border and the fill are clear, exit.
  output setcolor given the border and the fill.
  get a vertex from the polygon's vertices.
  if the vertex is nil, exit.
  output moveto given the vertex's spot.
  loop.
  get the vertex from the polygon's vertices.
  if the vertex is nil, break.
  output lineto given the vertex's spot.
  repeat.
  output stroke and fill given the border and the fill.

to draw a polygon with a color:
  draw the polygon with the color and the color.

to draw a polygon with a color (border only):
  if the polygon is nil, exit.
  if the color is clear, exit.
  create the hpen of the current canvas given the color.
  get a vertex from the polygon's vertices.
  if the vertex is nil, exit.
  call "gdi32.dll" "MoveToEx" with the current canvas and the vertex's x and the vertex's y and nil.
  loop.
  get the vertex from the polygon's vertices.
  if the vertex is nil, break.
  call "gdi32.dll" "LineTo" with the current canvas and the vertex's x and the vertex's y.
  repeat.
  destroy the hpen of the current canvas.
  if the polygon's vertices' first's spot is the polygon's vertices' last's spot, exit.
  convert the color to a colorref.
  call "gdi32.dll" "SetPixelV" with the current canvas and the polygon's vertices' last's x and the polygon's vertices' last's y and the colorref.

to draw a polygon with a color (fill only):
  if the polygon is nil, exit.
  if the color is clear, exit.
  create the hpen of the current canvas given the clear color.
  create the hbrush of the current canvas given the color.
  call "gdi32.dll" "SetPolyFillMode" with the current canvas and 2 [winding].
  create a vertex array given the polygon's vertices.
  call "gdi32.dll" "Polygon" with the current canvas and the vertex array's spot pointer and the vertex array's count.
  destroy the vertex array.
  destroy the hbrush of the current canvas.
  destroy the hpen of the current canvas.

to draw a roundy box:
  draw the roundy box with the black color and the clear color.

to draw a roundy box with a border color and a fill color:
  if the pdf state's page flag is set, draw the roundy box with the border and the fill (pdf style); exit.
  privatize the roundy box.
  create the hpen of the current canvas given the border.
  create the hbrush of the current canvas given the fill.
  if the border is clear, add the tpp to the roundy box's left-top.
  put the roundy box's radius times 2 into a diameter number.
  call "gdi32.dll" "RoundRect" with the current canvas and the roundy box's left and the roundy box's top and the roundy box's right and the roundy box's bottom
    and the diameter and the diameter.
  destroy the hbrush of the current canvas.
  destroy the hpen of the current canvas.

to draw a roundy box with a border color and a fill color (pdf style):
  if the border and the fill are clear, exit.
  if the roundy box's radius is 0, draw the roundy box as a box with the border and the fill (pdf style); exit.
  put the roundy box's radius into a radius.
  put the radius times 2 into an offset.
  put the roundy box into a box.
  output setcolor given the border and the fill.
  \ initial moveto
  output moveto given the box's left and the box's top plus the radius.
  \ left-top
  put the box's left and the box's top and the box's left plus the offset and the box's top plus the offset into an ellipse.
  output the arc of the ellipse given "left-top".
  output lineto given the box's right minus the radius and the box's top.
  \ right-top
  put the box's right minus the offset and the box's top and the box's right and the box's top plus the offset into the ellipse.
  output the arc of the ellipse given "right-top".
  output lineto given the box's right and the box's bottom minus the radius.
  \ right-bottom
  put the box's right minus the offset and the box's bottom minus the offset and the box's right and the box's bottom into the ellipse.
  output the arc of the ellipse given "right-bottom".
  output lineto given the box's left plus the radius and the box's bottom.
  \ left-bottom
  put the box's left and the box's bottom minus the offset and the box's left plus the offset and the box's bottom into the ellipse.
  output the arc of the ellipse given "left-bottom".
  \ finish up
  output "h".
  output stroke and fill given the border and the fill.

to draw a roundy box with a color:
  draw the roundy box with the color and the color.

to draw a row of a text:
  if the text is nil, exit.
  if the row is nil, exit.
  get a box given the row and the text.
  draw the row's working string in the box with the text's pen and the text's font and the text's alignment.

to draw a row of a text (editing):
  if the text is nil, exit.
  if the row is nil, exit.
  draw the selection box for the row of the text.
  get a box given the row and the text.
  draw the row's working string in the box with the text's pen and the text's font and the text's alignment.

to draw the selection box for a row of a text:
  if the text is nil, exit.
  if the row is nil, exit.
  if the row of the text is not selected, exit.
  get a selection box given the row and the text.
  draw the selection box with the hilite color and the hilite color.

to draw a spot:
  draw the spot with the black color.

to draw a spot with a color:
  convert the color to a colorref.
  call "gdi32.dll" "SetPixelV" with the current canvas and the spot's x and the spot's y and the colorref.

to draw a string at the left of a box:
  draw the string at the left of the box with the black color and the default font.

to draw a string at the left of a box with a color:
  draw the string at the left of the box with the color and the default font.

to draw a string at the left of a box with a color and a font:
  draw the string in the box with the color and the font and "left".

to draw a string at the left of a box with a font:
  draw the string at the left of the box with the black color and the font.

to draw a string at the right of a box:
  draw the string at the right of the box with the black color and the default font.

to draw a string at the right of a box with a color:
  draw the string at the right of the box with the color and the default font.

to draw a string at the right of a box with a color and a font:
  draw the string in the box with the color and the font and "right".

to draw a string at the right of a box with a font:
  draw the string at the right of the box with the black color and the font.

to draw a string at a spot with a color and a font:
  if the pdf state's page flag is set, draw the string at the spot with the color and the font (pdf style); exit.
  set the colorref of the current canvas given the color.
  create the hfont of the current canvas given the font.
  adjust spacing given the string.
  put the string's first into a substring's first.
  put the substring's first plus the text cutoff minus 1 into the substring's last.
  privatize the spot.
  loop.
  if the substring is blank, break.
  if the substring's last is greater than the string's last, put the string's last into the substring's last.
  call "gdi32.dll" "TextOutA" with the current canvas and the spot's x and the spot's y and the substring's first and the substring's length.
  get a width given the substring and the current canvas.
  add the width to the spot's x.
  move the substring given the text cutoff.
  repeat.
  destroy the hfont of the current canvas.

to draw a string at a spot with a color and a font (pdf style):
  if the string is blank, exit.
  privatize the spot.  
  include the font in the current pdf.
  include the font in the pdf state's current page.
  find a definition pdf object given the font's name and the pdf state's font index.
  if the definition is nil, exit. \ error
  create a font info given the font and the string.
  output the pdf border given the color.
  output the pdf fill given the color.
  output "BT".
  output "/" then the definition's font name then " " then the font's adjusted height then " Tf".
  add the font's adjusted height minus the font info's internal leading to the spot's y.
  output the spot without advancing.
  output "Td".
  output "[" without advancing.
  convert the font info to pdf em units.
  convert the string and the font info and the definition's font info into a buffer for pdf output.
  output the buffer without advancing.
  output "]" without advancing.
  output " TJ".
  output "ET".
  destroy the font info.

to draw a string in a box:
  draw the string in the box with the black color and the default font and "left".

to draw a string in a box over a number with a color and a font and an alignment:
  privatize the box.
  if the alignment is "left", add the number to the box's left.
  if the alignment is "right", subtract the number from the box's right.
  draw the string in the box with the color and the font and the alignment.

to draw a string in a box with an alignment:
  draw the string in the box with the black color and the default font and the alignment.

to draw a string in a box with a color:
  draw the string in the box with the color and the default font and "left".

to draw a string in a box with a color and an alignment:
  draw the string in the box with the color and the default font and the alignment.

to draw a string in a box with a color and a font and an alignment:
  get an offset pair given the string and the box and the font and the alignment.
  draw the string at the box's left-top plus the offset pair with the color and the font.

to draw a string in a box with a font and an alignment:
  draw the string in the box with the black color and the font and the alignment.

to draw a string in the center of a box:
  draw the string in the center of the box with the black color and the default font.

to draw a string in the center of a box with a color:
  draw the string in the center of the box with the color and the default font.

to draw a string in the center of a box with a color and a font:
  draw the string in the box with the color and the font and "center".

to draw a string in the center of a box with a font:
  draw the string in the center of the box with the black color and the font.

to draw a text:
  if the text is nil, exit.
  save the current canvas.
  mask outside the text's box.
  draw any visible rows of the text.
  restore the current canvas.

to draw a text (editing):
  if the text is nil, exit.
  save the current canvas.
  mask outside the text's box.
  draw any visible rows of the text (editing).
  draw the caret in the text.
  restore the current canvas.

a drive is a string. \ start of path to first slash = c:\ OR start of path to fourth slash = \\computer\share\

a drive kind is a string.

to duplicate a path to another path in the file system:
  if the path is directory-format, duplicate the path to the other path in the file system (directory).
  if the path is file-format, duplicate the path to the other path in the file system (file).

to duplicate a path to another path in the file system (directory):
  if the path is in the other path, put "Error duplicating directory '" then the path then "' - invalid recursion." into the i/o error; exit.
  if the path is not in the file system, put "Error duplicating directory '" then the path then "'." into the i/o error; exit.
  if the other path is not in the file system, create the other path in the file system.
  loop.
  get an item from the path.
  if the item is not found, exit.
  put the path into a third path.
  append the item's designator to the third path.
  put the other path into a fourth path.
  append the item's designator to the fourth path.
  duplicate the third path to the fourth path in the file system.
  repeat.

to duplicate a path to another path in the file system (file):
  privatize the path.
  null terminate the path.
  privatize the other path.
  null terminate the other path.
  call "kernel32.dll" "CopyFileA" with the path's first and the other path's first and 0 returning a number.
  clear the i/o error.
  if the number is not 0, set the path to read-write mode; exit.
  put "Error duplicating file '" then the path then "'." into the i/o error.

a dyad is a thing with
  a name,
  a value string.

the e-key is a key equal to 69.

the eight byte is a byte equal to 56.

the eight key is a key equal to 56.

an ellipse has a box.

the ellipsis byte is a byte equal to 133.

the em-dash byte is a byte equal to 151.

an email has
  a smtp server,
  a sender,
  a recipient,
  a subject,
  a message.

the en-dash byte is a byte equal to 150.

to encrypt a buffer given a passphrase string: \ sets i/o error if failure
  clear the i/o error.
  create a crypt session given the passphrase.
  if the crypt session is nil, exit.
  put the buffer into a temp buffer.
  put the temp buffer's length into a length.
  call "advapi32.dll" "CryptEncrypt" with the crypt session's hcryptkey and 0 and 1 and 0 and the temp buffer's first
    and the length's whereabouts and the length returning a result number.
  if the result number is 0, put "Error encrypting data." into the i/o error; destroy the crypt session; exit.
  destroy the crypt session.
  convert the temp buffer to a nibble string.
  put the nibble string into the buffer.

the end key is a key equal to 35.

to end printing:
  if the pdf state's document flag is set, end printing (pdf style); exit.
  call "gdi32.dll" "EndDoc" with the printer canvas.
  finalize the printer canvas.

to end printing (pdf style):
  if the pdf state's document flag is not set, exit.
  end printing the pdf state's pdf pointer's target.

to end printing a pdf:
  end printing the pdf (finish the parent).
  end printing the pdf (append the outline).
  end printing the pdf (finish the root).
  clear the pdf.
  end printing the pdf (append header).
  end printing the pdf (offset and append objects).
  end printing the pdf (append xref table).
  end printing the pdf (append trailer).
  end printing the pdf (append footer).
  destroy the pdf state's font index.
  destroy the pdf state's outline entries.
  destroy the pdf state's objects.
  clear the pdf state's document flag.

to end printing a pdf (append footer):
  append "startxref" then the crlf string to the pdf.
  append the pdf state's xref offset then the crlf string to the pdf.
  append "%%EOF" to the pdf.

to end printing a pdf (append header):
  append "%PDF-1.3" then the crlf string to the pdf.
  append "%âãÏÓ" then the crlf string to the pdf.
  append the crlf string to the pdf.

to end printing a pdf (append the outline entries - create the objects):
  get a pdf outline entry from the pdf state's outline entries.
  if the pdf outline entry is nil, exit.
  add an entry pdf object given "outline entry".
  put the entry into the pdf outline entry's pdf object.
  repeat.

to end printing a pdf (append the outline entries):
  if the pdf state's outline entries are empty, exit.
  end printing the pdf (append the outline entries - create the objects).
  loop.
  get a pdf outline entry from the pdf state's outline entries.
  if the pdf outline entry is nil, exit.
  put the pdf outline entry's pdf object into an object pdf object.
  append the object's number then " 0 obj" to the object.
  append "<<" to the object.
  convert the pdf outline entry's title to a pdf string.
  append "/Title " then the pdf string to the object.
  append "/Parent " then the pdf state's outline's number then " 0 R" to the object.
  if the pdf outline entry's next is not nil, append "/Next " then the pdf outline entry's next's pdf object's number then " 0 R" to the object.
  if the pdf outline entry's previous is not nil, append "/Prev " then the pdf outline entry's previous' pdf object's number then " 0 R" to the object.
  append "/Dest [" then the pdf outline entry's destination then " 0 R /XYZ null " then the pdf outline entry's  page height then " null]" to the object.
  append ">>" to the object.
  append "endobj" to the object.
  repeat.

to end printing a pdf (append the outline):
  void the pdf state's outline.
  if the pdf state's outline entries are empty, exit.
  add an outline pdf object given "outline".
  put the outline into the pdf state's outline.
  end printing the pdf (append the outline entries).
  append the outline's number then " 0 obj" to the outline.
  append "<<" to the outline.
  append "/Type /Outlines" to the outline.
  append "/First " then the pdf state's outline entries' first's pdf object's number then " 0 R" to the outline.
  append "/Last " then the pdf state's outline entries' last's pdf object's number then " 0 R" to the outline.
  append "/Count " then the pdf state's outline entries' count to the outline.
  append ">>" to the outline.
  append "endobj" to the outline.

to end printing a pdf (append trailer):
  append "trailer" then the crlf string to the pdf.
  append "<<" then the crlf string to the pdf.
  put the pdf state's objects' count plus 1 into a count.
  append "/Size " then the count then the crlf string to the pdf.
  append "/Root " then the pdf state's root's number then " 0 R" then the crlf string to the pdf.
  append ">>" then the crlf string to the pdf.
  append the crlf string to the pdf.

to end printing a pdf (append xref table):
  put the pdf's length into the pdf state's xref offset.
  append "xref" then the crlf string to the pdf.
  put the pdf state's objects' count plus 1 into a count.
  append "0 " then the count then the crlf string to the pdf.
  append "0000000000 65535 f" then the crlf string to the pdf.
  loop.
  get a pdf object from the pdf state's objects.
  if the pdf object is nil, break.
  zero fill the pdf object's offset given 10 and append it to the pdf.
  append " 00000 n" then the crlf string to the pdf.
  repeat.
  append the crlf string to the pdf.

to end printing a pdf (finish the parent):
  put the pdf state's parent into a parent pdf object.
  append "/Kids [" to the parent without advancing.
  loop.
  get a pdf object from the pdf state's objects.
  if the pdf object is nil, break.
  if the pdf object's kind is not "page", repeat.
  if a flag is set, append " " to the parent without advancing.
  append the pdf object's number then " 0 R" to the parent without advancing.
  set the flag.
  add 1 to a count.
  if the count is evenly divisible by 20, append the crlf string then "  " to the parent without advancing.
  repeat.
  append "]" to the parent.
  append "/Count " then the count to the parent.
  append ">>" to the parent.
  append "endobj" to the parent.

to end printing a pdf (finish the root):
  put the pdf state's root into a root pdf object.
  append "/Pages " then the pdf state's parent's number then " 0 R" to the root.
  find a pdf object given "page".
  append "/OpenAction [" then the pdf object's number then " 0 R /XYZ null null 1]" to the root.
  append "/PageMode /UseNone" to the root.
  if the pdf state's outline is not nil, append "/Outlines " then the pdf state's outline's number then " 0 R" to the root.
  append ">>" to the root.
  append "endobj" to the root.

to end printing a pdf (offset and append objects):
  get a pdf object from the pdf state's objects.
  if the pdf object is nil, break.
  put the pdf's length into the pdf object's offset.
  append the pdf object's data to the pdf.
  append the crlf string to the pdf.
  repeat.

to end a sheet:
  if the pdf state's document flag is set, end the sheet (pdf style); exit.
  call "gdi32.dll" "EndPage" with the printer canvas.
  put the memory canvas into the current canvas.
  put the saved tpp into the tpp.

to end a sheet (pdf style - finish the current contents):
  put the pdf state's current contents into a content pdf object.
  put the content's data into a buffer.
  clear the content's data.
  append the content's number then " 0 obj" to the content.
  append "<</Length " then the buffer's length then " >>" to the content.
  append "stream" to the content.
  append the buffer to the content's data.
  append "endstream" to the content.
  append "endobj" to the content.
  clear the pdf state's page flag.

to end a sheet (pdf style - finish the current page - font resources):
  put the pdf state's current page into a page pdf object.
  if the page's font strings are empty, exit.
  append "/Font <<" to the page without advancing.
  loop.
  get a string thing from the page's font strings.
  if the string thing is nil, break.
  if a flag is set, append " " to the page without advancing.
  append the string thing's string to the page without advancing.
  set the flag.
  repeat.
  append ">>" to the page.

to end a sheet (pdf style - finish the current page - image resources):
  put the pdf state's current page into a page pdf object.
  if the page's image strings are empty, exit.
  append "/XObject <<" to the page without advancing.
  loop.
  get a string thing from the page's image strings.
  if the string thing is nil, break.
  if a flag is set, append " " to the page without advancing.
  append the string thing's string to the page without advancing.
  set the flag.
  repeat.
  append ">>" to the page.

to end a sheet (pdf style - finish the current page):
  put the pdf state's current page into a page pdf object.
  append "/Resources" to the page.
  append "<<" to the page.
  append "/ProcSet [/PDF /Text /ImageC]" to the page.
  end the sheet (pdf style - finish the current page - font resources).
  end the sheet (pdf style - finish the current page - image resources).
  append ">>" to the page. \ end resources
  append ">>" to the page. \ end page
  append "endobj" to the page.

to end a sheet (pdf style):
  end the sheet (pdf style - finish the current page).
  end the sheet (pdf style - finish the current contents).

the end-of-medium byte is a byte equal to 25.

the end-of-text byte is a byte equal to 3.

the end-of-transmission byte is a byte equal to 4.

the end-of-transmission-block byte is a byte equal to 23.

to enque an event:
  append the event to the event queue.

the enquiry byte is a byte equal to 5.

the enter key is a key equal to 13.

the equal-sign byte is a byte equal to 61.

the equal-sign key is a key equal to 187.

the escape byte is a byte equal to 27.

the escape key is a key equal to 27.

the euro-sign byte is a byte equal to 128.

an event is a thing with
  a kind,
  a shift flag,
  a ctrl flag,
  an alt flag,
  a spot,
  a key, a byte.

the event queue is an event queue.

an event queue is some events.

the exclamation byte is a byte equal to 33.

to extend any selection in a text given a spot:
  if the text is nil, exit.
  get the text's caret given the spot and the text.
  clear the text's last operation.

to extend a box to include another box:
  if the other box's left is less than the box's left, put the other box's left into the box's left.
  if the other box's top is less than the box's top, put the other box's top into the box's top.
  if the other box's right is greater than the box's right, put the other box's right into the box's right.
  if the other box's bottom is greater than the box's bottom, put the other box's bottom into the box's bottom.

an extension is a string. \ last dot to end of path = .ext

to extract a designator from a path:
  clear the designator.
  extract a drive from the path.
  slap a path substring on the path.
  add the drive's length to the path substring's first.
  if the path substring is blank, put the drive into the designator; exit.
  slap a substring on the last byte of the path substring.
  if the substring's first's target is the backslash byte, subtract 1 from the substring's first.
  loop.
  if the substring's first is less than the path substring's first, break.
  if the substring's first's target is the backslash byte, break.
  subtract 1 from the substring's first.
  repeat.
  add 1 to the substring's first.
  put the substring into the designator.

to extract a directory from a path:
  clear the directory.
  extract a drive from the path.
  if the drive is blank, exit.
  slap a substring on the path.
  add the drive's length to the substring's first.
  if the substring is blank, exit.
  if the substring's last's target is the backslash byte, subtract 1 from the substring's last.
  loop.
  if the substring is blank, break.
  if the substring's last's target is the backslash byte, break.
  subtract 1 from the substring's last.
  repeat.
  put the drive then the substring into the directory.

to extract a directory name from a path:
  clear the directory name.
  if the path is not directory-format, exit.
  extract the directory name as a designator from the path.

to extract a directory name w/o slash from a path:
  extract the directory name w/o slash as a directory name from the path.
  if the directory name w/o slash is blank, exit.
  remove the last byte from the directory name w/o slash.

to extract a drive from a path:
  clear the drive.
  if the path's length is less than 3, exit.
  slap a substring on the first byte of the path.
  add 2 to the substring's last.
  if the substring ends with ":\", put the substring into the drive; exit.
  if the substring does not start with "\\", exit.
  slap the substring on the first byte of the path.
  loop.
  if the substring's last is greater than the path's last, exit.
  if the substring's last's target is the backslash byte, add 1 to a count.
  if the count is 4, break. \ "\\computer\share\"
  add 1 to the substring's last.
  repeat.
  put the substring into the drive.

to extract an extension from a path:
  clear the extension.
  if the path is blank, exit.
  slap a substring on the last byte of the path.
  loop.
  if the substring's first is less than the path's first, exit.
  if the substring's first's target is the colon byte, exit.
  if the substring's first's target is the backslash byte, exit.
  if the substring's first's target is the period byte, break.
  subtract 1 from the substring's first.
  repeat.
  put the substring into the extension.

to extract a file name from a path:
  clear the file name.
  if the path is not file-format, exit.
  extract the file name as a designator from the path.

to extract a file name w/o extension from a path:
  extract the file name w/o extension as a file name from the path.
  extract an extension from the path.
  remove trailing bytes from the file name w/o extension given the extension's length.

to extract a picture given a box:
  put the box's width divided by the tpp into a width.
  put the box's height divided by the tpp into a height.
  call "gdiplus.dll" "GdipCreateBitmapFromScan0" with the width and the height and 0 and 137224 [pixelformat24bpprgb] and 0 and a gpbitmap's whereabouts.
  call "gdiplus.dll" "GdipGetImageGraphicsContext" with the gpbitmap and a gpgraphic's whereabouts.
  call "gdiplus.dll" "GdipGetDC" with the gpgraphic and a bitmap canvas' whereabouts.
  normalize the bitmap canvas.
  call "gdi32.dll" "BitBlt" with the bitmap canvas and 0 and 0 and the box's width and the box's height
    and the current canvas and the box's left and the box's top and 13369376 [srccopy].
  call "gdiplus.dll" "GdipReleaseDC" with the gpgraphic and the bitmap canvas.
  call "gdiplus.dll" "GdipDeleteGraphics" with the gpgraphic.
  create the picture given the gpbitmap.
  put the box into the picture's box.
  put the box into the picture's uncropped box.

to extract a string from a text:
  if the text is nil, clear the string; exit.
  convert the text's rows to the string.
  remove any trailing linefeed byte from the string.
  remove any trailing return byte from the string.

to extract a string from a text (no linefeed additions):
  if the text is nil, clear the string; exit.
  convert the text's rows to the string (no linefeed additions).
  remove any trailing return byte from the string.

to extract a string from a text (selected bytes):
  clear the string.
  if the text is nil, exit.
  loop.
  get a row from the text's rows.
  if the row is nil, exit.
  slap a substring on any selected bytes in the row of the text.
  if the substring is blank, repeat.
  append the substring to the string.
  if the substring's last's target is the return byte, append the linefeed byte to the string.
  repeat.

the f-key is a key equal to 70.

the f1-key is a key equal to 112.

the f10-key is a key equal to 121.

the f11-key is a key equal to 122.

the f12-key is a key equal to 123.

the f2-key is a key equal to 113.

the f3-key is a key equal to 114.

the f4-key is a key equal to 115.

the f5-key is a key equal to 116.

the f6-key is a key equal to 117.

the f7-key is a key equal to 118.

the f8-key is a key equal to 119.

the f9-key is a key equal to 120.

the feminine byte is a byte equal to 170.

a file is a handle.

a file name is a string. \ after the last slash to end of path = file.ext

a file name w/o extension is a string. \ after the last slash to last dot or end of path = file

the file-separator byte is a byte equal to 28.

a filetime is a record with
  a number called dwlowdatetime,
  a number called dwhighdatetime.

to fill bytes with a byte starting at a pointer for a byte count:
  intel $8BBD0C000000. \ mov edi,[ebp+12] \ the pointer
  intel $8B3F. \ mov edi,[edi]
  intel $8B8D10000000. \ mov ecx,[ebp+16] \ the count
  intel $8B09. \ mov ecx,[ecx]
  intel $8B8508000000. \ mov eax,[ebp+8] \ the byte
  intel $8A00. \ mov al,[eax]
  intel $FC. \ cld
  intel $F3AA. \ rep stosb

to fill a string with a byte given a count:
  reassign the string's first given the count.
  fill bytes with the byte starting at the string's first for the count.
  put the string's first plus the count minus 1 into the string's last.

to finalize after run:
  if the heap count is 0, exit.
  put the heap count into a count.
  put the count then " drip(s)." into a string.
  debug the string.

to finalize the canvases:
  finalize the memory canvas.
  finalize the screen canvas.

to finalize the cgi:
  call "kernel32.dll" "FreeConsole".

to finalize the colors:

to finalize com:
  call "ole32.dll" "CoUninitialize".

to finalize the cursors:
  call "user32.dll" "DestroyCursor" with the i-beam cursor.
  call "user32.dll" "DestroyCursor" with the hand cursor.
  call "user32.dll" "DestroyCursor" with the arrow cursor.

to finalize the fonts:
  call "gdi32.dll" "RemoveFontMemResourceEx" with the osmosian font resource.

to finalize gdi+:
  call "gdiplus.dll" "GdiplusShutdown" with the gptoken.

to finalize the memory canvas:
  call "gdi32.dll" "SelectObject" with the memory canvas and the saved memory hbitmap returning an hbitmap.
  call "gdi32.dll" "DeleteObject" with the hbitmap.
  call "gdi32.dll" "DeleteDC" with the memory canvas.

to finalize the module:

to finalize the mouse:

to finalize the printer canvas:
  call "kernel32.dll" "GlobalFree" with the printer device mode handle.
  put 0 into the printer canvas.

to finalize the screen:

to finalize the screen canvas:

to finalize a talker:
  if the talker is nil, exit.
  call the talker's vtable's release with the talker.
  put nil into the talker.

to finalize the window:
  call "user32.dll" "DestroyWindow" with the main window.
  loop.
  call "user32.dll" "GetMessageA" with an msg's whereabouts and 0 and 0 and 0 returning a number.
  if the number is less than 1, break.
  call "user32.dll" "TranslateMessage" with the msg's whereabouts.
  call "user32.dll" "DispatchMessageA" with the msg's whereabouts.
  repeat.
  flush the event queue.
  destroy the current event.

to finalize winsock:
  call "ws2_32.dll" "WSACleanup".

the find anchor is an anchor.

to find a dyad given some dyads and a name:
  void the dyad.
  loop.
  get the dyad from the dyads.
  if the dyad is nil, exit.
  if the dyad's name is the name, exit.
  repeat.

to find next given a row and a text and a flag:
  clear the flag.
  if the text is nil, exit.
  if the row is nil, exit.
  slap a substring on the row's string.
  put the substring's first plus the find string's length minus 1 into the substring's last.
  if the row's row# is the find anchor's row#, move the substring given the find anchor's column# minus 1.
  loop.
  if the substring's last is greater than or equal to the row's string's last, exit.
  if the substring is the find string, break.
  move the substring given 1.
  repeat.
  set the flag.
  put the substring's first minus the row's string's first plus 1 into the text's anchor column#.
  put the row's row# into the text's anchor row#.
  put the substring's last minus the row's string's first plus 2 into the text's caret column#.
  put the row's row# into the text's caret row#.

to find next given a text and a flag:
  if the text's wrap flag is set, find next given the text and the flag (wrapped text); exit.
  clear the flag.
  if the text is nil, exit.
  if the find string's length is 0, exit.
  loop.
  get a row from the text's rows.
  if the row is nil, exit.
  if the row's row# is less than the find anchor's row#, repeat.
  find next given the row and the text and the flag.
  if the flag is set, exit.
  repeat.

to find next given a text and a flag (wrapped text):
  clear the flag.
  if the text is nil, exit.
  convert the find anchor to an absolute position called offset given the text.
  extract a string from the text (no linefeed additions).
  put the string's first plus the offset minus 1 into a substring's first.
  put the substring's first plus the find string's length minus 1 into the substring's last.
  loop.
  if the substring's last is greater than the string's last, exit.
  if the substring is the find string, break.
  move the substring given 1.
  repeat.
  set the flag.
  put the substring's first minus the string's first plus 1 into an anchor absolute position.
  put the substring's last minus the string's first plus 2 into a caret absolute position.
  convert the anchor absolute position to the text's anchor given the text.
  convert the caret absolute position to the text's caret given the text.

to find the next misspelling given a row and a text and a flag:
  clear the flag.
  if the text is nil, exit.
  if the row is nil, exit.
  slap a rider on the row's string.
  if the row's row# is the find anchor's row#, add the find anchor's column# minus 1 to the rider's source's first.
  if the rider's source's first is not the row's string's first, skip word characters in the rider's source.
  loop.
  move the rider (spell checking rules).
  if the rider's token is blank, exit.
  if the rider's token is not misspelled, repeat.
  set the flag.
  put the rider's token's first minus the row's string's first plus 1 into the text's anchor column#.
  put the row's row# into the text's anchor row#.
  put the rider's token's last minus the row's string's first plus 2 into the text's caret column#.
  put the row's row# into the text's caret row#.

to find the next misspelling in a text given a flag:
  clear the flag.
  if the text is nil, exit.
  loop.
  get a row from the text's rows.
  if the row is nil, exit.
  if the row's row# is less than the find anchor's row#, repeat.
  find the next misspelling given the row and the text and the flag.
  if the flag is set, exit.
  repeat.

to find a pdf object given a kind:
  void the pdf object.
  loop.
  get the pdf object given the pdf state's objects.
  if the pdf object is nil, break.
  if the pdf object's kind is the kind, break.
  repeat.

to find a pointer given a string and an index:
  find a refer given the string and the index.
  if the refer is not nil, put the refer's pointer into the pointer; exit.
  void the pointer.

to find a refer given a string and an index:
\  if the index is nil, exit. \ to make compiler faster
  if the string is blank, void the refer; exit.
  get a bucket given the string and the index.
  find the refer given the string and the bucket's refers.

to find a refer given a string and some refers:
  void the refer.
  loop.
  get the refer from the refers.
  if the refer is nil, exit.
  if the string is the refer's string, exit.
  repeat.

to find a sector given a grid and a spot:
  put the spot's x divided by the grid's x times the grid's x into the sector's x.
  put the spot's y divided by the grid's y times the grid's y into the sector's y.

to find a string given some string things and a string#:
  clear the string.
  loop.
  get a string thing from the string things.
  if the string thing is nil, exit.
  add 1 to a count.
  if the count is not the string#, repeat.
  put the string thing's string into the string.

the find string is a string.

to find a string thing given a string and some string things:
  void the string thing.
  loop.
  get the string thing given the string things.
  if the string thing is nil, break.
  if the string thing's string is the string, break.
  repeat.

to find a substring in a string given another string:
  slap the substring on the string.
  loop.
  if the substring is blank, exit.
  if the substring starts with the other string, break.
  add 1 to the substring's first.
  repeat.
  put the substring's first plus the other string's length minus 1 into the substring's last.

to find a value string given some dyads and a name:
  find a dyad given the dyads and the name.
  if the dyad is nil, clear the value; exit.
  put the dyad's value into the value.

to find a value string given the environment variables and a name:
  privatize the name.
  null terminate the name.
  put 32767 into a length. \ max size for environment variable
  reassign the value's first given the length.
  call "kernel32.dll" "GetEnvironmentVariableA" with the name's first and the value's first and the length returning the length.
  put the value's first plus the length minus 1 into the value's last.

a finger is a byte pointer.

the five byte is a byte equal to 53.

the five key is a key equal to 53.

a flag has 4 bytes.

to flip the gpbitmap in a picture:
  if the picture is nil, exit.
  reverse the picture's mirror flag.
  add 1800 to the picture's rotate angle.
  normalize the picture's rotate angle.
  flip the picture's gpbitmap.

to flip a gpimage:
  call "gdiplus.dll" "GdipImageRotateFlip" with the gpimage and 6 [rotatenoneflipy aka rotate180flipx].

to flip a picture:
  if the picture is nil, exit.
  put the picture's box's center's y minus the picture's uncropped box's center's y into a pair's y.
  multiply the pair's y by 2.
  move the picture's uncropped box given the pair.
  flip the gpbitmap in the picture.

to flip a polygon:
  if the polygon is nil, exit.
  put the polygon's box into a box.
  loop.
  get a vertex from the polygon's vertices.
  if the vertex is nil, exit.
  subtract the box's top from the vertex's y.
  put the box's bottom minus the vertex's y into the vertex's y.
  repeat.

to flip a ratio:
  swap the ratio's numerator with the ratio's denominator.

to flush all events:
  flush any messages.
  flush the event queue.

to flush any messages:
  call "user32.dll" "PeekMessageA" with an msg's whereabouts and 0 and 0 and 0 and 1 [pm_remove] returning a number.
  if the number is 0, exit.
  if the msg's message is 15 [wm_paint], call "user32.dll" "ValidateRect" with the main window and 0.
  repeat.

to flush an event queue:
  get an event from the event queue.
  if the event is nil, exit.
  remove the event from the event queue.
  destroy the event.
  repeat.

a font has a name and a height.

a font info is a thing with \ used for pdf conversion
  a font,
  an emsquare number,
  an internal leading number,
  a flags number,
  an ascent number,
  a descent number,
  a capheight number,
  an italicangle number,
  a stemv number,
  a font box,
  some font widths.

a font resource is a handle.

some font widths is a thing with \ used for pdf conversion
  a font,
  a count,
  a number pointer called data.

an foot is 12 inches.

the form-feed byte is a byte equal to 12.

to format a number and a singular string or a plural string into a string:
  convert the number to the string.
  append the space byte to the string.
  if the number is 1, append the singular to the string.
  if the number is not 1, append the plural to the string.

the four byte is a byte equal to 52.

the four key is a key equal to 52.

the g-key is a key equal to 71.

a gcd is a number.

a gcpresults is a record with
  a number called lstructsize,
  a pchar called lpoutstring,
  a number pointer called lporder,
  a number pointer called lpdx,
  a number pointer called lpcaretpos,
  a pointer called lpclass,
  a pointer called lpglyphs,
  a number called nglyphs,
  a number called maxfit.

a gdiplusstartupinput is a record with
  a number called gdiplusversion,
  a pointer called debugeventcallback,
  a number called suppressbackgroundthread,
  a number called suppressexternalcodecs.

to get an abca and an abcc given a string and a canvas:
  put 0 into the abca.
  put 0 into the abcc.
  if the string's length is less than 1, exit.
  call "gdi32.dll" "GetCharABCWidthsA" with the canvas and the string's first's target and the string's first's target and an abc's whereabouts.
  put the abc's abca into the abca.
  call "gdi32.dll" "GetCharABCWidthsA" with the canvas and the string's last's target and the string's last's target and another abc's whereabouts.
  put the other abc's abcc into the abcc.

to get an abca given a string and a canvas:
  put 0 into the abca.
  if the string's length is less than 1, exit.
  call "gdi32.dll" "GetCharABCWidthsA" with the canvas and the string's first's target and the string's first's target and an abc's whereabouts.
  put the abc's abca into the abca.

to get some addrinfo routines:
  clear the i/o error.
  call "kernel32.dll" "LoadLibraryA" with "ws2_32.dll"'s first returning a handle.
  if the handle is 0, put "Could not load ws2_32.dll" into the i/o error; exit.
  call "kernel32.dll" "GetProcAddress" with the handle and "getaddrinfo"'s first returning a pointer.
  if the pointer is nil, put "Sorry these routines only work on Windows XP and up." into the i/o error; exit.
  put the pointer into the addrinfo routines' getaddrinfo pointer.
  call "kernel32.dll" "GetProcAddress" with the handle and "freeaddrinfo"'s first returning the pointer.
  if the pointer is nil, put "Sorry these routines only work on Windows XP and up." into the i/o error; exit.
  put the pointer into the addrinfo routines' freeaddrinfo pointer.

to get a box for the caret in a text:
  if the text is nil, clear the box; exit.
  get a spot given the text's caret and the text.
  put the spot and the spot into the box.
  add the text's row height to the box's bottom.
  adjust the box given 0 and the tpp and 0 and - the tpp.
  put the text's globalized origin into an origin.
  if the box's left is less than the origin's x, put the origin's x into the box's left; put the origin's x into the box's right.
  if the text's wrap flag is not set, exit.
  limit the box's left to the text's left and the text's right.
  limit the box's right to the text's left and the text's right.

to get a box given a row and a text:
  if the text is nil, clear the box; exit.
  if the row is nil, clear the box; exit.
  put the text's globalized origin into the box's left-top.
  add the row's row# minus 1 times the text's row height to the box's top.
  put the text's right into the box's right.
  put the box's top plus the text's row height into the box's bottom.

to get a bucket given a bucket# and an index:
\  if the index is nil, void the bucket; exit. \ to make compiler faster
  put the index's first bucket into the bucket.
  add the bucket# times a bucket record's magnitude to the bucket.

to get a bucket given an index:
\  if the index is nil, void the bucket; exit. \ to make compiler faster
  if the bucket is nil, put the index's first bucket into the bucket; exit.
  if the bucket is the index's last bucket, void the bucket; exit.
  add a bucket record's magnitude to the bucket.

to get a bucket given a string and an index:
\  if the index is nil, void the bucket; exit. \ to make compiler faster
  get a bucket# given the string and the index.
  get the bucket given the bucket# and the index.

to get a bucket# given a string and an index: \ based on the djb2 algorithm
\  if the index is nil, put 0 into the bucket#; exit. \ to make compiler faster
  put the string's length into the bucket#.
  if the bucket# is 0, exit.
  add 5381 to the bucket#.
  slap a substring on the string.
  loop.
  put the substring's first's target into a byte.
  lowercase the byte.
  put the bucket# into a number.
  shift the bucket# left 5 bits.
  add the number to the bucket#.
  add the byte to the bucket#.
  add 3 to the substring's first.
  if the substring is blank, break.
  repeat.
  bitwise and the bucket# with the largest number.
  divide the bucket# by the index's bucket count giving a quotient and the bucket#.

to get a center spot given a spot and another spot:
  put the spot and the other spot into a line.
  put the line's center into the center.

to get a color given a spot:
  call "gdi32.dll" "GetPixel" with the current canvas and the spot's x and the spot's y returning a colorref.
  convert the colorref to the color.

to get a column# given a row and a spot and a text:
  put 0 into the column#.
  if the text is nil, exit.
  if the row is nil, exit.
  get a box given the row and the text.
  if the spot's y is greater than the box's bottom, put the row's string's length into the column#; exit. \ only happens on last row of text
  create the hfont of the memory canvas given the text's font.
  get a start width and a substring given the row and the spot and the text (for "get a column# given a row...").
  loop.
  if the substring's last is the row's string's last, break.
  get a width given the substring and the memory canvas.
  add the start width to the width.
  get another width given the substring's last's target and the memory canvas.
  divide the other width by 2.
  subtract the other width from the width.
  if the spot's x is less than the width, break.
  add 1 to the substring's last.
  repeat.
  put the substring's last minus the row's string's first plus 1 into the column#.
  destroy the hfont of the memory canvas.

to get a count of items in a path in the file system:
  put 0 into the count.
  loop.
  get an item from the path.
  if the item is not found, exit.
  add 1 to the count.
  repeat.

to get a difference between a pair and another pair:
  put the pair into the difference.
  subtract the other pair from the difference.

to get a difference between a pair and another pair given a grid pair:
  get the difference between the pair and the other pair.
  round the difference to the grid.

to get a distance between a spot and another spot (chessboard):
  put the spot's x minus the other spot's x into a number.
  de-sign the number.
  put the spot's y minus the other spot's y into another number.
  de-sign the other number.
  put the number into the distance.
  if the other number is greater than the number, put the other number into the distance.

to get a drive kind for a path:
  privatize the path.
  null terminate the path.
  call "kernel32.dll" "GetDriveTypeA" with the path's first returning a number.
  if the number is 2 [drive_removable], put "removable" into the drive kind; exit.
  if the number is 3 [drive_fixed], put "fixed" into the drive kind; exit.
  if the number is 4 [drive_remote], put "remote" into the drive kind; exit.
  if the number is 5 [drive_cdrom], put "cd-rom" into the drive kind; exit.
  if the number is 6 [drive_ramdisk], put "ram disk" into the drive kind; exit.
  put "" into the drive kind.

to get a gcd given a number and another number:
  put the number into a dividend number.
  put the other number into the gcd.
  de-sign the dividend number.
  de-sign the gcd.
  if the dividend is less than the gcd, swap the dividend with the gcd.
  if the gcd is 0, put 1 into the gcd; exit.
  loop.
  divide the dividend by the gcd giving a quotient and a remainder.
  if the remainder is 0, exit.
  put the gcd into the dividend.
  put the remainder into the gcd.
  repeat.

to get an ip address given a host string:
  clear the ip address.
  get a sockaddr given the host string.
  if the i/o error is not blank, exit.
  put the sockaddr's sin_addr's s_addr into the ip address' number.
  call "ws2_32.dll" "inet_ntoa" with the ip address' number returning a pchar.
  convert the pchar to the ip address' string.

to get an item (not first time):
  clear the i/o error.
  call "kernel32.dll" "FindNextFileA" with the item's handle and the item's win32finddata's whereabouts returning a number.
  if the number is not 0, adjust the item; exit.
  clear the item's kind.
  call "kernel32.dll" "FindClose" with the item's handle.

to get an item from a path:
  if the path is not directory-format, exit.
  put the path into the item's directory.
  if the item's kind is blank, get the item from the path (first time); exit.
  get the item (not first time).

to get an item from a path (first time):
  clear the i/o error.
  privatize the path.
  append "*.*" to the path.
  null terminate the path.
  clear the item's kind.
  call "kernel32.dll" "FindFirstFileA" with the path's first and the item's win32finddata's whereabouts returning the item's handle.
  if the item's handle is -1 [invalid_handle_value], exit.
  adjust the item.

to get an lcm given a number and another number:
  get a gcd given the number and the other number.
  call "kernel32.dll" "MulDiv" with the number and the other number and the gcd returning the lcm.

to get an offset pair given a string and a box and a font and an alignment:
  create the hfont of the memory canvas given the font.
  get the offset pair given the string and the box and the font and the alignment (fast).
  destroy the hfont of the memory canvas.

to get an offset pair given a string and a box and a font and an alignment (fast):
  if the alignment is "left", get the offset pair's x given the string and the box (fast - left).
  if the alignment is "right", get the offset pair's x given the string and the box  (fast - right).
  if the alignment is "center", get the offset pair's x given the string and the box (fast - center).
  call "gdi32.dll" "GetTextMetricsA" with the memory canvas and a textmetric's whereabouts.
  add the box's height minus the textmetric's tmheight divided by 2 to the offset pair's y.

to get an outlinetextmetric given a font:
  create the hfont of the memory canvas given the font.
  call "gdi32.dll" "GetOutlineTextMetricsA" with the memory canvas and 0 and 0 returning a result number.
  assign a poutlinetextmetric given the result.
  call "gdi32.dll" "GetOutlineTextMetricsA" with the memory canvas and the result and the poutlinetextmetric.
  put the poutlinetextmetric's target into the outlinetextmetric.
  destroy the hfont of the current canvas.
  unassign the poutlinetextmetric.

to get a position given a spot and a text:
  if the text is nil, clear the position; exit.
  get a row given the spot and the text.
  put the row's row# into the position's row#.
  get the position's column# given the row and the spot and the text.

to get a rgb pointer from a bitmapdata at a row# and a column#: \ 1 based
  put the bitmapdata's scan0 into the rgb pointer.
  add the row# minus 1 times the bitmapdata's stride to the rgb pointer.
  add the column# minus 1 times a rgb's magnitude to the rgb pointer.

to get a row given a row# and a text:
  void the row.
  if the text is nil, exit.
  loop.
  get the row from the text's rows.
  if the row is nil, exit.
  if the row's row# is the row#, exit.
  repeat.

to get a row given a spot and a text:
  if the text is nil, void the row; exit.
  put the spot's y into a y coord.
  limit the y to the text's top and the text's bottom.
  put the y minus the text's globalized origin's y divided by the text's row height plus 1 into a row#.
  limit the row# to 1 and the text's row count.
  get the row given the row# and the text.

to get a selection box given a row and a text:
  clear the selection box.
  if the text is nil, exit.
  if the row is nil, exit.
  get a box given the row and the text.
  put the box into the selection box.
  get the selection box given the row and the text (left side).
  get the selection box given the row and the text (right side).

to get a selection box given a row and a text (left side):
  put the text's normalized selection into a selection.
  put the text's globalized origin's x into the selection box's left.
  if the selection's anchor row# is the row's row#, get a spot given the selection's anchor and the text; put the spot's x into the selection box's left.
  limit the selection box's left to the text's left and the text's right.

to get a selection box given a row and a text (right side):
  put the text's normalized selection into a selection.
  put the text's right into the selection box's right.
  if the selection's caret row# is the row's row#, get a spot given the selection's caret and the text; put the spot's x into the selection box's right.
  limit the selection box's right to the text's left and the text's right.

to get a size given a path in the file system:
  if the path is directory-format, get the size given the path in the file system (directory).
  if the path is file-format, get the size given the path in the file system (file).

to get a size given a path in the file system (directory):
  put 0 into the size.
  loop.
  get an item from the path.
  if the item is not found, exit.
  if the item's kind is "file", add the item's size to the size; repeat.
  put the path into another path.
  append the item's designator to the other path.
  get another size given the other path in the file system.
  add the other size to the size.
  repeat.

to get a size given a path in the file system (file):
  privatize the path.
  null terminate the path.
  call "kernel32.dll" "GetFileAttributesExA" with the path's first and 0 and a win32finddata's whereabouts.
  put the win32finddata's nfilesizelow into the size.

to get a sockaddr given a host string:
  clear the i/o error.
  \ prepare strings
  privatize the host string.
  null terminate the host string.
  \ get the function addresses
  get some addrinfo routines.
  if the i/o error is not blank, exit.
  \ get the sockaddr
  put 2 [af_inet] into a addrinfo's ai_family.
  put 1 [sock_stream] into the addrinfo's ai_sockettype.
  put 6 [ipproto_tcp] into the addrinfo's ai_protocol.
  call the addrinfo routines' getaddrinfo with the host string's first and 0 and the addrinfo's whereabouts and a addrinfoptr's whereabouts returning a result number.
  if the result number is not 0, put "Could not resolve host name '" then the host then "'." into the i/o error; exit.
  if the addrinfoptr is nil, put "Could not resolve host name '" then the host then "'." into the i/o error; exit.
  put the addrinfoptr's ai_addr's target into the sockaddr.
  call the addrinfo routines' freeaddrinfo with the addrinfoptr.

to get a spot given a position and a text:
  clear the spot.
  if the text is nil, exit.
  get a row given the position's row# and the text.
  get a box given the row and the text.
  put the box's top into the spot's y.
  put the row's string's first into a substring's first.
  put the substring's first plus the position's column# minus 2 into the substring's last.
  get a width given the substring and the memory canvas and the text's font.
  put the box's left plus the width into the spot's x.
  get an offset pair given the row's working string and the box and the text's font and the text's alignment.
  add the offset pair's x to the spot's x.

to get a start width and a substring given a row and a spot and a text (for "get a column# given a row..."):
  clear the start width.
  clear the substring.
  if the text is nil, exit.
  if the row is nil, exit.
  get a box given the row and the text.
  slap the substring on the row's working string.
  get an offset pair given the substring and the box and the text's font and the text's alignment (fast).
  put the text's globalized origin's x plus the offset pair's x into the start width.
  put the substring's first plus the text cutoff minus 1 into the substring's last.
  loop.
  if the substring's last is greater than or equal to the row's string's last, break.
  get a width given the substring and the memory canvas.
  put the start width plus the width into another width.
  if the spot's x is less than or equal to the other width, break.
  add the width to the start width.
  move the substring given the text cutoff.
  repeat.
  put the substring's first into the substring's last.

to get a string from the windows clipboard:
  clear the string.
  call "user32.dll" "OpenClipboard" with the main window.
  call "user32.dll" "GetClipboardData" with 1 [cf_text] returning a handle.
  if the handle is 0, call "user32.dll" "CloseClipboard"; exit.
  call "kernel32.dll" "GlobalLock" with the handle returning a pchar.
  convert the pchar to the string.
  call "kernel32.dll" "GlobalUnlock" with the handle.
  call "user32.dll" "CloseClipboard".

to get a thing from some things:
  if the things are empty, void the thing; exit.
  if the thing is nil, put the things' first into the thing; exit.
  put the thing's next into the thing.

to get a thing from some things (backwards):
  if the things are empty, void the thing; exit.
  if the thing is nil, put the things' last into the thing; exit.
  put the thing's previous into the thing.

to get a width given a byte and a canvas:
  call "gdi32.dll" "GetTextExtentPoint32A" with the canvas and the byte's whereabouts and 1 and a pair's whereabouts.
  put the pair's x into the width.

to get a width given a byte and some font widths:
  put the byte into a number.
  get the width given the number and the font widths.

to get a width given a number and some font widths: \ indexes are 0 based
  if the font widths are nil, clear the width; exit.
  put the font widths' data into a number pointer.
  add the number times the number's magnitude to the number pointer.
  put the number pointer's target into the width.

to get a width given a string and a canvas: \ assumes font is already selected in canvas
  call "gdi32.dll" "GetTextExtentPoint32A" with the canvas and the string's first and the string's length and a pair's whereabouts.
  put the pair's x into the width.

to get a width given a string and a canvas and a font:
  create the hfont of the canvas given the font.
  get the width given the string and the canvas.
  destroy the hfont of the canvas.

to get a width given a string and a font: \ assumes memory canvas
  get the width given the string and the memory canvas and the font.

to get an x coord given a string and a box (fast - center):
  get a width given the string and the memory canvas.
  get an abca and an abcc given the string and the memory canvas.
  put the width minus the abca minus the abcc into the width.
  put the box's width minus the width divided by 2 minus the abca into the x.

to get an x coord given a string and a box (fast - left):
  get an abca given the string and the memory canvas.
  put - the abca into the x.

to get an x coord given a string and a box (fast - right):
  get an abca and an abcc given the string and the memory canvas.
  get a width given the string and the memory canvas.
  put the width minus the abca minus the abcc into the width.
  put the box's width minus the width minus the abca into the x.

a gigabyte is 1024 megabytes.

to globalize a box given a pair:
  move the box given the pair.

to globalize a spot given a pair:
  move the spot given the pair.

a gpbitmap is a gpimage.

a gpgraphic is a pointer.

a gpimage is a pointer.

a gpimageattributes is a pointer.

a gprect is a record with
  a number called x,
  a number called y,
  a number called width,
  a number called height.

the gptoken is a gptoken.

a gptoken is a number.

the gray color is a color.

the grayscale color matrix is a hex string equal to $8716993E8716993E8716993E0000000000000000A245163FA245163FA245163F0000000000000000D578E93DD578E93DD578E93D00000000000000000000000000000000000000000000803F00000000000000000000000000000000000000000000803F.

the green color is a color.

a grid is a pair.

the group-separator byte is a byte equal to 29.

to guarantee one row in a text:
  if the text is nil, exit.
  if the text's rows are not empty, exit.
  create a row given the return byte.
  append the row to the text's rows.
  renumber the text's rows.

a guid is a uuid.

the h-key is a key equal to 72.

the hand cursor is a cursor.

to handle align given a text and an alignment:
  if the text is nil, exit.
  remember the text with "alignment".
  align the text given the alignment.

to handle any wm-activate with a w-param:
  split the w-param into a wyrd and another wyrd.
  put the other wyrd into a number.
  if the number is 0, handle any wm-activate with the w-param (deactivate); exit.
  handle any wm-activate with the w-param (activate).

to handle any wm-activate with a w-param (activate):
  call "user32.dll" "SetFocus" with the main window.
  call "user32.dll" "ClipCursor" with 0.
\  seterrormode(sem_failcriticalerrors) \ keeps certain disk errors from appearing
  create an event.
  put "activate" into the event's kind.
  enque the event.
  call "user32.dll" "PostMessageA" with the main window and 0 [wm_null] and 0 and 0.

to handle any wm-activate with a w-param (deactivate):
  create an event.
  put "deactivate" into the event's kind.
  enque the event.
  call "user32.dll" "PostMessageA" with the main window and 0 [wn_null] and 0 and 0.

to handle any wm-char with a w-param and an l-param:
  if the alt key was down, exit.
  if the ctrl key was down, exit.
  put the w-param into a byte.
  if the byte is not printable, exit.
  create an event.
  put "key down" into the event's kind.
  if the shift key was down, set the event's shift flag.
  put the byte into the event's byte.
  convert the l-param to the event's key.
  enque the event.

to handle any wm-create with a window:
  put the window into the main window.

to handle any wm-destroy:
  call "user32.dll" "PostQuitMessage" with 0.

to handle any wm-keydown with a w-param and an l-param:
  put the w-param into a key.
  if the key with the l-param is any repeated escape or modifier key, exit.
  if the key is any wm-char key, exit.
  create an event.
  put "key down" into the event's kind.
  if the alt key was down, set the event's alt flag.
  if the ctrl key was down, set the event's ctrl flag.
  if the shift key was down, set the event's shift flag.
  put the key into the event's key.
  enque the event.

to handle any wm-lbuttondblclk with a l-param:
  create an event.
  put "left double click" into the event's kind.
  if the alt key was down, set the event's alt flag.
  if the ctrl key was down, set the event's ctrl flag.
  if the shift key was down, set the event's shift flag.
  convert the l-param to the event's spot.
  enque the event.

to handle any wm-lbuttondown with a l-param:
  create an event.
  put "left click" into the event's kind.
  if the alt key was down, set the event's alt flag.
  if the ctrl key was down, set the event's ctrl flag.
  if the shift key was down, set the event's shift flag.
  convert the l-param to the event's spot.
  enque the event.

to handle any wm-paint with a window:
  call "user32.dll" "BeginPaint" with the window and a paintstruct's whereabouts.
  call "user32.dll" "EndPaint" with the window and the paintstruct's whereabouts.
  create an event.
  put "refresh" into the event's kind.
  enque the event.

to handle any wm-rbuttondblclk with a l-param:
  create an event.
  put "right double click" into the event's kind.
  if the alt key was down, set the event's alt flag.
  if the ctrl key was down, set the event's ctrl flag.
  if the shift key was down, set the event's shift flag.
  convert the l-param to the event's spot.
  enque the event.

to handle any wm-rbuttondown with a l-param:
  create an event.
  put "right click" into the event's kind.
  if the alt key was down, set the event's alt flag.
  if the ctrl key was down, set the event's ctrl flag.
  if the shift key was down, set the event's shift flag.
  convert the l-param to the event's spot.
  enque the event.

to handle any wm-setcursor:
  refresh the cursor.

to handle any wm-syskeydown with a w-param and an l-param: employ handle any wm-keydown with a w-param and an l-param.

to handle capitalize given a text:
  if the text is nil, exit.
  if nothing is selected in the text, exit.
  remember the text with "capitalize".
  capitalize any selected rows in the text.
  square up any selection in the text.
  wrap the text.

to handle copy given a text:
  if the text is nil, exit.
  if nothing is selected in the text, exit.
  extract a string from the text (selected bytes).
  put the string on the windows clipboard.

to handle cut given a text:
  if the text is nil, exit.
  if nothing is selected in the text, exit.
  remember the text.
  extract a string from the text (selected bytes).
  put the string on the windows clipboard.
  remove any selected bytes in the text.
  wrap the text.
  scroll the text to the caret.

to handle an event given a console:
  if the console is nil, exit.
  if the event's kind is "key down", handle the event given the console (key down); exit.
  if the event's kind is "refresh", handle the event given the console (refresh); exit.
  if the event's kind is "right click", handle the event given the console (right click); exit.
  if the event's kind is "set cursor", handle the event given the console (set cursor); exit.

to handle an event given a console (backspace key):
  if the console's reply is blank, exit.
  if the event is modified, exit.
  handle the event given the console's text (backspace key).
  remove the last byte from the console's reply.
  show the console.

to handle an event given a console (down-arrow key):
  scroll the console's text down one line.
  show the console.

to handle an event given a console (end key):
  scroll the console's text to the bottom.
  show the console.

to handle an event given a console (enter key):
  handle the event given the console's text (enter key).
  relinquish control.

to handle an event given a console (home key):
  scroll the console's text to the top.
  show the console.

to handle an event given a console (key down):
  if the event's key is the backspace key, handle the event given the console (backspace key); exit.
  if the event's key is the down-arrow key, handle the event given the console (down-arrow key); exit.
  if the event's key is the end key, handle the event given the console (end key); exit.
  if the event's key is the enter key, handle the event given the console (enter key); exit.
  if the event's key is the home key, handle the event given the console (home key); exit.
  if the event's key is the page-down key, handle the event given the console (page-down key); exit.
  if the event's key is the page-up key, handle the event given the console (page-up key); exit.
  if the event's key is the up-arrow key, handle the event given the console (up-arrow key); exit.
  if the event's byte is not printable, exit.
  append the event's byte to the console's reply.
  handle the event given the console's text (printable key).
  show the console.

to handle an event given a console (page-down key):
  scroll the console's text down one page.
  show the console.

to handle an event given a console (page-up key):
  scroll the console's text up one page.
  show the console.

to handle an event given a console (refresh):
  show the console.

to handle an event given a console (right click):
  show the hand cursor.
  scroll the console given the event.
  refresh the cursor.

to handle an event given a console (set cursor):
  show the arrow cursor.

to handle an event given a console (up-arrow key):
  scroll the console's text up one line.
  show the console.

to handle an event given a text (backspace key):
  if the text is nil, exit.
  if there is nothing to backspace in the text, exit.
  remember the text with "backspace".
  if the event is modified, remove bytes from the text (backspace with jump).
  if the event is not modified, remove bytes from the text (backspace).
  wrap the text.
  scroll the text to the caret.

to handle an event given a text (delete key):
  if the text is nil, exit.
  if there is nothing to remove in the text, exit.
  remember the text with "delete".
  if the event is modified, remove bytes from the text (forward delete with jump).
  if the event is not modified, remove bytes from the text (forward delete).
  wrap the text.
  scroll the text to the caret.

to handle an event given a text (down-arrow key):
  if the text is nil, exit.
  if the caret of the text is on the last line, set a flag.
  if the flag is set, move the caret to the last byte of the text.
  if the flag is not set, move the caret down in the text.
  if the event's shift flag is not set, deselect the text.
  clear the text's last operation.
  scroll the text to the caret.

to handle an event given a text (end key):
  if the text is nil, exit.
  if the event is modified, move the caret to the last byte of the text.
  if the event is not modified, move the caret to the last byte of the current row of the text.
  if the event's shift flag is not set, deselect the text.
  clear the text's last operation.
  scroll the text to the caret.

to handle an event given a text (enter key):
  if the text is nil, exit.
  remember the text with "insert return".
  remove any selected bytes in the text.
  insert the return byte into the text.
  wrap the text.
  scroll the text to the caret.

to handle an event given a text (escape key):
  if the text is nil, exit.
  deselect the text.

to handle an event given a text (home key):
  if the text is nil, exit.
  if the event is modified, move the caret to the first byte of the text.
  if the event is not modified, move the caret to the first byte of the current row of the text.
  if the event's shift flag is not set, deselect the text.
  clear the text's last operation.
  scroll the text to the caret.

to handle an event given a text (left double click):
  if the text is nil, exit.
  deselect the text.
  move the caret right to any non-alphanumeric byte in the text.
  move the anchor left to any non-alphanumeric byte in the text.

to handle an event given a text (left-arrow key):
  if the text is nil, exit.
  if the event is modified, jump the caret left in the text.
  if the event is not modified, move the caret left in the text.
  if the event's shift flag is not set, deselect the text.
  clear the text's last operation.
  scroll the text to the caret.

to handle an event given a text (page-down key):
  if the text is nil, exit.
  scroll the text down one page.
  move the caret down one page in the text.
  if the event's shift flag is not set, deselect the text.
  clear the text's last operation.

to handle an event given a text (page-up key):
  if the text is nil, exit.
  scroll the text up one page.
  move the caret up one page in the text.
  if the event's shift flag is not set, deselect the text.
  clear the text's last operation.

to handle an event given a text (printable key):
  remember the text with "insert".
  remove any selected bytes in the text.
  insert the event's byte into the text.
  wrap the text.
  scroll the text to the caret.

to handle an event given a text (right-arrow key):
  if the text is nil, exit.
  if the event is modified, jump the caret right in the text.
  if the event is not modified, move the caret right in the text.
  if the event's shift flag is not set, deselect the text.
  clear the text's last operation.
  scroll the text to the caret.

to handle an event given a text (tab key):
  if the text is nil, exit.
  remember the text with "insert".
  remove any selected bytes in the text.
  insert the space byte into the text.
  divide the text's caret column# by 2 giving a quotient and a remainder.
  if the remainder is 0, insert the space byte into the text.
  scroll the text to the caret.

to handle an event given a text (up-arrow key):
  if the text is nil, exit.
  move the caret up in the text.
  if the event's shift flag is not set, deselect the text.
  clear the text's last operation.
  scroll the text to the caret.

to handle events given a console:
  if the console is nil, exit.
  loop.
  deque an event.
  if the event is nil, exit.
  handle the event given the console.
  repeat.

to handle font height given a text and a box and a font height:
  if the text is nil, exit.
  remember the text with "font height".
  change the text given the box.
  change the text given the font height.

to handle font height given a text and a font height:
  if the text is nil, exit.
  remember the text with "font height".
  change the text given the font height.

to handle font name given a text and a font name:
  if the text is nil, exit.
  remember the text with "font name".
  change the text given the font name.

to handle indent given a text:
  if the text is nil, exit.
  if nothing is selected in the text, exit.
  remember the text with "dent".
  indent any selected rows in the text.
  square up any selection in the text.
  wrap the text.

a handle is a number.

to handle lowercase given a text:
  if the text is nil, exit.
  if nothing is selected in the text, exit.
  remember the text with "case".
  lowercase any selected bytes in the text.
  wrap the text.

to handle outdent given a text:
  if the text is nil, exit.
  if nothing is selected in the text, exit.
  remember the text with "dent".
  outdent any selected rows in the text.
  square up any selection in the text.
  wrap the text.

to handle paste given a text:
  if the text is nil, exit.
  if there is not text on the windows clipboard, exit.
  remember the text.
  remove any selected bytes in the text.
  get a string from the windows clipboard.
  insert the string into the text.
  wrap the text.
  scroll the text to the caret.

to handle pen given a text and a color:
  if the text is nil, exit.
  remember the text with "pen".
  put the color into the text's pen.

to handle redo given a text:
  if the text is nil, exit.
  if the text's redos' last is nil, exit.
  copy the text into another text.
  append the other text to the text's undos.
  put the text's redos' last into a third text.
  remove the third text from the text's redos.
  copy the guts of the third text into the text.
  destroy the third text.
  set the text's modified flag.

to handle reverse given a text:
  if the text is nil, exit.
  if nothing is selected in the text, exit.
  remember the text with "reverse".
  reverse any selected rows of the text.
  square up any selection in the text.
  wrap the text.

to handle select all given a text:
  if the text is nil, exit.
  select every byte in the text.

to handle sort any selected rows given a text:
  if the text is nil, exit.
  if nothing is selected in the text, exit.
  remember the text with "sort selected rows".
  sort any selected rows in the text.
  square up any selection in the text.
  wrap the text.

to handle undo given a text:
  if the text is nil, exit.
  if the text's undos' last is nil, exit.
  copy the text into another text.
  append the other text to the text's redos.
  put the text's undos' last into a third text.
  remove the third text from the text's undos.
  copy the guts of the third text into the text.
  destroy the third text.
  set the text's modified flag.

to handle uppercase given a text:
  if the text is nil, exit.
  if nothing is selected in the text, exit.
  remember the text with "case".
  uppercase any selected bytes in the text.
  wrap the text.

an hbitmap is a handle.

an hbrush is a handle.

an hdc is a handle.

the heap count is a number.

the heap pointer is a pointer.

a height is some twips.

a hex string is a string.

an hfont is a handle.

an hicon is a handle.

to hide the cursor:
  call "user32.dll" "ShowCursor" with 0 returning a number.
  if the number is less than 0, exit.
  repeat.

the hilite color is a color.

the home key is a key equal to 36.

an hour is 60 minutes.

an hpen is a handle.

an hrgn is a handle.

a hue is an angle [0 to 3600].

a hundred is 100 units.

the i-beam cursor is a cursor.

the i-key is a key equal to 73.

the i/o error is a string.

a iid is a uuid.

an inch is 1440 twips.

to include a font in the current pdf: 
  find a pdf object given the font's name and the pdf state's font index.
  if the pdf object is not nil, exit.
  create a font info given the font.
  convert the font info to pdf em units.
  \ stream
  put the actual data of the font into a buffer.
  convert the buffer to a nibble string.
  add a stream pdf object given "font stream".
  append the stream's number then " 0 obj" to the stream.
  append "<<" to the stream without advancing.
  append "/Filter /ASCIIHexDecode" to the stream without advancing.
  append " /Length " then the nibble string's length to the stream without advancing.
  append " /Length1 " then the buffer's length to the stream without advancing.
  append ">>" to the stream.
  append "stream" to the stream.
  append the nibble string to the stream.
  append "endstream" to the stream.
  append "endobj" to the stream.
  \ descriptor
  add a descriptor pdf object given "font descriptor".
  put "F" then the descriptor's number into a font name.
  put the font's name into a font base name.
  replace the space byte with the underscore byte in the font base name.
  append the descriptor's number then " 0 obj" to the descriptor.
  append "<<" to the descriptor.
  append "/Type /FontDescriptor" to the descriptor.
  append "/FontName /" then the font base name to the descriptor.
  append "/FontFile2 " then the stream's number then " 0 R" to the descriptor.
  append "/Flags " then the font info's flags to the descriptor.
  append "/FontBBox [" then the font info's font box then "]" to the descriptor.
  append "/Ascent " then the font info's ascent to the descriptor.
  append "/Descent " then the font info's descent to the descriptor.
  append "/CapHeight " then the font info's capheight to the descriptor.
  append "/ItalicAngle " then the font info's italicangle to the descriptor.
  append "/StemV " then the font info's stemv to the descriptor.
  append ">>" to the descriptor.
  append "endobj" to the descriptor.
  \ definition
  add a definition pdf object given "font definition".
  put the font name into the definition's font name.
  append the definition's number then " 0 obj" to the definition.
  append "<<" to the definition.
  append "/Type /Font" to the definition.
  append "/Subtype /TrueType" to the definition.
  append "/Name /" then the font name to the definition.
  append "/BaseFont /" then the font base name to the definition.
  append "/Encoding /WinAnsiEncoding" to the definition.
  append "/FontDescriptor " then the descriptor's number then " 0 R" to the definition.
  append "/FirstChar 0" to the definition.
  append "/LastChar 255" to the definition.
  put the font info's font widths into another buffer.
  append "/Widths [" to the definition.
  append the other buffer then "]" to the definition.
  append ">>" to the definition.
  append "endobj" to the definition.
  put the font info into the definition's font info.
  index the definition given the font's name and the pdf state's font index.

to include a font in a pdf object:
  if the pdf object is nil, exit.
  find a font pdf object given the font's name and the pdf state's font index.
  if the font pdf object is nil, exit.
  put "/" then the font pdf object's font name then " " then the font pdf object's number then " 0 R" into a string.
  find a string thing given the string and the pdf object's font strings.
  if the string thing is not nil, exit.
  create a new string thing given the string.
  append the new string thing to the pdf object's font strings.

to indent any selected rows in a text:
  if the text is nil, exit.
  loop.
  get a row from the text's rows.
  if the row is nil, exit.
  if the row of the text is not selected, repeat.
  if the row is blank, repeat.
  prepend the space byte to the row's string.
  prepend the space byte to the row's string.
  repeat.

to indent a box given a number:
  add the number to the box's left.
  add the number to the box's top.
  subtract the number from the box's right.
  subtract the number from the box's bottom.

an indent is an count.

an index is a thing with
  a bucket count,
  a first bucket and a last bucket.

to index a pointer given a string and an index:
\  if the index is nil, exit. \ to make compiler faster
  if the string's length is 0, exit.
  get a bucket given the string and the index.
  create a refer.
  append the refer to the bucket's refers.
  put the string into the refer's string.
  put the pointer into the refer's pointer.

to index a string in an index:
\  if the index is nil, exit. \ to make compiler faster
  index nil given the string and the index.

to initialize before run:
  call "kernel32.dll" "GetProcessHeap" returning the heap pointer.
  call "kernel32.dll" "LoadLibraryA" with "kernel32.dll"'s first returning a handle.
  if the handle is not 0, call "kernel32.dll" "GetProcAddress" with the handle and "HeapSetInformation"'s first returning a pointer.
  if the pointer is not nil, call the pointer with the heap pointer and 0 and 2's whereabouts and 4.

to initialize the canvases:
  initialize the screen canvas.
  initialize the memory canvas.
  put the memory canvas into the current canvas.

to initialize the cgi:
  call "kernel32.dll" "AllocConsole".
  call "kernel32.dll" "GetStdHandle" with -10 [std_input_handle] returning the stdin handle.
  call "kernel32.dll" "GetStdHandle" with -11 [std_output_handle] returning the stdout handle.

to initialize the colors:
  call "gdi32.dll" "GetStockObject" with 8 [null_pen] returning the null hpen.
  call "gdi32.dll" "GetStockObject" with 5 [null_brush] returning the null hbrush.
  put -1 and 0 and 0 into the clear color.
  put 0 and 0 and 1000 into the white color.
  put 0 and 0 and 875 into the lightest gray color.
  put 0 and 0 and 750 into the lighter gray color.
  put 0 and 0 and 625 into the light gray color.
  put 0 and 0 and 500 into the gray color.
  put 0 and 0 and 375 into the dark gray color.
  put 0 and 0 and 250 into the darker gray color.
  put 0 and 0 and 125 into the darkest gray color.
  put 0 and 0 and 0 into the black color.
  put 0 and 1000 and 875 into the lightest red color.
  put 0 and 1000 and 750 into the lighter red color.
  put 0 and 1000 and 625 into the light red color.
  put 0 and 1000 and 500 into the red color.
  put 0 and 1000 and 375 into the dark red color.
  put 0 and 1000 and 250 into the darker red color.
  put 0 and 1000 and 125 into the darkest red color.
  put 300 and 1000 and 875 into the lightest orange color.
  put 300 and 1000 and 750 into the lighter orange color.
  put 300 and 1000 and 625 into the light orange color.
  put 300 and 1000 and 500 into the orange color.
  put 300 and 1000 and 375 into the dark orange color.
  put 300 and 1000 and 250 into the darker orange color.
  put 300 and 1000 and 125 into the darkest orange color.
  put 600 and 1000 and 875 into the lightest yellow color.
  put 600 and 1000 and 750 into the lighter yellow color.
  put 600 and 1000 and 625 into the light yellow color.
  put 600 and 1000 and 500 into the yellow color.
  put 600 and 1000 and 375 into the dark yellow color.
  put 600 and 1000 and 250 into the darker yellow color.
  put 600 and 1000 and 125 into the darkest yellow color.
  put 900 and 1000 and 875 into the lightest lime color.
  put 900 and 1000 and 750 into the lighter lime color.
  put 900 and 1000 and 625 into the light lime color.
  put 900 and 1000 and 500 into the lime color.
  put 900 and 1000 and 375 into the dark lime color.
  put 900 and 1000 and 250 into the darker lime color.
  put 900 and 1000 and 125 into the darkest lime color.
  put 1200 and 1000 and 875 into the lightest green color.
  put 1200 and 1000 and 750 into the lighter green color.
  put 1200 and 1000 and 625 into the light green color.
  put 1200 and 1000 and 500 into the green color.
  put 1200 and 1000 and 375 into the dark green color.
  put 1200 and 1000 and 250 into the darker green color.
  put 1200 and 1000 and 125 into the darkest green color.
  put 1500 and 1000 and 875 into the lightest teal color.
  put 1500 and 1000 and 750 into the lighter teal color.
  put 1500 and 1000 and 625 into the light teal color.
  put 1500 and 1000 and 500 into the teal color.
  put 1500 and 1000 and 375 into the dark teal color.
  put 1500 and 1000 and 250 into the darker teal color.
  put 1500 and 1000 and 125 into the darkest teal color.
  put 1800 and 1000 and 875 into the lightest cyan color.
  put 1800 and 1000 and 750 into the lighter cyan color.
  put 1800 and 1000 and 625 into the light cyan color.
  put 1800 and 1000 and 500 into the cyan color.
  put 1800 and 1000 and 375 into the dark cyan color.
  put 1800 and 1000 and 250 into the darker cyan color.
  put 1800 and 1000 and 125 into the darkest cyan color.
  put 2100 and 1000 and 875 into the lightest sky color.
  put 2100 and 1000 and 750 into the lighter sky color.
  put 2100 and 1000 and 625 into the light sky color.
  put 2100 and 1000 and 500 into the sky color.
  put 2100 and 1000 and 375 into the dark sky color.
  put 2100 and 1000 and 250 into the darker sky color.
  put 2100 and 1000 and 125 into the darkest sky color.
  put 2400 and 1000 and 875 into the lightest blue color.
  put 2400 and 1000 and 750 into the lighter blue color.
  put 2400 and 1000 and 625 into the light blue color.
  put 2400 and 1000 and 500 into the blue color.
  put 2400 and 1000 and 375 into the dark blue color.
  put 2400 and 1000 and 250 into the darker blue color.
  put 2400 and 1000 and 125 into the darkest blue color.
  put 2700 and 1000 and 875 into the lightest purple color.
  put 2700 and 1000 and 750 into the lighter purple color.
  put 2700 and 1000 and 625 into the light purple color.
  put 2700 and 1000 and 500 into the purple color.
  put 2700 and 1000 and 375 into the dark purple color.
  put 2700 and 1000 and 250 into the darker purple color.
  put 2700 and 1000 and 125 into the darkest purple color.
  put 3000 and 1000 and 875 into the lightest magenta color.
  put 3000 and 1000 and 750 into the lighter magenta color.
  put 3000 and 1000 and 625 into the light magenta color.
  put 3000 and 1000 and 500 into the magenta color.
  put 3000 and 1000 and 375 into the dark magenta color.
  put 3000 and 1000 and 250 into the darker magenta color.
  put 3000 and 1000 and 125 into the darkest magenta color.
  put 3300 and 1000 and 875 into the lightest violet color.
  put 3300 and 1000 and 750 into the lighter violet color.
  put 3300 and 1000 and 625 into the light violet color.
  put 3300 and 1000 and 500 into the violet color.
  put 3300 and 1000 and 375 into the dark violet color.
  put 3300 and 1000 and 250 into the darker violet color.
  put 3300 and 1000 and 125 into the darkest violet color.
  put 0 and 0 and 800 into the hilite color.

to initialize com:
  call "ole32.dll" "CoInitializeEx" with 0 and 2 [coinit_apartmentthreaded].

to initialize the cursors:
  initialize the cursors (arrow cursor).
  initialize the cursors (hand cursor).
  initialize the cursors (i-beam cursor).
  hide the cursor.

to initialize the cursors (arrow cursor):
  append $00000000000000004000000060000000 to an xor-mask.
  append $70000000780000007C0000007E000000 to the xor-mask.
  append $7F0000007F8000007C0000006C000000 to the xor-mask.
  append $46000000060000000300000003000000 to the xor-mask.
  append $01800000018000000000000000000000  to the xor-mask.
  append $00 to the xor-mask given 48.
  append $7FFFFFFF3FFFFFFF1FFFFFFF0FFFFFFF  to an and-mask.
  append $07FFFFFF03FFFFFF01FFFFFF00FFFFFF to the and-mask.
  append $007FFFFF003FFFFF001FFFFF01FFFFFF to the and-mask.
  append $10FFFFFF30FFFFFF787FFFFFF87FFFFF to the and-mask.
  append $FC3FFFFFFC3FFFFFFE7FFFFFFFFFFFFF to the and-mask.
  append $FF to the and-mask given 48.
  call "user32.dll" "CreateCursor" with the module's handle and 0 and 0 and 32 and 32 and the and-mask's first and the xor-mask's first returning the arrow cursor.

to initialize the cursors (hand cursor):
  append $000000000180000019B0000019B00000 to an xor-mask.
  append $0DB200000DB6000007F6000067FE0000 to the xor-mask.
  append $7FFC00003FFC00001FFC00001FF80000 to the xor-mask.
  append $0FF8000007F0000003F0000003F00000 to the xor-mask.
  append $00 to the xor-mask given 64.
  append $FE7FFFFFE40FFFFFC007FFFFC005FFFF to an and-mask.
  append $E000FFFFE000FFFF9000FFFF0000FFFF to the and-mask.
  append $0001FFFF8001FFFFC001FFFFC003FFFF to the and-mask.
  append $E003FFFFF007FFFFF807FFFFF807FFFF to the and-mask.
  append $FF to the and-mask given 64.
  call "user32.dll" "CreateCursor" with the module's handle and 2 and 1 and 32 and 32 and the and-mask's first and the xor-mask's first returning the hand cursor.

to initialize the cursors (i-beam cursor):
  append $EE000000100000001000000010000000  to an xor-mask.
  append $10000000100000001000000010000000 to the xor-mask.
  append $10000000100000001000000010000000 to the xor-mask.
  append $100000001000000010000000EE000000 to the xor-mask.
  append $00 to the xor-mask given 64.
  append $FF to an and-mask given 128.
  call "user32.dll" "CreateCursor" with the module's handle and 3 and 7 and 32 and 32 and the and-mask's first and the xor-mask's first returning the i-beam cursor.

to initialize the fonts:
  call "gdi32.dll" "GetStockObject" with 11 [ansi_fixed_font] returning the null hfont.
  call "gdi32.dll" "AddFontMemResourceEx" with the osmosian font source's first and the osmosian font source's length and 0 and a number's whereabouts
     returning the osmosian font resource.
  put "osmosian" and 1/4 inch into the default font.

to initialize gdi+:
  put 1 into a gdiplusstartupinput's gdiplusversion.
  call "gdiplus.dll" "GdiplusStartup" with the gptoken's whereabouts and the gdiplusstartupinput's whereabouts and 0.

to initialize the memory canvas:
  call "gdi32.dll" "CreateCompatibleDC" with the screen canvas returning the memory canvas.
  call "gdi32.dll" "GetCurrentObject" with the memory canvas and 7 [obj_bitmap] returning the saved memory hbitmap.
  call "gdi32.dll" "CreateCompatibleBitmap" with the screen canvas and the screen's pixel width and the screen's pixel height returning an hbitmap.
  call "gdi32.dll" "SelectObject" with the memory canvas and the hbitmap.
  normalize the memory canvas.

to initialize the module:
  \ temp path
  put 512 into a length.
  reassign the temp path's first given the length.
  call "kernel32.dll" "GetTempPathA" with the length and the temp path's first returning the length.
  put the temp path's first plus the length minus 1 into the temp path's last.
  null terminate the temp path.
  \ module handle
  call "kernel32.dll" "GetModuleHandleA" with 0 returning the module's handle.
  \ module name
  put 512 into the length.
  reassign the module's path's first given the length.
  call "kernel32.dll" "GetModuleFileNameA" with the module's handle and the module's path's first and the length returning the length.
  put the module's path's first plus the length minus 1 into the module's path's last.
  if the module's path starts with "\\?\", remove leading bytes from the module's path given 4.
  lowercase the module's path.
  null terminate the module's path.
  \ module's other path pieces
  extract the module's name from the module's path.
  null terminate the module's name.
  extract the module's directory from the module's path.
  null terminate the module's directory.
  extract the module's root directory from the module's directory.
  null terminate the module's root directory.

to initialize the mouse:
  put 1 into the mouse's left button.
  put 2 into the mouse's right button.
  call "user32.dll" "GetSystemMetrics" with 23 [sm_swapbutton] returning a number.
  if the number is 0, exit.
  swap the mouse's left button with the mouse's right button.

to initialize the printer canvas:
  put a printdlgex's magnitude into the printdlgex's lstructsize.
  put the main window into the printdlgex's hwndowner.
  put 1288 [pd_returndc + pd_returndefault + pd_nopageenums] into the printdlgex's flags.
  put -1 [start_page_general] into the printdlgex's nstartpage.
  call "comdlg32.dll" "PrintDlgExA" with the printdlgex's whereabouts.
  call "kernel32.dll" "GlobalFree" with the printdlgex's hdevnames.
  put the printdlgex's hdevmode into the printer device mode handle.
  put the printdlgex's hdc into the printer canvas.

to initialize the screen:
  call "user32.dll" "GetSystemMetrics" with 0 [sm_cxscreen] returning the screen's pixel width.
  call "user32.dll" "GetSystemMetrics" with 1 [sm_cyscreen] returning the screen's pixel height.
  put 96 into the ppi.
  put the tpi divided by the ppi into the tpp.
  put the screen's pixel width times the tpp into a width.
  put the screen's pixel height times the tpp into a height.
  put 0 and 0 and the width and the height into the screen's box.
  subtract the tpp from the screen's right-bottom.

to initialize the screen canvas:
   call "user32.dll" "GetDC" with the main window returning the screen canvas.
  normalize the screen canvas.

to initialize a talker:
  convert "{96749377-3391-11D2-9EE3-00C04F797396}" [clsid_spvoice] to a clsid.
  convert "{6C44DF74-72B9-4992-A1EC-EF996E0422D4}" [iid_ispvoice] to an iid.
  call "ole32.dll" "CoCreateInstance" with the clsid's whereabouts and 0 and 7 [clsctx_all] and the iid's whereabouts and the talker's whereabouts.

to initialize the window:
  put a window class's magnitude into the window class' cbsize.
  put 40 [cs_owndc + cs_dblclks] into the window class' style.
  point the window class' lpfnwndproc to routine handle any message with a window a message number a w-param and a l-param.
  put the module's handle into the window class' hinstance.
  put the module's name's first into the window class' lpszclassname.
  call "user32.dll" "RegisterClassExA" with the window class's whereabouts.
  call "user32.dll" "CreateWindowExA" with 0 and the module's name's first and the module's name's first and -2147483648 [ws_popup] 
    and 0 and 0 and the screen's pixel width and the screen's pixel height and 0 and 0 and the module's handle and 0.
  call "user32.dll" "ShowWindow" with the main window and 1 [sw_shownormal].

to initialize winsock:
    call "ws2_32.dll" "WSAStartup" with 2 and a wsadata's whereabouts.

to insert a byte into a text:
  if the text is nil, exit.
  put the byte into a string.
  insert the string into the text.

the insert key is a key equal to 45.

to insert a spot into a polygon after a vertex:
  if the polygon is nil, exit.
  create another vertex given the spot.
  insert the other vertex into the polygon's vertices after the vertex.

to insert a string into another string before a byte#:
  if the string's length is 0, exit.
  privatize the byte#.
  limit the byte# to 1 and the other string's length plus 1.
  slap a substring on the other string. \ left side
  put the substring's first plus the byte# minus 2 into the substring's last.
  slap another substring on the other string. \ right side
  put the other substring's first plus the byte# minus 1 into the other substring's first.
  put the other string's length plus the string's length into a combined length.
  reassign a pointer given the combined length.
  put the pointer into a third substring's first.
  copy bytes from the substring's first to the third substring's first for the substring's length.
  add the substring's length to the third substring's first.
  copy bytes from the string's first to the third substring's first for the string's length.
  add the string's length to the third substring's first.
  copy bytes from the other substring's first to the third substring's first for the other substring's length.
  unassign the other string's first. \ don't use put a string into a string to prevent extra allocating and copying
  put the pointer into the other string's first.
  put the other string's first plus the combined length minus 1 into the other string's last.

to insert a string into a text:
  if the text is nil, exit.
  get a row given the text's caret row# and the text.
  put the row's string's length minus the text's caret column# into a number.
  put the row's string into another string.
  insert the string into the other string before the text's caret column#.
  convert the other string to some rows.
  put the rows' last into another row.
  insert the rows into the text's rows before the row.
  remove the row from the text's rows.
  destroy the row.
  renumber the text's rows.
  put the other row's row# into the text's caret row#.
  put the other row's string's length minus the number into the text's caret column#.
  deselect the text.

to insert a thing into some things after another thing:
  if the thing is nil, exit.
  if the other thing is nil, prepend the thing to the things; exit.
  insert the thing into the things before the other thing's next.

to insert a thing into some things before another thing:
  if the thing is nil, exit.
  if the things are empty, append the thing to the things; exit.
  if the other thing is nil, append the thing to the things; exit.
  if the other thing is the things' first, prepend the thing to the things; exit.
  put the thing into a new thing.
  put the other thing into a previous thing.
  put the new thing into the previous thing's previous' next.
  put the previous thing into the new thing's next.
  put the previous thing's previous into the new thing's previous.
  put the new thing into the previous thing's previous.

to insert some things into some other things after a thing:
  if the thing is nil, prepend the things to the other things; exit.
  insert the things into the other things before the thing's next.

to insert some things into some other things before a thing:
  privatize the thing.
  loop.
  put the things' first into another thing.
  if the other thing is nil, exit.
  remove the other thing from the things.
  insert the other thing into the other things before the thing.
  repeat.

to insert a vertex into a polygon after another vertex:
  if the polygon is nil, exit.
  if the vertex is nil, exit.
  insert the vertex into the polygon's vertices after the other vertex.

to insert a vertex into a polygon at a spot:
  if the polygon is nil, exit.
  if the vertex is nil, exit.
  loop.
  get another vertex from the polygon's vertices.
  if the other vertex is nil, exit.
  if the other vertex's next is nil, exit.
  put the other vertex's spot and the other vertex's next's spot into a line.
  if the spot is not on the line, repeat.
  insert the vertex into the polygon's vertices after the other vertex.

to insert a vertex into a polygon before another vertex:
  if the polygon is nil, exit.
  if the vertex is nil, exit.
  insert the vertex into the polygon's vertices before the other vertex.

to intersect a box with another box giving a third box:
  \ boxes do not touch
  clear the third box.
  if the box's left is greater than the other box's right, exit.
  if the box's top is greater than the other box's bottom, exit.
  if the box's right is less than the other box's left, exit.
  if the box's bottom is less than the other box's top, exit.
  \ boxes touch
  put the box into the third box.
  if the box's left is less than the other box's left, put the other box's left into the third box's left.
  if the box's top is less than the other box's top, put the other box's top into the third box's top.
  if the box's right is greater than the other box's right, put the other box's right into the third box's right.
  if the box's bottom is greater than the other box's bottom, put the other box's bottom into the third box's bottom.

to invert a flag:
  if the flag is yes, put no into the flag; exit.
  put yes into the flag.

the inverted-exclamation-mark byte is a byte equal to 161.

the inverted-question-mark byte is a byte equal to 191.

a in_addr is a record with
  a byte called s_b1,
  a byte called s_b2,
  a byte called s_b3,
  a byte called s_b4,
  a wyrd [unsigned] called  s_w1 at the s_b1,
  a wyrd [unsigned] called s_w2 at the s_b3,
  a number called s_addr at the s_b1.

an ip address has
  a number,
  a string.

an istream is a pointer to an istream object.

an istream object is a record with an istream vtable called vtable.

an istream vtable is a pointer to an istream vtable record.

an istream vtable record is a record with
  \ iunknown
  a pointer called queryinterface,
  a pointer called addref,
  a pointer called release, \ function(this:istream):number; stdcall;
  \ istream
  a pointer called read,
  a pointer called write,
  a pointer called seek,
  a pointer called setsize,
  a pointer called copyto,
  a pointer called commit,
  a pointer called revert,
  a pointer called lockregion,
  a pointer called unlockregion,
  a pointer called stat,
  a pointer called clone.

an item has
  a kind,
  a path, a directory, a designator, an extension,
  a size,
  a win32finddata and a handle.

the j-key is a key equal to 74.

to jump the caret left in a text:
  if the text is nil, exit.
  move the caret left to any non-noise byte in the text.
  if the text's caret column# is 1, exit.
  get a row given the text's caret row# and the text.
  put the row's string's first plus the text's caret column# minus 2 into a byte pointer.
  if the byte pointer's target is alphanumeric, move the caret left to any non-alphanumeric byte in the text.
  if the byte pointer's target is not alphanumeric, move the caret left to any non-symbolic byte in the text.
  move the caret left to any non-noise byte in the text.

to jump the caret right in a text:
  if the text is nil, exit.
  move the caret right to any non-noise byte in the text.
  get a row given the text's caret row# and the text.
  if the text's caret column# is the row's string's length, exit.
  put the row's string's first plus the text's caret column# minus 1 into a byte pointer.
  if the byte pointer's target is alphanumeric, move the caret right to any non-alphanumeric byte in the text.
  if the byte pointer's target is not alphanumeric, move the caret right to any non-symbolic byte in the text.
  move the caret right to any non-noise byte in the text.

the k-key is a key equal to 75.

a key is a number.

a kilobyte is 1024 units.

a kind is a string.

the l-key is a key equal to 76.

a l-param is a number.

a landscape sheet is a sheet.

the largest number is 2147483647.

an lcm is a number.

the left-alligator byte is a byte equal to 60.

the left-alligator-quote byte is a byte equal to 139.

the left-arrow key is a key equal to 37.

the left-brace byte is a byte equal to 123.

the left-bracket byte is a byte equal to 91.

the left-double-alligator-quote byte is a byte equal to 171.

the left-double-quote byte is a byte equal to 147.

the left-paren byte is a byte equal to 40.

the left-single-quote byte is a byte equal to 145.

the left-window key is a key equal to 91.

a length is a number.

the lexicon is a thing with an index.

the light blue color is a color.

the light cyan color is a color.

the light gray color is a color.

the light green color is a color.

the light lime color is a color.

the light magenta color is a color.

the light orange color is a color.

the light purple color is a color.

the light red color is a color.

the light sky color is a color.

the light teal color is a color.

the light violet color is a color.

the light yellow color is a color.

the lighter blue color is a color.

the lighter cyan color is a color.

the lighter gray color is a color.

the lighter green color is a color.

the lighter lime color is a color.

the lighter magenta color is a color.

the lighter orange color is a color.

the lighter purple color is a color.

the lighter red color is a color.

the lighter sky color is a color.

the lighter teal color is a color.

the lighter violet color is a color.

the lighter yellow color is a color.

the lightest blue color is a color.

the lightest cyan color is a color.

the lightest gray color is a color.

the lightest green color is a color.

the lightest lime color is a color.

the lightest magenta color is a color.

the lightest orange color is a color.

the lightest purple color is a color.

the lightest red color is a color.

the lightest sky color is a color.

the lightest teal color is a color.

the lightest violet color is a color.

the lightest yellow color is a color.

a lightness is a number [0 to 1000].

the lime color is a color.

to limit a box to another box:
  limit the box's left to the other box's left and the other box's right.
  limit the box's top to the other box's top and the other box's bottom.
  limit the box's right to the other box's left and the other box's right.
  limit the box's bottom to the other box's top and the other box's bottom.

to limit the caret in a text:
  if the text is nil, exit.
  limit the text's caret row# to 1 and the text's row count.
  get a row given the text's caret row# and the text.
  limit the text's caret column# to 1 and the row's string's length.

to limit a number to another number and a third number:
  if the number is less than the other number, put the other number into the number; exit.
  if the number is greater than the third number, put the third number into the number.

to limit the origin of a text:
  if the text is nil, exit.
  limit the text's x to the smallest number and the text's margin.
  put the text's row count minus 1 times the text's row height into a number.
  limit the text's y to - the number and 0.

to limit a spot to a box:
  if the spot's x is less than the box's left, put the box's left into the spot's x.
  if the spot's y is less than the box's top, put the box's top into the spot's y.
  if the spot's x is greater than the box's right, put the box's right into the spot's x.
  if the spot's y is greater than the box's bottom, put the box's bottom into the spot's y.

to limit some texts to a count:
  put the texts' count into another count.
  loop.
  if the other count is less than or equal to the count, exit.
  put the texts' first into a text.
  remove the text from the texts.
  destroy the text.
  subtract 1 from the other count.
  repeat.

a line has a start spot and an end spot.

the linefeed byte is a byte equal to 10.

the little-a byte is a byte equal to 97.

the little-a-acute byte is a byte equal to 225.

the little-a-circumflex byte is a byte equal to 226.

the little-a-diaeresis byte is a byte equal to 228.

the little-a-grave byte is a byte equal to 224.

the little-a-ring byte is a byte equal to 229.

the little-a-tilde byte is a byte equal to 227.

the little-ae byte is a byte equal to 230.

the little-b byte is a byte equal to 98.

the little-c byte is a byte equal to 99.

the little-c-cedilla byte is a byte equal to 231.

the little-d byte is a byte equal to 100.

the little-e byte is a byte equal to 101.

the little-e-acute byte is a byte equal to 233.

the little-e-circumflex byte is a byte equal to 234.

the little-e-diaeresis byte is a byte equal to 235.

the little-e-grave byte is a byte equal to 232.

the little-eth byte is a byte equal to 240.

the little-f byte is a byte equal to 102.

the little-f-hook byte is a byte equal to 131.

the little-g byte is a byte equal to 103.

the little-h byte is a byte equal to 104.

the little-i byte is a byte equal to 105.

the little-i-acute byte is a byte equal to 237.

the little-i-circumflex byte is a byte equal to 238.

the little-i-diaeresis byte is a byte equal to 239.

the little-i-grave byte is a byte equal to 236.

the little-j byte is a byte equal to 106.

the little-k byte is a byte equal to 107.

the little-l byte is a byte equal to 108.

the little-m byte is a byte equal to 109.

the little-n byte is a byte equal to 110.

the little-n-tilde byte is a byte equal to 241.

the little-o byte is a byte equal to 111.

the little-o-acute byte is a byte equal to 243.

the little-o-circumflex byte is a byte equal to 244.

the little-o-diaeresis byte is a byte equal to 246.

the little-o-grave byte is a byte equal to 242.

the little-o-stroke byte is a byte equal to 248.

the little-o-tilde byte is a byte equal to 245.

the little-oe byte is a byte equal to 156.

the little-p byte is a byte equal to 112.

the little-q byte is a byte equal to 113.

the little-r byte is a byte equal to 114.

the little-s byte is a byte equal to 115.

the little-s-caron byte is a byte equal to 154.

the little-t byte is a byte equal to 116.

the little-thorn byte is a byte equal to 254.

the little-tilde byte is a byte equal to 152.

the little-u byte is a byte equal to 117.

the little-u-acute byte is a byte equal to 250.

the little-u-circumflex byte is a byte equal to 251.

the little-u-diaeresis byte is a byte equal to 252.

the little-u-grave byte is a byte equal to 249.

the little-v byte is a byte equal to 118.

the little-w byte is a byte equal to 119.

the little-x byte is a byte equal to 120.

the little-y byte is a byte equal to 121.

the little-y-acute byte is a byte equal to 253.

the little-y-diaeresis byte is a byte equal to 255.

the little-z byte is a byte equal to 122.

the little-z-caron byte is a byte equal to 158.

to load the lexicon:
  if the lexicon is not nil, exit.
  extract a directory from the module's path.
  loop.
  if the directory is blank, exit.
  put the directory then "lexicon\" into a path.
  if the path is in the file system, load the lexicon given the path; exit.
  extract the directory from the directory.
  repeat.

to load the lexicon given a buffer:
  if the lexicon is nil, create the lexicon.
  slap a rider on the buffer.
  loop.
  move the rider (index lexicon rules).
  if the rider's token is blank, exit.
  index the rider's token in the lexicon's index.
  repeat.

to load the lexicon given a path:
  get an item from the path.
  if the item is not found, exit.
  if the item's kind is not "file", repeat.
  read the item's path into a buffer.
  if the i/o error is not blank, repeat.
  load the lexicon given the buffer.
  repeat.

to localize a box given a pair:
  privatize the pair.
  negate the pair.
  move the box given the pair.

to localize a spot given a pair:
  privatize the pair.
  negate the pair.
  move the spot given the pair.

to lock a gpbitmap given a bitmapdata (24-bit rgb):
  put the gpbitmap's gprect into a gprect.
  call "gdiplus.dll" "GdipBitmapLockBits" with the gpbitmap and the gprect's whereabouts and 3 [imagelockmoderead or imagelockmodewrite]
    and 137224 [pixelformat24bpprgb] and the bitmapdata's whereabouts.

a logbrush has
  a number called lbstyle,
  a colorref called lbcolor,
  a number called lbhatch.

the lower-double-quote byte is a byte equal to 132.

the lower-single-quote byte is a byte equal to 130.

to lowercase any selected bytes in a text:
  if the text is nil, exit.
  loop.
  get a row from the text's rows.
  if the row is nil, exit.
  if the row of the text is not selected, repeat.
  slap a substring on any selected bytes in the row of the text.  
  lowercase the substring.
  repeat.

to lowercase a byte:
  intel $8B8508000000. \ mov eax,[ebp+8] \ the byte
  intel $803841. \ cmp byte ptr [eax],'A'
  intel $0F820C000000. \ jb END
  intel $80385A. \ cmp byte ptr [eax],'Z'
  intel $0F8703000000. \ ja END
  intel $800020. \ add byte ptr [eax],$20
  \ END

to lowercase the character under a finger and put it into a string:
  if the finger is nil, exit.
  put the finger's target into the string.
  lowercase the string.

to lowercase a string:
  slap a substring on the string.
  loop.
  if the substring is blank, exit.
  lowercase the substring's first's target.
  add 1 to the substring's first.
  repeat.

to lowercase a text:
  if the text is nil, exit.
  loop.
  get a row from the text's rows.
  if the row is nil, break.
  lowercase the row's string.
  repeat.
  wrap the text.

the m-key is a key equal to 77.

the magenta color is a color.

the main window is a window.

to make a box some twips by some other twips:
  put 0 into the box's left.
  put 0 into the box's top.
  put the twips into the box's right.
  put the other twips into the box's bottom.

to make a box with a left coord and a top coord and a right coord and a bottom coord:
  put the left coord and the top coord and the right coord and the bottom coord into the box.

to make a box with a spot and another spot:
  put the spot and the other spot into the box.

to make a color from a hue and a saturation and a lightness:
  put the hue and the saturation and the lightness into the color.

to make an ellipse given a box:
  put the box into the ellipse's box.

to make an ellipse some twips by some other twips:
  put 0 into the ellipse's left.
  put 0 into the ellipse's top.
  put the twips into the ellipse's right.
  put the other twips into the ellipse's bottom.

to make an ellipse with a left coord and a top coord and a right coord and a bottom coord:
  put the left coord and the top coord and the right coord and the bottom coord into the ellipse.

to make an ellipse with a spot and another spot:
  put the spot and the other spot into the ellipse.

to make a line with a spot and another spot:
  put the spot and the other spot into the line.

to make a line with an x coord and a y coord and another x coord and another y coord:
  put the x coord and the y coord and the other x coord and the other y coord into the line.

to make a ratio pair given a box and another box:
  put the box's x-extent into the ratio pair's ratio's numerator.
  put the other box's x-extent into the ratio pair's ratio's denominator.
  put the box's y-extent into the ratio pair's other ratio's numerator.
  put the other box's y-extent into the ratio pair's other ratio's denominator.

to make a roundy box from a box and a radius:
  put the box and the radius into the roundy box.

to make a roundy box some twips by some other twips:
  put 0 into the roundy box's left.
  put 0 into the roundy box's top.
  put the twips into the roundy box's right.
  put the other twips into the roundy box's bottom.

to make a roundy box with a left coord and a top coord and a right coord and a bottom coord and a radius:
  put the left coord and the top coord and the right coord and the bottom coord and the radius into the roundy box.

to make a roundy box with a spot and another spot and a radius:
  put the spot and the other spot and the radius into the roundy box.

to make a spot with an x coord and a y coord:
  put the x coord and the y coord into the spot.

a margin is a number.

the masculine byte is a byte equal to 186.

to mask inside a box:
  create an hrgn given the box.
  mask inside the hrgn.
  destroy the hrgn.

to mask inside an ellipse:
  create an hrgn given the ellipse.
  mask inside the hrgn.
  destroy the hrgn.

to mask inside an hrgn:
  call "gdi32.dll" "ExtSelectClipRgn" with the current canvas and the hrgn and 4 [rgn_diff].

to mask inside a polygon:
  create an hrgn given the polygon.
  mask inside the hrgn.
  destroy the hrgn.

to mask inside a roundy box:
  create an hrgn given the roundy box.
  mask inside the hrgn.
  destroy the hrgn.

a mask is a hex string.

to mask only inside a box:
  unmask everything.
  mask inside the box.

to mask only inside an ellipse:
  unmask everything.
  mask inside the ellipse.

to mask only inside a polygon:
  unmask everything.
  mask inside the polygon.

to mask only inside a roundy box:
  unmask everything.
  mask inside the roundy box.

to mask only outside a box:
  unmask everything.
  mask outside the box.

to mask only outside an ellipse:
  unmask everything.
  mask outside the ellipse.

to mask only outside a polygon:
  unmask everything.
  mask outside the polygon.

to mask only outside a roundy box:
  unmask everything.
  mask outside the roundy box.

to mask outside a box:
  create an hrgn given the box.
  mask outside the hrgn.
  destroy the hrgn.

to mask outside an ellipse:
  create an hrgn given the ellipse.
  mask outside the hrgn.
  destroy the hrgn.

to mask outside an hrgn:
  call "gdi32.dll" "ExtSelectClipRgn" with the current canvas and the hrgn and 1 [rgn_and].

to mask outside a polygon:
  create an hrgn given the polygon.
  mask outside the hrgn.
  destroy the hrgn.

to mask outside a roundy box:
  create an hrgn given the roundy box.
  mask outside the hrgn.
  destroy the hrgn.

the max text undos is a count equal to 32.

a megabyte is 1024 kilobytes.

the memory canvas is a canvas.

the menu key is a key equal to 93.

a message is a string.

the micro byte is a byte equal to 181.

a million is 1000 thousands.

a millisecond is a number.

to minimize a window:
  call "user32.dll" "ShowWindow" with the window and 6 [sw_minimize].

a minute is 60 seconds.

to mirror the gpbitmap in a picture:
  if the picture is nil, exit.
  reverse the picture's mirror flag.
  mirror the picture's gpbitmap.

to mirror a gpimage:
  call "gdiplus.dll" "GdipImageRotateFlip" with the gpimage and 4 [rotatenoneflipx].

to mirror a picture:
  if the picture is nil, exit.
  put the picture's box's center's x minus the picture's uncropped box's center's x into a pair's x.
  multiply the pair's x by 2.
  move the picture's uncropped box given the pair.
  mirror the gpbitmap in the picture.

to mirror a polygon:
  if the polygon is nil, exit.
  put the polygon's box into a box.
  loop.
  get a vertex from the polygon's vertices.
  if the vertex is nil, exit.
  subtract the box's left from the vertex's x.
  put the box's right minus the vertex's x into the vertex's x.
  repeat.

a mixed has a whole number and a ratio.

the module has
  a handle,
  a path,
  a directory,
  a root directory, \ one up from the directory that exe is run from
  a file name w/o extension called name.

the mouse has
  a key called left button,
  a key called right button.

to move the anchor left to any non-alphanumeric byte in a text:
  if the text is nil, exit.
  get a row given the text's anchor row# and the text.
  loop.
  if the text's anchor column# is 1, exit.
  put the row's string's first plus the text's anchor column# minus 2 into a byte pointer.
  if the byte pointer's target is not alphanumeric, exit.
  subtract 1 from the text's anchor column#.
  repeat.

to move a box down some twips:
  move the box given 0 and the twips.

to move a box given a pair:
  move the box given the pair's x and the pair's y.

to move a box given a ratio pair and a spot:
  get a difference between the box's left-top and the spot.
  put the difference into another difference.
  scale the other difference given the ratio pair.
  subtract the difference from the other difference.
  move the box given the other difference.

to move a box given some x twips and some y twips:
  add the x twips to the box's left.
  add the y twips to the box's top.
  add the x twips to the box's right.
  add the y twips to the box's bottom.

to move a box left some twips:
  move the box given - the twips and 0.

to move a box right some twips:
  move the box given the twips and 0.

to move a box to a spot:
  get a difference between the spot and the box's left-top.
  move the box given the difference.

to move a box up some twips:
  move the box given 0 and - the twips.

to move the caret down in a text:
  if the text is nil, exit.
  add 1 to the text's caret row#.
  limit the caret in the text.

to move the caret down one page in a text:
  if the text is nil, exit.
  add the text's rows/box to the text's caret row#.
  subtract 1 from the text's caret row#.
  limit the caret in the text.

to move the caret to the first byte of the current row of a text:
  if the text is nil, exit.
  put 1 into the text's caret column#.

to move the caret to the first byte of a text:
  if the text is nil, exit.
  put 1 and 1 into the text's caret.

to move the caret to the last byte of the current row of a text:
  if the text is nil, exit.
  get a row given the text's caret row# and the text.
  put the row's string's length into the text's caret column#.

to move the caret to the last byte of a text:
  if the text is nil, exit.
  put the text's row count into the text's caret row#.
  get a row given the text's caret row# and the text.
  put the row's string's length into the text's caret column#.

to move the caret left to any non-alphanumeric byte in a text:
  if the text is nil, exit.
  get a row given the text's caret row# and the text.
  loop.
  if the text's caret column# is 1, exit.
  put the row's string's first plus the text's caret column# minus 2 into a byte pointer.
  if the byte pointer's target is not alphanumeric, exit.
  subtract 1 from the text's caret column#.
  repeat.

to move the caret left to any non-noise byte in a text:
  if the text is nil, exit.
  get a row given the text's caret row# and the text.
  loop.
  if the text's caret column# is 1, exit.
  put the row's string's first plus the text's caret column# minus 2 into a byte pointer.
  if the byte pointer's target is not noise, exit.
  subtract 1 from the text's caret column#.
  repeat.

to move the caret left to any non-symbolic byte in a text:
  if the text is nil, exit.
  get a row given the text's caret row# and the text.
  loop.
  if the text's caret column# is 1, exit.
  put the row's string's first plus the text's caret column# minus 2 into a byte pointer.
  if the byte pointer's target is not symbolic, exit.
  subtract 1 from the text's caret column#.
  repeat.

to move the caret left in a text:
  if the text is nil, exit.
  subtract 1 from the text's caret column#.
  limit the caret in the text.

to move the caret right to any non-alphanumeric byte in a text:
  if the text is nil, exit.
  get a row given the text's caret row# and the text.
  loop.
  if the text's caret column# is the row's string's length, exit.
  put the row's string's first plus the text's caret column# minus 1 into a byte pointer.
  if the byte pointer's target is not alphanumeric, exit.
  add 1 to the text's caret column#.
  repeat.

to move the caret right to any non-noise byte in a text:
  if the text is nil, exit.
  get a row given the text's caret row# and the text.
  loop.
  if the text's caret column# is the row's string's length, exit.
  put the row's string's first plus the text's caret column# minus 1 into a byte pointer.
  if the byte pointer's target is not noise, exit.
  add 1 to the text's caret column#.
  repeat.

to move the caret right to any non-symbolic byte in a text:
  if the text is nil, exit.
  get a row given the text's caret row# and the text.
  loop.
  if the text's caret column# is the row's string's length, exit.
  put the row's string's first plus the text's caret column# minus 1 into a byte pointer.
  if the byte pointer's target is not symbolic, exit.
  add 1 to the text's caret column#.
  repeat.

to move the caret right in a text:
  if the text is nil, exit.
  add 1 to the text's caret column#.
  limit the caret in the text.

to move the caret up in a text:
  if the text is nil, exit.
  subtract 1 from the text's caret row#.
  limit the caret in the text.

to move the caret up one page in a text:
  if the text is nil, exit.
  subtract the text's rows/box from the text's caret row#.
  add 1 to the text's caret row#.
  limit the caret in the text.

to move an ellipse down some twips:
  move the ellipse given 0 and the twips.

to move an ellipse given a pair:
  move the ellipse given the pair's x and the pair's y.

to move an ellipse given some x twips and some y twips:
  move the ellipse's box given the x twips and the y twips.

to move an ellipse left some twips:
  move the ellipse given - the twips and 0.

to move an ellipse right some twips:
  move the ellipse given the twips and 0.

to move an ellipse to a spot:
  get a difference between the spot and the ellipse's left-top.
  move the ellipse given the difference.

to move an ellipse up some twips:
  move the ellipse given 0 and - the twips.

to move a finger over a number:
  if the finger is nil, exit.
  add 1 to the finger.

to move a line down some twips:
  move the line given 0 and the twips.

to move a line given a pair:
  move the line given the pair's x and the pair's y.

to move a line given some x twips and some y twips:
  add the x twips to the line's start's x.
  add the y twips to the line's start's y.
  add the x twips to the line's end's x.
  add the y twips to the line's end's y.

to move a line left some twips:
  move the line given - the twips and 0.

to move a line right some twips:
  move the line given the twips and 0.

to move a line to a spot:
  get a difference between the spot and the line's start.
  move the line given the difference.

to move a line up some twips:
  move the line given 0 and - the twips.

to move a picture down some twips:
  move the picture given 0 and the twips.

to move a picture given a pair:
  move the picture given the pair's x and the pair's y.

to move a picture given some x twips and some y twips:
  if the picture is nil, exit.
  move the picture's box given the x twips and the y twips.
  move the picture's uncropped box given the x twips and the y twips.

to move a picture left some twips:
  move the picture given - the twips and 0.

to move a picture right some twips:
  move the picture given the twips and 0.

to move a picture to a spot:
  if the picture is nil, exit.
  get a difference between the spot and the picture's left-top.
  move the picture given the difference.

to move a picture up some twips:
  move the picture given 0 and - the twips.

to move a polygon down some twips:
  move the polygon given 0 and the twips.

to move a polygon given a pair:
  move the polygon given the pair's x and the pair's y.

to move a polygon given some x twips and some y twips:
  if the polygon is nil, exit.
  loop.
  get a vertex from the polygon's vertices.
  if the vertex is nil, exit.
  move the vertex given the x twips and the y twips.
  repeat.

to move a polygon left some twips:
  move the polygon given - the twips and 0.

to move a polygon right some twips:
  move the polygon given the twips and 0.

to move a polygon to a spot:
  if the polygon is nil, exit.
  get a difference between the spot and the polygon's box's left-top.
  move the polygon given the difference.

to move a polygon up some twips:
  move the polygon given 0 and - the twips.

to move a rider (index lexicon rules):
  skip any leading noise in the rider's source.
  position the rider's token on the rider's source.
  loop.
  if the rider's source is blank, exit.
  bump the rider.
  if the rider's source's first's target is noise, exit.
  repeat.

to move a rider (quoted string rules):
  bump the rider.
  if the rider's source is blank, exit.
  if the rider's source's first's target is not the double-quote byte, repeat.
  if the rider's source's first is the rider's source's last, bump the rider; exit.
  bump the rider.
  if the rider's source's first's target is not the double-quote byte, exit.
  repeat.

to move a rider (spell checking rules):
  skip any non-alphanumeric bytes in the rider's source.
  position the rider's token on the rider's source.
  loop.
  if the rider's source is blank, exit.
  bump the rider.
  if the rider's source is on any contraction, bump the rider; repeat.
  if the rider's source's first's target is not alphanumeric, exit.
  repeat.

to move a rider (text file rules):
  position the rider's token on the rider's source.
  loop.
  if the rider's source is blank, exit.
  if the rider's source's first's target is the return byte, bump the rider; break.
  if the rider's source's first's target is the linefeed byte, bump the rider; exit. \ *dahn new to handle lines terminated by just linefeed
  bump the rider.
  repeat.
  if the rider's source is blank, exit.
  if the rider's source's first's target is the linefeed byte, add 1 to the rider's source's first.

to move a rider (word wrapping rules):
  position the rider's token on the rider's source.
  if the rider's source is blank, exit.
  if the rider's source's first's target is the return byte, bump the rider; exit.
  loop.
  if the rider's source is blank, exit.
  if the rider's source's first's target is the return byte, exit.
  if the rider's token is blank, bump the rider; repeat.
  if the rider's source's first's target is like the rider's token's last's target, bump the rider; repeat.

to move a rider given a box (word wrapping rules):
  skip any leading linefeed byte in the rider's source.
  position the rider's token on the rider's source.
  if the rider's source is blank, exit.
  slap another rider on the rider.
  loop.
  if the rider's source is blank, exit.
  move the other rider (word wrapping rules).
  if the other rider's token is blank, exit.
  if the other rider's token's first's target is the return byte, bump the rider; exit.
  if the other rider's token's first's target is whitespace, bump the rider by the other rider's token's length; repeat.
  if the rider's token is blank, bump the rider by the other rider's token's length; repeat.
  if the rider's token then the other rider's token is wider than the box, exit.
  bump the rider by the other rider's token's length.
  repeat.

to move a rider given a separator byte:
  position the rider's token on the rider's source.
  loop.
  if the rider's source is blank, exit.
  if the rider's source's first's target is the separator byte, add 1 to the rider's source's first; exit.
  bump the rider.
  repeat.

to move a spot to another spot:
  put the other spot into the spot.

to move a spot down some twips:
  move the spot given 0 and the twips.

to move a spot given a pair:
  move the spot given the pair's x and the pair's y.

to move a spot given some x twips and some y twips:
  add the x twips to the spot's x.
  add the y twips to the spot's y.

to move a spot left some twips:
  move the spot given - the twips and 0.

to move a spot right some twips:
  move the spot given the twips and 0.

to move a spot up some twips:
  move the spot given 0 and - the twips.

to move a substring given a number:
  add the number to the substring's first.
  add the number to the substring's last.

to move a text down some twips:
  move the text given 0 and the twips.

to move a text given a pair:
  move the text given the pair's x and the pair's y.

to move a text given some x twips and some y twips:
  if the text is nil, exit.
  move the text's box given the x twips and the y twips.

to move a text left some twips:
  move the text given - the twips and 0.

to move a text right some twips:
  move the text given the twips and 0.

to move a text to a spot:
  if the text is nil, exit.
  get a difference between the spot and the text's left-top.
  move the text given the difference.

to move a text up some twips:
  move the text given 0 and - the twips.

to move a thing from some things to some other things:
  if the thing is nil, exit.
  privatize the thing.
  remove the thing from the things.
  append the thing to the other things.

to move some things to some other things:
  put the things' first into the other things' first.
  put the things' last into the other things' last.
  clear the things.

to move a vertex down some twips:
  move the vertex given 0 and the twips.

to move a vertex given a pair:
  move the vertex given the pair's x and the pair's y.

to move a vertex given some x twips and some y twips:
  if the vertex is nil, exit.
  add the x twips to the vertex's x.
  add the y twips to the vertex's y.

to move a vertex left some twips:
  move the vertex given - the twips and 0.

to move a vertex right some twips:
  move the vertex given the twips and 0.

to move a vertex to a spot:
  if the vertex is nil, exit.
  put the spot into the vertex's spot.

to move a vertex up some twips:
  move the vertex given 0 and - the twips.

to move a window left:
  call "user32.dll" "GetWindowRect" with the main window and a box's whereabouts.
  subtract the screen's pixel width from the box's left.
  call "user32.dll" "MoveWindow" with the window and the box's left and the box's top and the screen's pixel width and the screen's pixel height and 1.

to move a window right:
  call "user32.dll" "GetWindowRect" with the main window and a box's whereabouts.
  add the screen's pixel width to the box's left.
  call "user32.dll" "MoveWindow" with the window and the box's left and the box's top and the screen's pixel width and the screen's pixel height and 1.

a msg is a record with
  a window called hwnd,
  a number called message,
  a w-param called wparam,
  a l-param called lparam,
  a number called time,
  a spot called pt.

the multiplication-symbol byte is a byte equal to 215.

to multiply a number by another number:
  intel $8B8508000000. \ mov eax,[ebp+8] \ the number
  intel $8B00. \ mov eax,[eax]
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the other number
  intel $F72B.\ mul [ebx] \ means mul eax,[ebx] but is weird form
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the number
  intel $8903. \ mov [ebx],eax

to multiply a number by a ratio: employ scale a number given a ratio.

to multiply a pair by another pair:
  multiply the pair's x by the other pair's x.
  multiply the pair's y by the other pair's y.

to multiply a pair by a number:
  multiply the pair's x by the number.
  multiply the pair's y by the number.

to multiply a pair by a number and another number:
  multiply the pair's x by the number.
  multiply the pair's y by the other number.

to multiply a pointer by a number: employ multiply a number by another number.

to multiply a ratio by another ratio:
  multiply the ratio's numerator by the other ratio's numerator.
  multiply the ratio's denominator by the other ratio's denominator.
  reduce the ratio.

to multiply a ratio by a number:
  multiply the ratio's numerator by the number.
  reduce the ratio.

the n-key is a key equal to 78.

a name is a string.

to negate a number:
  intel $8B8508000000. \ mov eax,[ebp+8] \ the number
  intel $F718.\ neg [eax]

to negate a pair:
  negate the pair's x.
  negate the pair's y.

to negate a ratio:
  negate the ratio's numerator.

the negative-acknowledge byte is a byte equal to 21.

a nibble is a byte. \ only low order 4 bits are valid

a nibble string is a string. \ $0010A0...

the nine byte is a byte equal to 57.

the nine key is a key equal to 57.

the non-breaking-space byte is a byte equal to 160.

to non-destructively resize a picture given a ratio pair:
  if the picture is nil, exit.
  move the picture's uncropped box given the ratio pair and the picture's box's left-top.
  resize the picture's uncropped box given the ratio pair.
  resize the picture's box given the ratio pair.
  if the picture's right is less than the picture's left, mirror the gpbitmap in the picture.
  if the picture's bottom is less than the picture's top, flip the gpbitmap in the picture.

to non-destructively resize a picture given a twip pair:
  if the picture is nil, exit.
  put the picture's box into a box.
  resize the box given the twip pair.
  make a ratio pair given the box and the picture's box.
  non-destructively resize the picture given the ratio pair.

to normalize an angle: divide the angle by 3600 giving a quotient and the angle.

to normalize a box:
  if the box's right is less than the box's left, swap the box's left with the box's right.
  if the box's bottom is less than the box's top, swap the box's top with the box's bottom.

to normalize a canvas:
  call "gdi32.dll" "SetGraphicsMode" with the canvas and 2 [gm_advanced].
  call "gdi32.dll" "SetBkMode" with the canvas and 1 [transparent].
  call "gdi32.dll" "SetMapMode" with the canvas and 8 [mm_anisotropic].
  call "gdi32.dll" "SetViewportOrgEx" with the canvas and 0 and 0 and nil.
  call "gdi32.dll" "SetViewportExtEx" with the canvas and the ppi and the ppi and nil.
  call "gdi32.dll" "SetWindowOrgEx" with the canvas and 0 and 0 and nil.
  call "gdi32.dll" "SetWindowExtEx" with the canvas and the tpi and the tpi and nil.

to normalize an ellipse:
  normalize the ellipse's box.

to normalize a picture:
  if the picture is nil, exit.
  normalize the picture's box.
  normalize the picture's uncropped box.

to normalize a ratio and another ratio:
  get a lcm given the ratio's denominator and the other ratio's denominator.
  multiply the ratio's numerator by the lcm divided by the ratio's denominator.
  put the lcm into the ratio's denominator.
  multiply the other ratio's numerator by the lcm divided by the other ratio's denominator.
  put the lcm into the other ratio's denominator.

to normalize a selection:
  if the selection's anchor row# is less than the selection's caret row#, exit.
  if the selection's anchor row# is greater than the selection's caret row#, swap the selection's anchor with the selection's caret; exit.
  if the selection's anchor column# is greater than the selection's caret column#, swap the selection's anchor column# with the selection's caret column#.

to normalize a text:
  if the text is nil, exit.
  normalize the text's box.

the not byte is a byte equal to 172.

the null byte is a byte equal to 0.

the null hbrush is an hbrush.

the null hfont is an hfont.

the null hpen is an hpen.

to null terminate a string:
  put the string's length into a saved length.
  reassign the string's first given the saved length plus 1.
  put the string's first plus the saved length minus 1 into the string's last.
  put the string's last plus 1 into a byte pointer.
  put the null byte into the byte pointer's target.

to null terminate a wide string:
  put the wide string's length into a saved length.
  reassign the wide string's first given the saved length plus 2.
  put the wide string's first plus the saved length minus 1 into the wide string's last.

a number has
  a first byte,
  a second byte,
  a third byte,
  a fourth byte,
  a low wyrd at the first byte,
  a high wyrd at the third byte.

a number pointer is a pointer to a number.

the number-sign byte is a byte equal to 35.

the numlock key is a key equal to 144.

the numpad-astrisk key is a key equal to 106.

the numpad-cross key is a key equal to 107.

the numpad-dash key is a key equal to 109.

the numpad-eight key is a key equal to 104.

the numpad-five key is a key equal to 101.

the numpad-four key is a key equal to 100.

the numpad-nine key is a key equal to 105.

the numpad-one key is a key equal to 97.

the numpad-period key is a key equal to 110.

the numpad-seven key is a key equal to 103.

the numpad-six key is a key equal to 102.

the numpad-slash key is a key equal to 111.

the numpad-three key is a key equal to 99.

the numpad-two key is a key equal to 98.

the numpad-zero key is a key equal to 96.

the o-key is a key equal to 79.

an offset is a number.

the one byte is a byte equal to 49.

the one key is a key equal to 49.

the one-half byte is a byte equal to 189.

the one-quarter byte is a byte equal to 188.

to open a file given a path:
  clear the i/o error.
  extract a directory from the path.
  if the directory is not in the file system, put "Directory '" then the directory then "' doesn't exist." into the i/o error; exit.
  set the path to read-write mode.
  privatize the path.
  null terminate the path.
  call "kernel32.dll" "CreateFileA" with the path's first and -1073741824 [generic_read+generic_write] and 0 and 0 and 4 [open_always] 
    and -2147483520 [file_flag_write_through or file_attribute_normal] and 0 returning the file.
  if the file is -1 [invalid_handle_value], put "Error opening file '" then the path then "'." into the i/o error; exit.

to open a file given a path and some milliseconds:
  start a timer.
  loop.
  open the file given the path.
  if the i/o error is blank, exit.
  if the timer's ticks are greater than the milliseconds, exit.
  repeat.

an operation is a string.

the orange color is a color.

an origin is a spot.

the osmosian font resource is a font resource.

the osmosian font source is a hex string equal to $00010000000B0080000300304F532F32BB41B2760000013800000056636D6170E2B9EDE9000005440000032867617370FFFF000300008BDC00000008676C79664268E45D00000A4800007A6868656164E4394351000000BC00000036686865610D54057A000000F400000024686D747868C6405100000190000003B46C6F6361A327C3220000086C000001DC6D6178700559021500000118000000206E616D659DA64946000084B0000004FA706F73745544E6B3000089AC00000230000100000001000091EDF0B35F0F3CF5000B080000000000BF91DAB800000000C0031E39FFBAFE4805CC071A00000009000100000000000000010000073EFE4E0043063D0005000105CC0001000000000000000000000000000000ED0001000000ED00DF00070104000400020010002F00420000040C000000020001000102FB019000050008059A05330000011B059A0533000003D100660212000002000000000000000000A00002AF500078FB0000000000000000484C20200040002025CA05D3FE510133073E01B26000019FDFF70000000003E8007F00C8000000C8000001900000025800CE02BC007804B0002F03B6004603E8005D04B00050019000780284006402840064046D0022046700400190005703E80064019000640320006B03E8003603E8006B03E8003503E8003203E8002803E8003C03E8006403E8006C03E8007203E8005A01D400640190005604B0002E04B0005704A9002104B000C804B00064043F002803E8003B0460003C03AC00050460000E03C000640467002104740011039E0006039F000D03D4004B03CD004A047B0022044C003504B0005603E80064051400490403004203B600350453000D038C0036037700280535001403DB001B03690028041D00210258004903200022025800490384004204A9004A0258004303E8002F03EF005A0320002803D400280363002F0334002103E1004303A5005001980064021C000D033B00190161005405350064038A0050049500430341002803D7004302AF0038033B002102A1001E0377003603200014041700360348001B031300140409001B02580042019000490258004E03E8005D043F0028043F0028046000360460000E044C003504B00056038C003603E8002203E8003203E8002F03E8002F03E8002F03E8002F03200028036300220363002F0363002F0363002F0190FFBA0190FFD90190FFD90190FFBE038A0020049500360495004304950043049500430495004303770036037700360377003603770036034F0042025800490320007E046D00210438007802580063049C0078041D008505CB005D0517004904F3006A02AE006B02E4005E04EC0043051400560495005E0564005D048F006404590042048F0042042B003603AC006403B3006B048F005004B0006403E800720319008B0320006A051E001A046C007E04B0005004B000C80190007104600042044C007203E8006404B0005604B0005104B0007804B0006B02FF0042043F0036043F003D04B00056051A0067042B002F04670056063D008C0320005D02C3000701ED007802010078046700500453006B031300140369002804B0005D0438005602BC006402BC006403E5007F0190002F01F400560320005D053C0069043F00280460000E043F00280460000E0460000E039E002F039E001A039E0006039E002E04B0005604B0005D04B0005D038C0036038C0036038C0036019000780320005703E8006502BC007801F4004902C3004903B60035033B0021041D00210409001B025800DC0453004A041D0064036900280313001403A50050038B005704380057039F005002580071032000A0032000AE04B0006A0507006B0578007F03E8007904B0004A000000020001000000000014000300010000011A0000010600000100000000000000010200000002000000000000000000000000000000010000030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F505152535455565758595A5B5C5D5E5F60610062636465666768696A6B6C6D6E6F707172737475767778797A7B7C7D7E7F808182838485868788898A8B8C8D8E8F909192939495969798999A009B9C9D9E9FA0A1A2A3A4A5A6A7A8A9AA03ABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBD0000BEBFC0C1C2C3C4C5C6C7C8C9CACBCCCD00CECFD0D1D2D3D4000000D5D60000D70004020E00000048004000050008007E00FF0131015301610178017E019202C702DA02DC037E2014201A201E202220262030203A204420AC2122212622022206220F22122215221A221E222B22482260226525CAFFFF0000002000A00131015201600178017D019202C602DA02DC037E20132018201C2020202620302039204420AC2122212622022206220F221122152219221E222B22482260226425CAFFFFFFE30000FFA1FF5CFF78FF41FF5DFF130000FDFBFDF8FCA0E09D000000000000E084E092E083E076E00FDF6ADF78DE96DEA1DE8B0000DEA50000DE74DE70DE5EDE2FDE30DAED00010000004600000000000000000000000000F8000000000000000000F200F600FA000000000000000000000000000000000000000000EA000000EA0000000000000000000000000000000300A20084008500EB009600DC0086008E008B009C00A800A30010008A00EC0083009300E600E7008D0097008800BF00D600E5009D00A900E900E800EA00A100AB00C500C300AC006200630090006400C7006500C400C600CB00C800C900CA00DD006600CE00CC00CD00AD006700E4009100D100CF00D0006800DF00E10089006A0069006B006D006C006E009F006F0071007000720073007500740076007700DE0078007A0079007B007D007C00B600A0007F007E0080008100E000E200B800D300D700B400B500C000B200B300C1008200BE0087009900E300BF00A40000004E004E004E004E007E00AC011A01A0021C028202A202E0031C037803AE03D203F2040E043A04B404EA054805A8060C068E06FA073807C60844087608AE08E80928096209C00A5C0ADC0B600BBE0C380CAC0CFC0D8E0DFE0E380E7C0ED60F1A0F9C0FFE113011941232134E13B013EC1446149E152C159815DA162C165A168616B416E8170617241794180E186A18D0194619A41A461AB21AE41B281B8C1BB41C2E1C741CE41D401DB21DEA1E3E1E881ECE1F201F8C1FD8201E207820CC20EC213E217821842190219C21A821B421C021CC21D821E421F021FC220822142220222C223822442250225C226822762282228E229A22A622B222BE22CA22D622E222EE22FA233A237023B6244824D024F0255425C2265C26DC273C275C278627E2284428EA295E29B029FA2A442A9A2AE22B362B8A2BC82C102C502C942CFA2D782DF82E562E842EA82EF22F5C2FC43010306430B830E430F030FC3108318631FA32123228327032B832DC32FE3336339833A433B033F63456348234AE34FA3518353A3582362A36363642364E365A36663672367E368A369636A236AE36BA36C636D236DE3702372A3762379637C037EA37F63802380E381A384A38B439343940394C399A39F63A1C3A643A943AD23B183B943C103CA83D163D340002007F0000036B0560001E003400001333173317053332151114071507111615062B01262722273534271127113617111711161D011617143B01113735363D0127232527BF2C2C3420011C24C00C0810193BE02AE67C140C080878080C1EF21C98080C2828FEC420056008080454FEE0AD93202CFE3C15175C0B0544CCAD9301142C01804088FED42CFEE093AD8C08040801D82C1493ADF0040408000200CEFF8F017105FB0011001C000001161511071517150623263D01273537113613161D01062322273437340131401008083840081008294008383B191405FB0732FE367DA172E5390732E5728F7D01DC39FA74083860405C10284C00000000020078030602300582000D001B000013321714071106232635112734370532170711062326351126353437D03F09140838400C44012C3F090C08384014440582601A16FE5440083801B4302F25046030FE704008380198161A2F250002002FFFFA048F04BA0047005000000116150714172127353633161D01173325321714230723151F013215062B0122271517150623223522272623161D010623263D013427232635363B01352635232635363B01263534131733321735262735014F40041C0104040838400424010C270D74CC1C20BA580838201C86200838440818714F2008384028E8400838C830D8400838B418BC38103C800C0C04BA0D27407B6D309440083894301440441010DC0F40400314AF204064E31CE32960400838604BCD083840048622083840767A6CFE24B418047F2D1C00000000030046FFE60346056000470052005C000001161D01071536331615142706071536333437161D01140706072207060F01161706072637222707060F012635343F0136352627060F022227353635363736333736373536333403363734333735060706150517333732373237220701E2400840287589272D537D1C40240C140E161622501403165938280903444162184093801C0C241D6073183B19182C2847192040280A1AF488380C041C406401402404480B0906122D5705600838202C38282338390C2408D0240701083840153B0F3D3C184070958A3F0828964C341C1804083839175C0A067A962F4233045C60502C5A3258143F05847409FD1456490804B01D23713328B07C30241C0005005D002E03A1056200190028003100450053000001161507060703072207150623263D01363F011237323736353605321F0115062326272635343734370716333637352306070133321716171514070623222F01353633263534171514071715071517343735262702CD402C693F5C4807090838400A263C4454061A5C17FE956A1E08414F5448382C6814201C15132C150F01CC20315F310334153BA8180C0B0908840C0408242C053305620838A4A4ECFEB0B84434400838404D57A0011CE844945044DC4C2C40D808382C4441234434DC28213F28063EFE6C40352B202557604C2C4044153F3E76081D0704102C24081848100C1C000300500006044005C2002E0035004400000133321F0115061507161F01333637363316151407060F01161506232235272307140723222F013637363F010335361715173337352603140F011514173332373637262F010138203A8A2420382C2C4404DE4E2A2240403BBD50280838401404B848209F350440486117146C088C2804081A0E7C4C38341781252744301005C2885C806D437462B29CB1532C083829274696406E5A405C5C680C0C704CCE7AA8402002182040B404C8286440FD900EDAC814110B500E227BA1440001007803260114057A0012000013331615140715140F012635363D0127363334C0045010301C400C0C0E16057A0E3A1715F0E9030408383369E4305809000000010064FFB0022005BC00260000011615140702150706151114171617161D0106232227262F01263511343736373637323736373601E04034A044243C23157C0838283854204814401B192636072133192105BC08382B19FEEF0F88761EFEEC885C501C83210440544B5594822E0100659F213B595B44501418000000010064FFB0022005BC00260000172635343712353736351134272627263D0136333217161F011615111407060706072207060706A44034A044243C23157C0838283854204814401B19263607213319215008382B1901110F88761E0114885C501C83210440544B5594822EFF0064A0213B595B4450141800010022009A042204D6003D0000011615140706071537363316151407060F0101170623222F0123061507062326353637363523220F01140726353437363F01352627353633321F0136373602E64018101CC02014403851536401480408382B45D80448201B1D40201C20040B8DEC284098AA4A64D60A08382C3C8024141C04D608380F316860048C1408382E16453348FE80184064F8C15F941C0A32CE7A4A0E60540B05083843213E423004F61610405C90857760000000010040FFC0042004200020000001062B0107131714072235030607232635363B01363F01260336333217133733160420083874D44C044044488A72A04008389465830C28380838430D48E0804002504030FE5440270D740188141C08384018140892010E4080FEBC34080000010057FEB9010F00BD0015000037161532171506071423263D013637353427263D013697680B050C1840401C08281008BD0C3028C04A4A4C08382058346C0719151720400000000001006401C2038402AA00110000011615140714050607232635363B0136253403444064FEE0C7554040083834A3018102AA0838371D081C1C1408384024280C000100640000012C0124000E0000133217161706231407263D01343736C43A0A160E0C3428601C0E01244C1751600B05093F2061174400000001006BFFB002EF05C80017000000171507020F01020706071423222734371312373413363302E7085090045C60440D0B48380824645048CC233505C84008ACFECC38F4FEB6965F097C401C9C011801169E4401B060000000030036000003AE0584002A002E00560000013316150623153332171615321D0107151407140706230723222726272627263D01343736373437343736171533350115141714171617163B0136353635363D0137352627262B01062326353437352306071407060F0101BE2040091B8C507858080C2844745080207C3C17612C182828174D58641B5508FEC02C581C34151334A474240C081C543C6415174040102838401731380584083838046868581C60F030518B3672A41C44065E406C3D7FE06266736D13650943287C0404FDE8E05C5C41530B2D0C1C18874D812744F054472D5C10083830180424200947324AC40000000001006BFFBD038705A500230000011615113633321714230415060723263534373633110623062B01263534333F02353601C740E8602D0B5CFE246E2E0840CC222E7D0B1E1620405C5854140805A50838FB282040402E12181808384D1F1403C47C1408384458883020400000010035FFD703C7055B003F0000001716171615140706072207060733361733321F0132170623222734272324071407232227343736373637363D0134272607060706070623263534373637363702A92F30101F6B1F6611D8391704D7EA0F612C490A05083520344122FEF3ED351F351B3219ADBE1FB32A95A428371D1815193D41622B8B7C054435314F905495A33672F0271D4828203C284030110328641A0A5848282597D709DE7E1472866B8B17351C40140838334D620A56120001003200000396057300420000013332171615140714070607061532171617161D0114070607060723220726353437363B01363F0135342726272627263534373637363723072126352227363B01172102B2402B15205058167A2C3197973D0C30315340BC5421AB407C4B5934D63630443AB248A824EC77351622048CFEA07409030838202C01680573321426264508602F5D16074F63AA4B35226934453321292E083A440F1D2943424F863C60351E0B19264D4C515D0B2F110B1A25430900010028000003D7054000450000013217071506151F0136373633161514070607151615333617363316151407061706070623222735342726270706232227263511363334371615071117253526353437353433020C2B150414040CAC67271940A02DBA340403082D1740342A0B141019472D0B24060AE42E2631271C0C202440100401140C143C05403050404F91D00448311C08384523254C04E4501A132008382B191D1A0E4E204050B2A62808603C24685C0200B409030A3270FDD428740459B383613480000001003C000003C00570005C000001321714230607060714231407150715141715333637363736373637333217161D0106070607060714072635343736373637363D013427232207220F011407140723170623222735263D013437351233343716150607323F0136373633036C270D74F64E804C30240C140410242A366E3246664C51333C0553AA06127E3C4078241CCF010C3C383860158738283C080808385A12140C1F1940401C101351780E46FC5805704044442C4341080B09104C94445C58703056327D174C14588A4278477DB71D1E92210B083824882739DF2D0E1A683D6B609C68315727092440FC346B41803933140144320A083856663C400C1C5C000000000200640000037B0573002C0047000001161514070607060722073237363F01321F01150706070607060714072227222726352227353437123F013637032315141F02331733363736373637323F013527060706150706019040400B29301806060F8C10DC5458241C03371D124E3B3DCC0C244C543C0A0624343C501F11880C1C20309030042A1A3C1C141812010C142E169CDB140573083A1089264A84AE2E7F395A154F74844BD42977585F150C111967764580216587014275B63901FC9B4F457543210C1634318E17697529644A0A133722BD2900000001006C00010384054000260000013217161514030607060F0206232635363F023437363F0123260F022635343736373237032C301414A82E0654594D27181C40131449615C17454008AA667A9E40AA6B4B0FE505403C161A18FEC88B01CDB0A4BE180838923898C912C65E7A7C0B1B30AE083842A031130800000000020072000003620574004E0062000001161514071407060714070615060F0115161F01333437343F0134371615140706070607161714171615140706070607140727232227222F013437363736352627263D01343736373437363736333413140706071516331716173336373637352726270232405C48142C2C14372104239128084858703C406867052F1D495B340838064A132D3C2C405F351A3E14383F414012BE681C173D38422E2D3F2084461A130D10012B7020243C24300850057408383D0B0B051010071D0F112D4704142C2C1C1173228288210B08383068893F32522B811858223664641E622622210B08288868684C78484B152143561A0C611734481D1B390B2007FD45179D7840186C200C0C0D433E864460234D0002005AFFB9039E0592003C0054000001321F0232171617151407150607060706070607220F022635363B0137343F01363736370607060F01232635263D0134373536373637363F013E01011507151633141733363736372627222F0126070607220702AE392F241810100A221C1C0C0B0D3D232880132D7440400838246C3478242420185868297738209C540C1C262D27497F403240FE700C312728046969646E03190F191222485086134F0592686060CA212F10142C68515F0C80C3102F5D1C2404083840240C0C641EA1D9375D6B293F0C32224D6B0C393334B34B433B2D6324241AFD82304C40580C0818684C7E89737C2C2C212F66A40000000200640014017003D0000E001E000001321732171506070623263534373603161D01140722070623263D0136373601041C2C1B091E422014403C15015C380923310F400D272B03D028382064281408386B6510FD94193B403D3730180838206349440000020056FEB9011E034000150024000037161532171506071423263D013637353427263D0136133217161706231407263D0134373697680B050C1840401C08281008573A0A160E0C3428601C0EBD0C3028C04A4A4C08382058346C07191517204002834C1751600B05093F20611744000001002EFFF9043E043900220000052227262726272627263534253637363736331615140506051516173217161716150603BA39637D878CDC2838240180CE626A622E2640FEC48CFEA477CD0894596740080754497354C8100418246349343033453C0838539D404C047E8A78354B08384000000002005700DC0437030C00120028000001331615062B010607220F012635343F01253613331615062B0107230723062326353433373336373603B74040083854FEA290805C40689C0138E12F4040083840E0548C748844405CA49448D44F030C083840301020100838410B181C30FE940838401410200838402010041000000000010021000004310440002200001332171617161716171615140506070607062326353425362535262722272627263536A539637D878CDC283824FE80CE626A622E2640013C8C015C77CD089459674008044054497354C8100418246349343033453C0838539D404C047E8A78354B0838400000000200C8FF4F040005A90033003F00000132173217161D0106070607060715141F01142B0126353734272635343F013637363D013427232207061506232635343736253603321716150623270722273603205E16124A100D634E4AB41034083C084004241854583A6A7C4414DE36D8181C403C2E0126509B5B1D10083818202F190B05A924A05739206F5D612F6A02042E9E38800D274C265A534534343012627A3E147C582C451F1808382B2D21630CFA7D3E1D215B06067D5A0000000100640000046804B80071000001331732171615161D011407060723222F0107232627263536333633321F010623263D01232215141F013237353633161D01363F01353427262726272623342F0123220706070615061D0116171633163B013637363F01161514070623062B0122272627263D0134373637363736373637340270603C50484C3C5030540434400430206C384C182434745A2A08083840145C443C13210838404315042C130507111A12580854922A31434814477962322236705E3A38342440783F15721A809E5A5B69703806220933204C1E4A04B8145480406888208E3E461A400C0C163652967C38385C4008381440722610241C40083878382C2C346B49372D012738090F085026A67E3A432180873140083A121242080838364A20483C2B518B45646D9B015704783B5920240F0000020028FFCE03FC05E5004B005800000116151406153217141F01163B01371615140F011417161716171617321506232227262F012227263523060714070623220706072207062326353437343F0122273437363713363F013437360B0106072207333F0127342735020C402C0D23444C1206108040603048083020041206080838410B13090C1B4928080D539838482222320614081824402430200B053420086C13191838281C6814080701108C8C504805E50A4337501B651287BB2C220A434B0B0F14B120365F27035D224D7D234721CF501E0D190C2E22C07B3B642C0D3B5441197C86303220785B012E44304817AC1DFE69FED63960183039C11683180002003BFF8803B505C80053005F000013161D0137330417321715060714071533321F011615171514070615070615070623263534373635363F01363F013526232627262B0107232227151715161D01161D010623263D01263D012735273527113735361311171532373437363526238340042C0145096810097F342C7183543C08985C3C3C101B1D404C2C1E0E68223A0C052F2735493B908A1817150814100838401014080808087008AC564C28081805C808384C041206BC0446960F2504483C4B2D5064328A5014542A2A381C0A32546011231E1E64283018447C29131C08105060BC4F2D381517304008381C1517448CAC60F82C01802C3440FEFCFEF82C145409573A16300001003C0000041D055F003E0000013316151427062B0106070607220706071407061513171615141F01371732373316151407252435222726272635270334373437363736373237363334373402D018618120340813393F01154F2341203C06042084849EEC0E4F084095FEF8FEFE1468590F50080630402C4C14480F21443C84055F31404E280E100B3B0A45085D0B1E8859FEF7450F1F1D3E3C04042E0A404F2805091C373514722A4E011C58841962473A073D2A40120E080000000200050000038D05C000330052000013161D013320151617161F01161715071406071407140706070607062723170623263537352627361726272227353F01273F0136171507151407151716171637363736353637363726363526232627222726239D4070010457212157241F09142B4830341C79582C5B29080808385408571D1058230D070110143F142116741410180B0D5B677116441D1F3523050C131926520F291DCF05C00838381C14200761304050189C858454112B0A2A30633A1709022440153B2C040E42490A95CC3CE0A0952A4B1575F804602C6B35E4FC318B302B6A16540C13352C5893751D6C43251418000001000E000004160520005300000116151407232723072315071105333217062B012227230723150715161F01363B01173215062B01222723222723220F012327072322272627353723220F0126353437363711372326353437363717363B01173303564058D82CA4381414017C843A0E0838406E56D02C0808102008AF41ACCC48083830171508273DA437B9140C04041052161C100804093F1C4060440408104054174534232DAC2CAC052008383B11080C1850FEF004504010080C2C30FD57446C204040101074040404CC5AF64C20400408382E460F0D0108480838491B0804040C08000000000100640000039C06060035000013161D013305331617331615062B01262723252311140717153637363734371615140F010514071517150623263D0127352735371334B8404001082C286C5C400838646D3320FEF83C09013672A26C58407884FEFE500808384008081004060608383E200C08083840080C20FEC2275D643C150F24100D0B0838420E202C100440C0E6400838DEC0FC603454020C2D0000000001002100000421058C0065000001161514071407060706070607060F0115140706071516171617333217333637363F0235263D0123060F012635343736373637343716151407060F011F011106071407060706071407232623222726272627263D0136373237323F01363734373633343736025D405C2C012738283C241D13102814104438354704325A281963380C241C4C048B2D2440B4313F0F755440301769085C0C0818301B6D4020287845173A1A2E623F510814280E0E0D0F3C431D48391F343B058C0838351F0A0E090F3F153153167E1418193F2B4D906775411B181B252B2D3C68F0462A0C47450808384765200C1923250F08382B152A1A086834FEF84C20244053450D270B0518180A6A7B81112F94605C5464706F050632440913280000010011FFAC04640581004B0000131615061506151117253526031136331615111217153733161514071516173217150623263D01032627052315171516070617062322272637273527220F0126353437363327113437363736E74006040801FF100C0838400C10780840B8180C0808083840240B05FE1904120D10070308383A060414090E302C18403430340C04020C1B05800A32354B5544FEE068421041010B0100400838FF00FEF333082C083848240C8FE19C204008382001B0173D3E04D734854A283540443E6D7134CB240408382B19208401206D4C364A1C000000000100060000036605A40027000001331615062B012215161D011311331615062321263536332111342735262307232635363B0137330246C0400838D434181CF4400838FD40400838014C1C10148CA0400838A0A03405A40838400C534514FEF4FD2008384008384002E032CE34800C0838400C0001000D000003450580002C0000013217321F011617110223220706150607062B012635263D013633321716173336373437343F01352627352736024E453F09032122243E120E0E5C2470883020C04408383E062C64102FAD602830382F500805809524558290FF00FEEC28622A2E2A4036223B2920405432160C5024682020C8E4F75C108940000001004B000203BC0600003B000013161517160722171536133F011615140F02161716171615062322272627262715161D01161732071516071407223F01262F0135363511273727368B400D010409121BFB94404044C8A097CD96224408381E4AC3246DEC081306070B122140440D06030210020A040D080600083846394969FF09010E881408383117BCA020D6C61933254044DF288A3804153F146CD6426A3A312D0B907181B35034B61F010BDB103A4000000001004A000003BE0574002B00001316151407150715031217161715373337363736371615142706230607230623222734270313353735343736B6401810040C1C0F091458BE3B65147C5AAA34604ED01C1A2A4038281804102014057408381C18686C04FE40FEED4D173908041E120E0C2429384207201B1734942B75013401C0106C34601C200000010022000004440554005B00000132171617321732173337363336373437363B011615161D0114071112173217150623263D01262F0111373522072207060F01060F01150715062322352627032723140715070615220F01150623263D0112373637363D0137343734011C353B21130B210729044016120543903018185C0C141C04060A083840140C1014093B1331291F18240C080C08384410446810041C2034060C040838401C1E10140C1C1C05546423D17C8CC464165226722418400E1A1C2167FEB0FED28E844C40083844B6D6B4016C68183C601A6A506C4408087874407450B0014088204C3CC08973F610344008384801568817850E1A58681E563800000000010035FFA303F3059E0040000013161D01161F01141716171617161735131134273536333217321711140711161706272227262726273427222726272635231507111311062326351103113711368140265290840818323E114B1C1C08382E160C0C1C271333453416173719495C151B16DE3C040C04083840040C080540083858056390156B0127295B2044640120016E10300C403848FE8646C6FEE28D7045439C106825700B753005EB32124830FEBCFEFFFE984008380158012501403001304000000100560000045A057800DE000001173733173733161F0116173217161D0107171507171507171514030607060706070607062322272227262726353327353727353727353727353727353727353727353727353727353727353727353727353437363B011615140F01171506231715071715071715071715071715071715071715071715071715071715071617161516171617163736373637343712352735372735373427342726272623350723272207060722072207220723171507171507171507171507171507141715062322272635332735372735372735372735372735372735363734373637363702EE04041C040410364624290F151330040404040404101418104E15614C8C60501933395F25174C0404040404040404040404040404040404040C0404040404243C200440240404091B0404040C0404040404040404040404040404040418281C1C142014695F605D5F30201804040404341805271D2F041C041E76081C0612130D0E1204040404040404040404045008382E16480404040404040404040404041418400745299705780404040406322C38285038380C04041C04041C04040461FEE63F2540854334511B0D28AC5D0F9977041C04041C04041C04041C04041C04041C04041C04041C04041034041C04041C04040453194808381B290C041038041C04041034041C04041C04041C04041C04041C04041C04041C04041C04A52B26121F41232538062E455D970E36013B40041C04041C041A4E1D131933340404043C0553245C58041C04041C04041C04041C04041C04377D1040386B5D041C04041C04041C04041C04041C04041058303C48404C340C0000020064FFE60390060C003400440000011615140714071533363F01331615161715140F022207062317151423151617061707062322272637263D01372635113F02361323071136373637363735262B010607010040181404875D68847C1E0ED0906417891E16040C160C11111C08383014030E0D041014141C164A0C18911F0967D5371428508147060C0838142845170C1C241018181A4A485FB5685C94141C100824CA1E383846403C5D9A962134182D37019488649C70FE9090FE9496061D478E76381C0B2500010049FF7B049D05BF006E000001331615142306070607060F031517151417141F01163B0137323735273427263536333217321F0137363F01262F0123060714072635343F01363B01161716130706071407161716173217062326352627262722270623060723222726273427263D0127353736371237363F010259204064163A6A2A261E381C1008404060643824580A2A804018083829230B415C307A0614146034407A0638405080153F2050506814141C5C60810B290B210B0838583B1917110A265E1A372920EA721A4A20300820182458406B454005BF083844140C47555761989844242C34424A2147322640300488083C2117403C505C40C262B2A5350C450B1A0A083830384408083867FEFF7CA781107C863A261A3C40182837450E26306036027804741626496B142C40908F45011438770D1C000000010042FFC403EA056E00CF000013321733363315373317373332171617150717150717150717150717151407060706071407011617161506232227012227343732373637363537273537342F01062335062307171507171507171507171507171507171507171507171507172317150717150717150717150717150717150717150717150717150716152317150717150717150623263D013727353727353727332735372735372735372735372735372735372635332735372735372733273537273537273537273537273537273537273537273537273537273536338E231D0442325C0C040404986C453704040404040404042C53675B1B180190522E1408382F81FE88301C680E26903820040404F8103B316C1C04040404040404040404040404040404040C040404040410040404040404040C04040404041804040404040408384004040404041804040404040C040404040404041004040404040C04040404040404040404040404040404040404040D33056E291404110404362C541D04041D04051C05041D0404101E318E3B460B0C19FEA45413171B4280014367306E2E3383292104041D0455270511041914041D04051D04041D04041D04041D04041D04051D04041D046F051D04041D045F0C04051C05041D04041D043A0C04051C05041D048832041D04041D04041177096E0D04041D04041D04BA041D04041D043A0D04041D04041D04041D043D33041D04041D0470041D04041D04051C05041D04041D04041D04041D04051C05041D0404108D0000000100350000037D056C004000000116150627060F010623060715171417161F011617161D01140706070623072225273633321F01363F01363D012627252726232627263D013637363732373237360243B11AB66F1547202B400C5942228BFC302C1B353A1E7F4D1F75FEFF09093D1FE5425A30351F1E67FEE1051A2D3340580D2423470F2F30356F056C5F389EB51020243C45533C3C0D0B1A22481A361C58402567394F9404BD20409508366E403F15602B115404141B35215740613343353C3428000001000DFFA3041705440026000001330415161506232523150711140716151706232227352637113706072207062326353437343702A7380120180A32FEFC1814030710083840100E0A14F16D1B352E16406CF20544220A181C40200478FDB471A2774F40407008ABF602A05C140A2820083832360E1C0000010036FFF20350055D0039000001161D010717150717031607060F0106070607232627262F023327113633161D01071307141716171617363F013637323727132735372735360310400404040406021B063A2C3814202040D44F2C4C200804040838400404043C214302B94711241D0A1107041004040408055D08380C04041C0404FD63F016414F5D2D0A0C20437C1DDB6C640402504008380C04FDC4043EB2634D154A0C30441073940402CC041C04041040000100280000033C04D8003A000001161514070607060F0214070607060F01062322272227353727332735372627262F02363332173217161F021533343F01133637363F013602FC404C241C0B0D24281C18280E0E18161A390F0903040804040410281D4F4C200838380C060E505040080824283C0F091311581604D808381779698F174D986C0E3A5E52145C2C1454240C0448041C04A2568898E49C40486CF5ABE02414204C6C010C2355264E941400010014FFF704F80573005800000116170F02030603070E01072627262726272627230306070607060726272627262726272627263726272627373617160F0116171607161716170617161F02363F033617160716071617161F023312371337363704D81D0314080C2A08541E0728384404111F3E0C0A17043A053B292F19353E0E0C183A112C241A1E3B04180C0B01060E383F0604090D20053710022F024C0229190456053216150E383D022003130D161F1C3D0447082A11082805711C3854542BFE4E5BFEB66E3B310307633A89C7510973FEED3A9586273918073D0B7D63554D8319918D311B650128403F050E38340E542E359050136218AC24444301E52CF08BDF3F05065455231F6021857BCB01125801BE5F6E440000000001001BFFF9039B05C9004700000116151407060F01171617161716171615142B0122272227262F01262726270607060706070306070623263534373637363736373526272635363332171617321733343736373633032F405467351430110B3533132148441830240D13212310271517154B1D2030162E5C0F19181C404048283937313F0B49500838331507310D33044C4F3D1D2705C908382C74F52F2844091B256F113F05375C4C3C284418192B14245F411490465EFF00093F1808381B75E044BF3D5D47041B458F154044025E400C6CC3514C000000010028FF81034405A4002700000116151407060F01060706070607060714072635263F013E01272627263D013633321716171237360304405C2C284C2A1A17191A16260140400E452C2E1A1381707C0A327076415F9C321B05A408381E8A5577D47D5F4197455F38CF320A0838C483A87FB726E688123A044074959D01B14B4400000000010021FFD103FC0547003400000132171615140714070306072207061507153605171615140726250722353437343736373437363F0123040722072635343732372403111B21103C20B92C23076560046101928C543873FE68D85C3070552F6E523C1004FEB0941F4D40781B5D018E05473C15171C501A42FEEA7544D87D530404281C2136382E1657042C4412823DAFB070129E6390381B34140838430D203B00000000010049FF1002290648001D000013211615062B011517110711331615062321223D01343711371127353437C90100400838D8080CFC400838FF00A0240C084406480838402C2CFD40A0FD800838403C0C1A2E0270A002B42C602F2500010022FFB002A605C8001700001332171215161B0116150623223526272603272603273536623523CC485064240838480B0D44605C0490500805C860FE50449EFEEAFEE89C1C407C095F96014AF4380134AC084000000000010049FF1002290648001D000005212635363B013527113711232635363321321D0114071107111715140701A9FF00400838D8080CFC4008380100A0240C0844F00838402C2C02C0A002800838403C0C192FFD90A0FD4C2C602E260001004203CD02FE0585001F00000132173217163316150623263526272306070607062326353437363736373637021E37150917382418083854263E04446C3375141440400785584419530585545884181C40191B1AA2404C16560C08383018124A3C40342400000001004A0000044A00A8001000002516151407230507232635363B01372533040A4080F0FE70A02040083820A00190E4A80838430D0C0C0838400C0C000100430460023305DC001000001332171617163332170623222F01263536831D5323813315401408382850A4940805DC481060285C403C785137400002002FFFD0039303E80039004B0000013304151617161D01161506231707170623222F01352207060F012326272627353637363736213334273427232207060714072635343736333603151633141733363F01352723200706070601A76001002C2C1C14060E0C04100838410B080A628B3D5080315F23191B3D7D4B3B013D1C40A8681E4E260E40402C4242269A1B1D2498257BB80430FEDD254E5A1F03E82D3F33A9B53388161A2C68045840683818403F2D0403492454209040891F4432861A1E180D27270D0A324A1A4818FCC804400C08243070B4283C26762E0000000001005AFFAA03BC05FE0051000013161714071506171617363F0136373637363F013316171617161D01140706070607060F01060F0223263534333637363736373237363D01262F0123060F010615060F02060722272627033537362726AC401426160803260B1844262E41431C3C14604D3B1D0B0C200A0A091B164A5C4D833C18204058C04040241612090B20101C203C283428742E1A10431439391A0C1A010C150A0205FE08671CC5FCB2375AB12854DC2D574E1E0A2604104C1448154B40662E13390460167A8C585C2004083844728E53450B5940352F745410141C141CA533A11740824C0F5193800185AC9C12AD4D0000010028000002E80448003D0000011615062B0107060706070607060F0115161716171617141733363536371615140706230607232227262326272635223D0136373637343736373637323702A8400838344434406513123A211F101408141018143824783F3540501E2E295B402C581D07101C340C172133454042322957104804480838401C2B196E0A27494C24605457050C24082C0C1013313705083834184C181040300735294B5C40AB096359182C541C0C401C0000020028FF9C03C80610002D0041000001160703141715173734371615062314071F01140722352627230607062B01223527363736373637363F01171336011F01333237363727352F01372706070615070602EE5C52180408603C40142C94280440441408043ABA3B1920C4280D1F30300F314E42726A212EFDF9184020089E4268040804040CAC2080402306104F45FDE874A4887C2427090838600533C4242D0B641B651DA32C6C99AFE34458172948303B0B01BB98FAAC702A7D3245043080A07C571137711764CE00000001002FFFCB032B040B0051000001333217141F011516151407060706071407060F012635343734373637363734273427232207220706070615111417163B0136373637363736331615140706072207062B012227262711343736353637363701B780354B30044078063E555F58015710406C6008554348282C58243C132536222438254F0C1B5528403309272940454F300F752E1A20B636380858582523194F040B7C1476180C08383F15091733150C0C090F0408383810110B0B10202527315A24485027834A1AFEE23D2F100F2613311249400838256046283D24505050015029C36C1430103319000000010021FF6A031305D1003E0000013332171615062322272227230615061507173336333615060F01220715061D011607160306232637362736273537060F012635343727363F013637323736021B2461175C08381D2F0A12405450100E04644B8C0845532E710C0E0106041D6038250B0905060442421840E40E14081C23350B393B05D11C2D33402C102D075C80509216213F40140E1604251F2C71A475FEF168367993A88C8B243017310408384B49B6625A4C3F45242400000000030043FE5503CB04390046005800710000013217161507161506070E01070E013315370516171417161D011407060706070623222723222F013534373437363335263D013637352227262F013437363732373335262735360115163B01363736353635342F01070607060315161733321F01333237363F0135262325272306072207140246216B180C440C4834503C50071C14010C3933402C282F5124382A6A3E8E405983081C883014100714294F3F15047C6779147C04460A08FED862222C255F44443408C83D2B50233D2F1831933C040E2E7F35104F15FEF804044C3C2D4F04394C310F30364E53F13C29073A460404040830094F3C1C205F35412B19133C249424406117286C18041517202632044C273D4C3F895D1B240424201040FDF41C5C0C0C2507F01C0E0A0838212365FD59544907200428353F2834780404111F640A00010050FFB7035805C3004A00001316150F011507113237323F013637363736331615161D01161D0107151706070623263527323D013437353427353427230607060706070607060714070607150623223527263511123736C840240C080B090D371C2E22113FA421602C140C1B090B181C401B080C141404195B412C07150A16181050081C08384004100A220B05C30838909F3480FDCC3CC0448937342828142C4F79146B41A04C54DB021E180838CF1430393394445C203D47074019940143095B4C182484028348405CA1224A02800181327000000000020064FFDF010805B800140020000013161D0107111715170706232237263D012711363337223D01343B011615071714B0400C1410100838471B1414062E26443C0840040404000838204CFE944C74DB2E40C5663250500164BCBC740C800D274C4C270002000DFE7001BD0540000B002C000001321D01142B01263537273413161D01141F02151407140706232635343736373637363735342703222735360121443C08400404404014282060A0452B40343F4D12262A0E1C300907080540740C800D274C4C27FEAD0838203C48E4DCDC877530745008382B194731104C2A4EE04583011880204000000000010019FFBA031D05C70044000013161D010615111733363F013437323736333437161514070623060706072207321716171615161F01062322272227262F011514071407062F013637363D013711343735368540010404261E1C5809671D1F5440382C2C294B1C200D23165E4B0DA92B2108083840801E5B2B55611308104D3203141301010805C7083840EB7CFECC1C17311819475014141808382E16282A2A1C3434705C23D1263F1D2040FEAC1E6230543A8278643C023B43889236588C01407AF93440000000010054FFB6011005AD0015000013161707110615131417062322273703343711342736A2402E1814040808384616140414021505AD084560FEC03F3DFDBE38D440A0B002464242011067561000000000010064FF7B04E203D400530000013217321715363734373332173217321711161707263F011127342723061506072207151407142326352637112735232207060F0106070607160706232637352635262711363316151114173637323736373637025488180903386C28602A360B150C0C140A62631B0C182030990C04100F0C4C400410084C34540A1E181C1418101414083868281C080C0838400C140406420D1F4F3903D44C24302C100B05506048FDE46A503738594C022448251726360D37A4A011567E0838743501182CF094054B6C2C5C851767394014C028315793290140400838FECC1D0349337C063A5E0E00000000010050FF96033803F2002E000013161511373637363B013217141F01161314171407223534272627263523060706070615140715062326351103353690404C48443E1E203E2A3424202C084044400F1D3C046E3E182C3010083840080803F20838FEE88C6B3130781A82C42BFEA79D2B2D0B70EAF613C1862A4A961A8659372212F440083801B00100D040000200430000043704140025004A00000116150733161F011615161D0106071407062B01262F012627262726273534373637363736330115141714171E0117333637363F0135262726232723220F01263534373633272307220706026B600454753B4018141C28708A2A807867613E32172121034046724C0C5D3FFE94283C2856B664644C1420141804520E2C44085C3840482616084C6C2E86200414093F1C1E4E582A3E155B608C303D6358142E3E2C4C095F352F80228A644C270D40FE246813491C3C3C3A261D5F3C34547454286C144C0C0838380C300848882F00000000020028FE4D031F044A0027003A0000131615140F01153637363B011617161115060714070607062716071607262736372736351134373613111716373637363734232627230607060706D240280810717464144F552C2A3A4C2E777E6E061B1B4F5701100D3222381C2C04817C6937171D2C171D1C5728384C48044A083810603C04183A6C0F6D2EFEFE0CDA47105C2A524F22CE7478231948AED649396601B065C358FE60FE2C3022635A6A20A9F81E0E2B243625440000010043FE4E03D6043C004E00000116151407220F010607060F01151417163B0136373637363D0136373633161D01140714070615070617363F0116151407060F01232227263F0123060706232627262F01353437363F013637363334037340701E32B45048A03C08B40E1A1477316E1614121E291F40382018271B3517351C40182E375C0C39132C1B27041C802266A828412B1470293F9850A45C54043C0838410B285024304D8F701467250C245081872D1340761628083820119715633FB1E7D2A035440408380F313F350E907DEAC740402027211C585020CC64342C582C44440700010038FFC602A80426002100000116170627060F0206170615070623263537343734032734373215173637363736020C7E1E3478800C541C1911090D0838400D0524184048101B1D2490180426246A6B717444982858988D485B4008385B33BE310147E42D0B8C84184C5E7216000000010021FFB1030D042A003900000116151427060F010607163B01051617321715140714071407140706232227222736333217323736373437352723263522273534373637363336023B4D913B9D1C2E342F1984013C41130B055E58246C42421246320A08382A3A1E52364E46F0C07831135629977A4E27042A3638441E066E1876401804192B284026B11B3108241351282840402848522A0F981C040B1D6020229062524C14000001001EFFB00272057C00300000011615140711363B011615062B01220714171417061F010706232237222735263726272637062326353437363311363736012640106E4E20400838206256050F0312070D15384B2007010E020C04101367194038641C100418057C0838462AFEA41C0838402427A55D682F433D6E8AF41C300C902D871C644408382E16440198324A2400000000010036FF95033603DD002F000013161D010715161F0136133727353633321715071715141714171506232227222726352302232227263D01343F013536A640300CB828296F200408383F09041C281808382E1609171C0462526BB96428080803DD0838C0C0C4495F10510153604C60406060489850AFB1352F084038B47E62FEBC8C51778C467E28B4400000010014000002F803F00035000001161514071407060F01060722072317150623222726272627222726272635263536333217161716171617161734373637363736373602B840283C1C1814190F0B09040408382E161E2A1834112B3014303408384020130D240C261E363228243C140C0B211803F008381E5E49BB557B541E6234140440380F3D0B5178453F475D8C1040943B553335265E5B211E5EBAAE496F026A1800010036FFCE03EE041C0047000001161506150207060706070623222722272635262723060F01060F0115062322272627262F01353633161D01163317363736373637363F01363332171517121F013336373637123303AE4030380C141C26121428390F0F11380C0C0414183854100808383D0B1C380B1D1008384009134035131C101F050E0E10152B3B1928281C0C042008181C2F19041C083BD838FECF6E61537A042A587EC63D2686306B8A933F082E436083A72F3EB08643093A86ACCD51452B5C5141179558326037C4FEC44E37946355E60108000001001BFFDE032B03F6003100000116151407060F01153217161D010623222F01070607060706070623263534373437363F0126272635363332171617363736029B40701E32080AB65808382B4DA440334D2329162615174040682B4D2C6448540838126639573D632503F608382E561F790804A0531D04406488604B99217317491008381E621FA1626E48541C2830403C1D439F3D380000010014FE4802F103EC002A000001161707060F01061507020F01062326373436373626272627262726273633161F0114173736373536373602B73901290814251824462424181C4007242F18242835633D59200D0838545BAC3418141D141E1803EC1552662283BE3C50C0FED46E761808600F64E12173305E8641C124304014E2F41044985A903462626E0001001BFFC803FC0421003B00000132171407171407060F0114070615373637361734371615060726070607060706232635343F013437343F02060F01060F0126353437363736333402DC2D0B0C043C712F3C6C20E0063E7469246F0E59545AB8AB2F55201440404074487018735A5815A318405C5ACE955C0421461517272521E1495C0FB23E0D650A193D080A03093D501F372964472A2016093D36637716B8106ACE35312834045605093E30411D69540D0000010042FF3E01FE0642003A00000133161514230615071514171617161D0114230715161507140F011F011615062B01222F011233373427232635343F013637352F01263D013437360192204070880C381523101C245C71141C429340083840A42849230D71286040543010182C401450A806420838443E0610347947443C2311207034084CBCA00F29D074140838408292010C9079270838390F2C261A30608C4F49403642540000010049FF74012D063400110000131615111615140714072635112227343734C54028284040320A2406340838FA5C1D231D43320A083805B440113F230000000001004EFF3E01FE0642003A00001723263534333635373534272627263D0134333735263537343F0127232635363B01321F010223071417331615140F010607151F01161D01140706AE2040706E0C1D1623101C245C71141C5D6440083840A41B42220E71286040543010182C341444A8C20838443F0510347947443C2311207034084CB6A01028D08E08384081A0FEFB9073270838390F2C261A30607F4E4A403550540001005D0168037D02B40026000001161D010623140723262F01262B0106150623263D0134373633321F0114173336353235323736033D40251B5C606B29305622105C1824407036227527903C4C140807051802B4083820AC2319112B2450434D2408382033713030700709251F144C24000000FFFF0028FFCE03FC07060222002400000003008E009D0145FFFF0028FF5D03FC070902220024008F000300D500A50198FFFF0036FE5D041705CA02220026FA6B000300D6016AFF8FFFFF000E0000041607060222002800000003008D00A20152FFFF0035FFA303F30711022200310000000300D4000A01CBFFFF00560000045A070D0222003200000003008E00EA014CFFFF0036FFF20350070D0222003800000003008E0070014CFFFF0022FFD0038605C802220044F3000002008D5C140000FFFF0032FFD0039605BA0222004403000003004300AAFFDEFFFF002FFFD0039305B2022200440000000200D357FA0000FFFF002FFFD0039305780222004400000002008E74B70000FFFF002FFFD003930589022200440000000200D4DE430000FFFF002FFFD003930599022200440000000300D5008E0028FFFF0028FE5D02E804B302220046006B000200D6388F0000FFFF0022FFCB031E05A702220048F3000002008D33F30000FFFF002FFFCB032B05AD0222004800000003004300A0FFD1FFFF002FFFCB032B05B8022200480000000200D331000000FFFF002FFFCB032B057E0222004800000002008E48BD0000FFFFFFBAFFDF01AA05AD022200D2F3000003008DFF4FFFF9FFFFFFD9FFDF01C905A0022200D200000002004396C40000FFFFFFD9FFDF01B605B8022200D20000004200D39400333340000000FFFFFFBEFFDF01C20571022200D200000003008EFF60FFB0FFFF0020FF96033C0582022200510000000200D4BB3C0000FFFF00360000042A05C802220052F3000003008D00D60014FFFF00430000043705CF022200520000000300430112FFF3FFFF00430000043705B8022200520000000300D300C00000FFFF00430000043705850222005200000003008E0112FFC4FFFF0043000004370589022200520000000200D443430000FFFF0036FF95033605A70222005800000002008D66F30000FFFF0036FF95033605A0022200580000000300430093FFC4FFFF0036FF95033605B8022200580000000200D338000000FFFF0036FF95033605710222005800000002008E57B0000000010042FF95030205B5002A00000116150F01153733373217142306071715161315062B01222734373503273507232635363B01373534373401CA401C041404C82D0B708E1A040C40163A083F0920400CAC4040083840A82405B50A32883CE4041040440C0814049EFDE244A0601A264002348C081008384010F85B752700000002004903CE020905A600160021000001321732171617150623062322272627263D01343F0136071514173F0135342707060161231D2E162103111B2A325771243C105458356198200828403005A62838382C40785C2C03411652202D473C30F4300E26342C281B352C16000001007E003C02A205280031000001161D0133161506232227230607061D011433143B013237363316150623140723150623263D012227263D01343F01273536019640505C08381A16205262408450143B15151740183068180838407A461CC01C040805280838CC193B401411776A52283C082C1008385C0D13F0400838FC58332120E4A01444C84000000000010021FFAA041D058A0068000001321732173217062322272623270607061507220715161F012533161514072207171506070607220733173217161F013326353633321F01151407062B01222722272627262F01232207062B0126353437363732373523072326353433363727342735363336373637029962261F2D1B0908382636290F28AA16543010081A1A2801040840701B89040913211F0606346431B33F2D2808140838313B043820202014701040285C1B790864202C2117204094283C070904CC204064088428301B1D171D4296058A243C38403C180409171937443444223E40340838410B201CA05D172D3F1020683A0A18161A406014202E16243C302626161A0830180838317B2173449034083844081C4C0C4C707C1D43512300000000020078FF88039805B8004B0060000005262726353633321716173336373526272627263D0134373637352635223D01343F01363B01321716150623222F0123220F0115163316171617161716171514231407151615171407060714133427262F0123060F011514171617153637363F01021496461808381D2F235118625E52C656C64C70445C40084848614F1C4147280838263224084868180D1B1D7B028A6404160E1C6C6404607D2BA89C0C380C808E1610386CC40C581B3504781A42181C402C160E2890344C48156F4F9920384C1C1004365A1C402D633440442C1C404408583C24641947084C5820175140701E3204453334625E7D070C02F45854090B0C1523100C83113E42040C041814040001006301CF01F3038D0012000001333217161D01140F0123263D013437363334012425463F2545459373402A37038D454834504E46190C702380375E09000000020078FF310424059D003200410000013217361707151714171106232635112F01112307151615161503110623263511343734272326232227222726353437363736011417161732173503350607060706030C76224D0B080828083840280888080C1C0C0838400C0C14682C3F4D3480207C32BEADFE6770451F554F0C69672B3140059D0804404CE8EC40BCFD5C4008380294F0FC01041CF0ADB78D4FFEF4FEAC400838014039E73349242C983B79AC44355738FE608A5A190F2004013CF4164214282700000000010085002103790551004B00000133161516151714070623151617321F01150607060706232227343336373637363D0126232627263534373637363537353427262B010607060F01111716150623222F011134373637363734022D20745808902616715B2B29040953CB71E1432D0B64C672B410140E224167A0341E5E6C04300828383B45274510182408383B2918582D1F6B29055118185321507E5E28042F499C3C604B558B194040442C2C691F20107054442016462A1A34205C10101C311F18122A0C5828FE7C74261E407480016486463A0A4404140000000004005D003C05490558002500480065006E000001333217161716173217140706070607232227262726272635263D0134373635363316153334150623220706072207151417161F01163B013637363F013403272627262B012207263517321F011506230607231F0132170623222F02150623263511343334171533323735342B01033920607C4F1D7E120F09381A828662A0959B38942D2F2C0C789C88403C04053713C57507090320153B60B4809C70901632046C2010783038281E4E3C3CB232141C241C6404745C281808382B6D445C083840641C0436726440055890403CF8949C824658585E12500E7E22523A0E2B3D80AC84A60A8C0927606848DC734D3CA8361638344C681983137544900104403A5E48180927E86440205C20185C485840743040DC4008380240440787643404340000030049005E04C50532001E003B0059000001331617161532171617161716151407060F01232227262F0135343736373601151617163B013237323736353427262734272627342723220706150625321506232723061507151633163B01371615140722272227263D01343702A9205692301D3F37250B1110B459A78020BBE931470C6439CB83FE952745C0683482562884302439532407694428466AC85401A4A00838401084107739163A082C40605E4633A11C6C05320A56291B685D6711634F41E18B53350C941B8930C089A37DBB48FD68C46F21683C9041735E7E9769150F15270E0A40D72590945040101D1B101880180808383F0924A423194031570002006A031304760577002600420000013217161715062322353427060706070623222F01150623263D013437343732171417333637360533161514230623161D01170623222722032707232635343336333603C2430D491B083840401C08090B181C2341240838404024353720043C1C18FE442040701B11101408383A06130908642040706A5617057780EB9124405C18E41F35021E18481CD8400838E0763A0903580B19725E1808083844107583246C4044014C2C10083844140F0000000001006B0438025B05B4001000000017140F0106232227363332373637363302530894A450283808144015338123531D05B4403751783C405C286010480000000002005E04E5026205C1000D0019000001321D0106231715062322273536071615140F0123263D01363301EA78050B04193B3B150BDF4C54182040155305C140042804105C5C40400411372F410408382058000000010043FF24047B0474003E0000011615140F01331617161506232723060717331615062B012F0107140722070623263534371327232227263536331F013317132325232635363B01053337360377402C4434A147180838CC501448F84840083840D854443807091B1D40285C04D073791408388040906C6004FEE0C0400838C00120245434047408382028BC161A181C402462CE1C0838401808E8198B381C0A322F5101280438161A40240404012C1008384010E85800000200560064049E0524003B004200000132151733253332171423072315161F01331615062B012715132116150623211407263D010335210607060F0226353437343F013637363736373403333427060F0102824004200144042D0B8CF40C3014E44840083864B4240108400838FEF0384024FED4432D101C3024402458504B31333D2B0978D4401A265405245C3418404810049587040838400410FEA40838401A0A0838600160049C40125A4C080838163E2490AC8F4570643F452DFDCF37D1225A880003005EFF24043A05F00042005D0071000001161D01060F011714071516173217161D01020714070607062B01222706151407140F01263534373437343F01263D01373437363736373637363B01321F0133363736011514173637363736373437363727262B0106070615060706150601140F01060F0133363736373637363D0127262703CA402430140424311B1133281329500D67AA36804A1618284C204030281C04A8283C181C10249B294315402F652804420618FD386C3B593B310D4F1C2222046D1B245A2A50210F5018024864502C346898347843112E261848172105F0083820802828241F1104393B783E1A60FEEC1C16863359540C290F0B3D27510808381B3D183C1A2A187FBDA0B0498728580F5DAB0120441C505C24FC4CA8615BA5C3D23A377D0B295127045017413E323838906C3A016A0AAAAC9F69FC04403F3943618A42548C1147000003005D011E04ED03BA002D003C004E00000132171617161F01151407062B012627262706070623072627342F01353633343732173637343733321F013736331706070615161F0133323735262F0105231514171417323736372627230615060703954A2E8004282C084C415B204C64702C521E622A3C5C50500818282C1C185F3530404C341878451728412F3852823028441027356CFD48104450263622523814286C293703BA448C20443420602E4220073948545A425C081B7112AA2860580E06182E0205076C28804C7C3F3D2818833108203C256F7C8014108C243C443D5F6D13130D0B210002006400000420043C00230036000001161D01253316150623222723051407150623263D01343F01230607263534373637353601331615062322272322070607263534372536022840011C405C08381A162CFEE428083840200804E35D406823F908018810600838171504B1DB77AD4070016068043C0838C008193B401408817F40400838203A7664181C0838410B0C1CCC40FCA4153B4010300C240838410B381C0000020042003C041603F0001E002C000001161514070607060F02041716150623242526272635343F013637363736013305331615062B012523263536031E40346B3D6854702401E3911C0838FEDBFEF5765A40749884204C486EFDC2C00180E0400838E0FE80C0400803F008382B19681C68204C201C181B1D401C0C14180838392B684E1A482870FCD40808384008083840000000020042003C041603F0001E002C000000171617161F0116151407060704052227343736252F012627262726353437001714072305232227343733253301646E484C20849874405A76FEF5FEDB38081C9101E3247054683D6B344002A00840C0FE80E0380840E00180C003F07028481A4E682B39380818140C1C401D1B181C204C20681C68192B3808FCD440380808403808080000010036FFC403DA0584003C000013321516171633373637363316151407220F0115331615062B011517211615062B011711062326351127232235363317333527232635363B010027353676442672B50BEC23511513407C105C8CB8400838B80C0110400838F004083840088CA0083840900CC8400838ACFE9D31080584645183ACD80C6C0C08382D73607C0C083840047C08384050FEA040083801743C504010047C0838400126CA20400000010064FF1D031C03250030000001161D0116153217161506232227222706070623222723031423263D011332373637363B01161D0114173337363F013536029C40140606200838331D0A062020342C5038046C4040680A0E2513093B04402C044029130C080325083834739D30281C4050241F3D4460FE4C50083820019CE09527640838E08C2064417748344000000002006BFFC4032F04900028003900000132171615161D011407062314072322272635343736373637332F01262B0107150623263D01343736131433163B01323F01352723060714070601A3833184543C465230205A8E38440A724070243C342F2114C00838403C22A21C583808582C0C0C346F5D2810049060EA46C9A760B0486805078C2692924A264E1F19B46C600850400838602B2D20FC786460688460800C500A362200000001005000570410054B0038000001331615142304231617161716151407060706070607151617163B011615062B0122272627263D013437363736373637352726272635363337039C204064FDCC2836AA5C5C60540864497F327A63FD7FC13040083830C28EE458C4A04E52564A063E407DAB80191BCC054B08384494305C4430442C3E060B25255B0D7F04231D280838402820143A2A1039834C24461E0917042057616034542800010064FF95044803FD0028000013163321363316151407061D0113150623263D01033534372122270711100706232635363511363334C8AD5301B44D3F4034140C0838400C18FE3045830824161A4014101403FD241008381656497B24FE70F0400838F0019010A74D1820FE4CFE8E3A140A32A2E201C08C0E000000010072FEE1035A0651002D0000013217140F0106070607061511161511140F011407060F012635343736373637363F01113427113437363736373403222D0B4844035D40180820183488365A184048063E0F590D2F0C205C3F292054065140380C38174558801222FE987F6DFEE0581C740B8515470408382C280E1E045C027E0C014C627E01608BB9570D37391A000002008B035C02A705C80020002A00000133321F0115171407222707232227263D01363F0133161735342F0123072635341315141F013332372623011F60C23E240440301C3840693B74134544A03913581C7030404C6024481D070E3205C8A08C709C270D480C28275528720A040810044B29040C08383EFEAA180D23040C400002006A034802B60610001A002C00000132171417161D01062306072326352627263D0134373637333536171407270607061D0116173317333237352601B6343850442331313360942666147018701408403818333120452B242C44390F19061050155F932580A025070F15156B290F609E5A22260C40B01A0A040A3E2838644A1A085C647500000001001AFFD804A6042C00470000013332173217161532173217151407331615062321263534373637363D0126272627222722272307230615071516171617161716150623212635363B012F023534373637363B0101F28017212765940616090350C4400838FEA040382C18300C1808640E3A2A12604C4C3C402A2202562F15280838FEA0400838DC683430480844296B14042C184C995FB824C024B808384008382E16184C651BA425BB33752C14102C0C5CC0B632156F38301428400838409078BCCC394F2C30300000000003007EFFDE040A03FE003F004B005A000001321F0233363B0132171617151407060F01141F013633161D010623222717150623263D0107222726353437363B01373326272627230615142326353437360115173336353735232723220123151417163337353427342B01060172363E203004502020B6361008241C5C98A4581123400838BF6D0C08384080647C383C2014344C601C301C14185040406422015E0410C4140480140BFE77107C1513601C08643303FE503C783834133940153B4329202282141C083820407894204008383408A03E722B2D140CD547440C13654808389D372CFE7048141937202808FED40C3B690C080C3C68100C0000030050FEA00428051C0033004200550000013316151407060732171617161D01140F010607062B0122270306232635343F012627263D013637363F01363733173337363736011516173613373527230615061506250307151F013332373237363F01353427263503C8204044385021271D37302C382755A523402D73C40D3F4078703F59180C1407318413AD60401458323E15FD53224A71872820448C642E0206C8745C142818842C300A2E045438051C08383A06448C783D4F4F6160144C6848244848FE886C083845CFDC1F6D181CC0571D235980191F10944E460CFD28983C30D001144408081715541850C4FE7CD80830043C60076504702B75700C00000200C8FF4F040005A90033003F00000522272227263D0136373637363735342F01343B0116150714171615140F010607061D011417333237363536331615140706050613222726353633173732170601A85E16124A100D634E4AB41034083C084004241854583A6A7C4414DE36D8181C403C2EFEDA509B5A1E10083818202F190BB124A05739206F5D612F6A02042E9E38800D274C265A534534343012627A3E147C582C451F1808382B2D20640C05833E1E205B06067C5B00000000020071FF8F010D05FB0011001C00001627112735373534373217150715171114070235263536333217151407950810084038080810404814193B380840713D01F6849879F234083CF279AA85FE1D3508058C4C28105C40603808000001004200FD03EE0305001400001321053316151417150623263D0127232521263536820140018060400C0838400C20FE80FEC040080305080838859B6040083860E0080838400000010072FFD803E605AC0031000001331615142306071423161D01030623072227262726272306151423263D013437363F013217141317333711340335343736038620405C21C71834041030143F290C503A1E04544040445721203C20800C040434D08405AC0838400B0908E9FFC0FE2CB804940FD56761DB214808382013C1CF0D085C32FEF6243C01BCEB010520590B04000000010064FF4603A00642004B00000133161532170623222F012307140F01140F011517331615062B012715061506070607060F012322272635273437161D013217333736353735343735232635363B013534373437343736373602EC20800E0608382418240C28441C1C0480044008380480180A12294F0F4918401D53180440400E12183C4C14147C4008387C20204804542E0642142C2C4024083C175D7C2C68408C0408384004345FD110DC6F552A2E04403014242D0B0838101050429A9C54416B280838408C596739671F69255B180000000002005600AE0469032000240049000001333217163B013237363316151407062B012227262F01230607060714072635343736333413333217163B013237363316151407062B012227262F01230607060714072635343736333401A560334D6038781F25242C40543F396071471F551C7C10302F353840703C346160334D6038781F25242C40543F396071471F551C7C10302F353840703C340320446844440838206C3C3C14540811072F191A0A0838383C3C14FEBA446844440838206C3C3C14540811072F191A0A0838383C3C140000020051FFC50431042D001D002E0000013215161716171613321706230F012307230607232635343713363736371706070306153337333237262726272627023D441A323C7037710B0514406C809080D44F25084040A44440035D0434408C20E480A4761E494F5E364A02042D707E423DEB41FEF1285C1004080A16083818980198D9672375E85DC7FEA44A0E080CBF71C53F6729000000000200780000042C03F0001B0035000001161514070607061516171615062322272627263534373637363536051615140703060716171617161506232227262726353437133603BC4044693784C672600838206859BF44A435475408FEB04034E41C3806AA462E1008382D9F534D184CF84803F00A32465285639B11856B23354048578133254AB65D5B6C14401008381C38FEBC1C580B853F19151740903A4A28141C64016070000002006B0000041F03F0001B00350000001714171617161514070607062322273437363734272627263534370417131615140706070623222734373637363726270326353437011308544735A444BF59682038086072C6843769444001B848F84C184D539F2D3808102E46AA06381CE4344003F040146C5B5DB64A25338157484035236B85119B63855246320A1070FEA0641C14284A3A90401715193F850B581C0144381C380800000300420013029A00BA00080011001A00003716151407263D01361736333217062B01260526353437161D01068260604008D4153B3B1508382040013C60604008BA153B3B150838204060606040080F153B3B1508382040FFFF0036FF6A040A071A022200240E9C0003004300FD013EFFFF003DFF92041107170222002415C4000300D4003601D1FFFF00560000045A0703022200320000000300D4007401BD00020067005704AB05330039005800000116172116150623211617113337331615062B01072327230607060F011721321D01062327212723062B0126273427263D0137363F01363B01341714070607060722072207151633161F01333635363736353635112623262301D34D5B0170400838FEE01424C02C40400838342CCC040418100B211008016CA00A3264FEC0800C5020405662442C1C090B4C64480C2C38511B12160705070118143C242C241C3F0D3C1C3729261E0533064A083840247CFEF40808384008045765095710083C0C4008083812760D5F6C5CA0900864C8981B77121A597F23894C14A48C661A1C0C0C3E265A524F550110BC400003002F005703C303A7003300430050000001321716151734373437333217161D010607062B01161F0236331615140F0122272635230607062B0122272635113437363736170F0115161733323F01363D0126233425150733363536373534272306014B1824741C702C60424E2026324C2078253740281424404C2C619B2004175536661C246C48382448403080141C481813213C1C160E01041068301014304C3003A71C59232066360E064C392320873D3C93293014200838322608AC3B11573D60504E2601002F692C7C4888C844E42D2734382A1AD4641F0D306818240C48042410180000000001005601AA03F6022E000B000013172116150623212722273486F00240400838FDC0EC270D022E0408384004402B000001008C01B905CC02390009000013211615062321263536CC04C0400838FB404008023908384008384000000002005D037002A105D8001C00300000011615140714070607220715373316150623222F0135343734373633360516151407060715333217062322273536373633012D40302810180C04041040193B41330C242C3F0D2001484050160A083E0E153B5B29281C442005D808382B150A2E1E5244640408385C5038605E4623495C141008381C684B0D78605C74D07E2668000200070341024B05A9001C00300000012635343734373637323735072326353633321F0115140714070623062526353437363735232227363332171506070623017B40302810180C04041040193B41330C242C3F0D20FEB84050160A083D0F153B5B29281C4420034108382B150A2E1E5244640408385C5038605E4623495C141008381C684B0D78605C74D07E2668000100780333018405A70014000001331615062307061D013217062B01222F01343736012420400838301C4014093F204C1C04581F05A70838407046661C5C608C4CAD9B54000000000100780335018405A90014000013232635363337363D012227363B01321F01140706D820400838301C4014093F204C1C04581F03350838407046661C5C608C4CAD9B5400030050003C03F003C0000A00150021000001171615140723222735360117211615062321263536013217142B01222F0134333402106C2054283B1508FEB82C02F4400838FD00600801E0361A44202F25043403C028151F621E5C4040FE8C08083840093F40FECC786444147C0500000002006B000003C705880028003E000001161D01161716171617161F0114230603060723171506232227262726272627263D0134371237363717060706071516171615161733123735272627262F010247641010251F1E461D27101C4157150B04040838373D224259335D1B6C48FD0361170823612E86501484356F0477452C156F17351405881252381331315719734335387065FED92D67041040781D6F815F5F417616084430012B259612C8537142960458309C2041B701924A18543B8D47592C00FFFF0014FE4802F105770222005C00000002008E3CB60000FFFF0028FF81034406FA0222003C00000003008E006801390001005DFFDE04550572002B0000011615140F0106072207060706150607060714070607062326353437363F01363736373637363736373237360415402C6C2B39085820107059171C54742C041B1D40445E6648521638243E322739164E072125057208381937D03769801B319A0E55372F61097F342C1C083835576682705335375941532D6B0FA94430000001005600AD03BA050D0042000001331615062B010607060F0121161506232107211615062321141716331417161506232227222726352635232635363B01363F0127262726353633173336373633363702F640400838343A564C2820019C400838FE282001F4400838FE00B4304C441C0A3224385662903060400838640616040454442408388C28104479332E5E050D0838400133264A4C083840600838405E861C0B0D1B1D4014507F1D395708384001570404100418244010119F84290F0001006400A0023C039400190000011615140F01153217161F010623222726272635343F0136373601FC40A890226E77210408381F4D4157886C685A2A15039408382FD1800468442C18403C25533E3E2B555C71473000000001006400A0023C0394001900001217161F01161514070607062322273736373633352726353437CF152A5A686C8857414D1F38080421776E2290A84003943047715C552B3E3E53253C40182C44680480D12F38080000000001007FFFF9038305990033000001161D01133336331615142307231617211615062321121D010623263D01340323223D013633173303232722273633173503353601BF40088C3339405C449009130118400838FEF8340838403458A00A3264441804D42D0B0B2DD008080599083820FEE40C0838400CB15B083840FEF34B80400838803A011E3C0C4008010C04404004040118204000000001002F022A0147033E00100000133332153217140F012227222F01343736B9265011075117123A312E053E20033E6E383B2E051E551A352032000000010056FF25016201990014000017232635363337363D012227363B01321F01140706B620400838301C4014093F204C1C04581FDB0838407046661C5C608C4CAD9B54000002005DFED402A1013C001C00300000012635343734373637323735072326353633321F011514071407062306252635343736373523222736333217150607062301D140302810180C04041040193B41330C242C3F0D20FEB84050160A083D0F153B5B29281C4420FED408382C140A2E1F5144640408385C5038605E4623495C141008381D674B0D78605C74D07D276800070069006A04EC04AA00190033003F00520065006D00740000011615140F0106070607062314072635363736373637363F0136053217141F0214071407232227222F01373437363B0117333417061507333217333527342301321F01151423140723222722273534373237051737161F0115140706232227263D01363336051517333527230605151737352706037740A0649D0F32A64507244009BB581C02BA2B496415FDCD2050282C0820584061172C30041C4015170C0404141818040F196440140323325E144028401850260E4C2113FE6818242F550460290F6751141B1D3E01C230141C0417FE3B3C28283C04AA08382DE788AB3147B570090308384EBE6D330ED2495FAC10483C112740383824161A1C4C3854313710040B770D23381410540CFE285C4040A00B05385C803226180C0404086418602C5C18602711207C5088541C681810500C2034302433FFFF0028FF6403FC0718022200240096000300D300560160FFFF000E00000416070A022200280000000300D300740152FFFF0028FF7703FC070D0222002400A90003008D00970159FFFF000E0000041607070222002800000003008E00910146FFFF000E0000041607070222002800000003004300DD012BFFFF002FFFA3038F07140222002C29A30003008DFFEB0160FFFF001AFF95037A070B0222002C1495000300D3FFE60153FFFF00060000036607000222002C00000003008E0027013FFFFF002EFFB0038E07070222002C28B0000300430053012BFFFF0056FFCB045A06FA0222003200CB0003008D00E70146FFFF005DFFBD046107040222003207BD000300D300CC014CFFFF005DFF8F046106DE02220032078F00030043017E0102FFFF0036FFF2035006F20222003800000003008D006E013EFFFF0036FFF203500718022200380000000300D300440160FFFF0036FFF20350070002220038000000030043006A012400010078FFDF011C04000014000013161D0107111715170706232237263D0127113633C4400C1410100838471B1414062E04000838204CFE944C74DB2E40C5663250500164BC000000010057042402AB05B800160000013217161716150623222726270706232635343F01363701DB2E162A4A1808382B194616C84F1D403490495B05B8387153181C40344844A44008382B19783163000000010065043E0381054600240000013316171617163B01363F0116151407062B012227222F0123060722070623263D013437360175202B5D302C3B19081C2C2440682711203781103C38047A061C041824406816054603350B25201B41080838345C1450241411173424083820323E190002007803F50250057100130020000001161716151407062B012627263D01343F0136330715173337352623272306150601685F31583C38306047612C3034164A405C4830283C0404381605710C24442C77254008382F1D2022364824D0041C3014340411072A0000010049FECE017D00D6001A0000251615073217140722070623263D013437363D0123263534373637012540141D0F9C1513161A4044702840481F11D6083844788F4128140838203B052F2D2008382B453701000001004903FC02710574001900001332171617343732353633161506230607140722272627263536892E1621877808182440191B51333C30683C3C24080574380A96146C0C24083854454B210B804527321A4000FFFF0035FFB6037D07090222003600B6000300D7006C0195FFFF0021FFB1030D05D1022200560000000200D7275D0000FFFF0021FFD103FC07090222003D0000000300D7008A0195FFFF001BFFC803FC05E50222005D0000000200D772710000000200DCFF7A01780606000F001D000001161514071507150623263D0137353613161D0117150623263D01273536013840100C0838400C151F400C0838400C08060608381715D0A0A0400838A0A0E05CFBF40838A0A0C0400838C0A0A04000000002004A006B03FA053F0030004A000001161D01373337333217161F0115140706070607062322273433353327352306070623263534373637363D01342F0135361723061D01161D0136371615140F011136373637363D01022B01013E401C348C60466A503C044C7D9B65CB3F212D0B580404042B4115174048293F2C200808B4102420AD4B4070C8A781304C30488468053F0838080410545FCD4CC026A675533937104044083CC40D2F100838311B26120A0A4C9BED684040C4070920C8B4282C0C0838410B30FEF0315F184C7410D4012C0000030064000003B004980021003F00580000011615140706071716150623222F0106232635343736332627263522273633321736033217363332171417161D01140706230723202F013437363736373237361723070607060F0115163B013237363F013534273427263506028040383A12BC180A322E6A7090244034410B021E600B050838199F8E42231115135379403C5079375080FED149041C19378C20092F2236204C1C404B110432CA743755300C14585C4814049808382E16271544181C4030287808382B1934090B360628405C84FE401C0C6C073553314077755C14C84861173F2DA212280880342A464331045864301F2D40542F3D1B2912120C00FFFF0028FF4B034407000222003C00CA0003008D0045014CFFFF0014FE4802F105A00222005C00000002008D40EC000000020050FFF9034C05790024003300001316150715333217321716173217151407060714052315062307263D013735273711271136131517113336373637352726272623984008B49D731359152B09033C2567FED474062E18400C08081409771458F81C64182813357153057908382CC0687402A22440791B291F1814A8BC040838204CD02C2C012CE0014060FE5404D0FEE80917202058840B4D5800020057FE70031B05100030003E0000133215131533321716151714070607060723150607150706232635343735363735232635363B01033523263536333503341315133325363735342726232623B7441C80CD2F84047C5389057F18100C1018245C280C100840083808080840083820A8080C01043D27482E3A153F051070FED00468DA6E3C3D573414091B7041BF205C24163A241C10BC505C0838400138BC0838400401682DFDE7BCFED0441E2E04617F700800000000010057017C03B70240001500001316053317331617161506232227232723242726353697600100402CB433492408383933B42C34FECD511C0802401818080C041824400C081C1C1B1D4000000100500099033803A9002F0000011615140706071517141714171615062322272627071407062B0126353437343736372627263536333217161737363702F8404402B2843020140838375D3E2E885060140C405068017F20C4300838232D9A3E88453303A9083820441BA9046C093B0612161A40882828880A427008382947085C08781C80321E4038623288632D0000010071033401F105BC001D000001161D011615173316150623212635363B01372F010623263534373637340131400C0430400838FF00400838480404041E1E4030074105BC083880A89C0408384008384010DC1C2008381D3316422D000000000100A0034802B805C4002A00000116153217321D011407060F011533321D010623272126353437363F0135262B01060706232635343736330160B01D1710206A3220A0A00A3264FF005C8832421C0B69200533141440281C5405C40917346420601C701814043C0C4008193B386C1E3E2070101C500C08381D4358000100AE035502A605D5003000000133321F0114073217161D01140F011407232635363B01373237323734272627263534373437352723220F01263536333401624093211434362E0C5C7844A04008389460210B07115421471878141C80191F1C40184005D554542329741414202A6230090B08384024201C38141315181C3C1C09031004240408385C0C000003006A000004520554001D0035005700000116151117331615062B0107222734333527352306232635343734373536051615140706070607060706232635363F023637363736033332151615140F013316150623210722273437363F013523220706232635363334014E40082440083854742D0B5C0804181C4034440802B840B88331296F8F7D193B40046C84B43A5EB44815A5207C146C18D0400838FEEC542D0B6023450C281808181C401C2405540838FE6C280838401040440424B41808382B190A4E284018083828F8B0504D8FCBC57008384B95C8F86F79F3750CFD5434155B538D300838400C40246841633818201808385C100003006BFFFA048B056E001D0035005800000116151117331615062B0107222734333527352306232635343734373536051615140706070607060706232635363F023637363736131615113215062B0127161D010623263D0134272322352227353633161D0117331136014F40082440083854742D0B5C0804181C4034440802B840B88331296F8F7D193B40046C84B43A5EB44815274068083804140C0838400C68B80701083840287008056E0838FE6C280838401040440424B41808382B190A4E284018083828F8B0504D8FCBC57008384B95C8F86F79F3750CFDE40838FEDC44400443895040083850834D301C8040083848040120400003007FFFD105030565002D004B006B000001321F01150623151615171407140706072635343736353237352723072235343F01353423220F0123263534373405161514071407140103061506070623263534373637360134373637363303161507113217140F01150623263D0137232635373536331615071507331136021F3B351413255C04908C42824060845567106C3C649064103C484408409803284060B0FE64E8442711181C40587C28CC0138AC024A1F296840082D0B3C0808384008E45C20093F40080CB00905654840205C0836420C6D57112B1A1208383F091113700C1010443E2A4C0418201C083841270E020838267220A818FE68FEF4341C3F391808382C947642DC01380EB21A5244FDB408382CFEDC4030146C804008388064153B70706008382C7430013C600000020079014D038D043D0039004B00000132173736331615140F01161D0106071617161506232227222735230623222706230607263534373635263527363F012635273633321736333603151633363F013527262F010727230607060215336D701513406034380B293C20240838271D14440447414B611C2C313340443840041C14046C0408382759505811BD6F7D73110C2C172D10242C20481C12043D70500C083830302C742C2445333C102E1A403054083C34182507083832161709372D38781C0C640C1440604C1CFE88149449172C1074174D0C08082D371C0001004A04BD044A0565001000001333051733321714072327252326353437D6E40190A02038084020A0FE70F0804005550C0C4038080C0C0D4338080000002801E60001000000000000005000000001000000000001000800570001000000000002000700500001000000000003001500570001000000000004000800570001000000000005002E006C000100000000000600080057000100000000000A0040009A0003000104030002000C02CA0003000104050002001000DA0003000104060002000C00EA0003000104070002001000F60003000104080002001001060003000104090000007001160003000104090001001001940003000104090002000E01860003000104090003002A01940003000104090004001001940003000104090005005C01BE000300010409000600100194000300010409000A0080021A00030001040A0002000C02CA00030001040B00020010029A00030001040C0002000C02CA00030001040E0002000C02E80003000104100002000E02AA0003000104130002001202B80003000104140002000C02CA0003000104150002001002CA0003000104160002000C02CA0003000104190002000E02DA00030001041B0002001002E800030001041D0002000C02CA00030001041F0002000C02CA0003000104240002000E02F800030001042D0002000E030600030001080A0002000C02CA0003000108160002000C02CA000300010C0A0002000C02CA000300010C0C0002000C02CA4F736D6F7369616E20536C6F70707920A920323030352052656C6174696F6E616C2053797374656D7320436F72706F726174696F6E20323030352E20416C6C205269676874732052657365727665642E526567756C61726F736D6F7369616E3A56657273696F6E20312E303056657273696F6E20312E3030204E6F76656D62657220362C20323030352C20696E697469616C2072656C656173655468697320666F6E74207761732063726561746564207573696E6720466F6E742043726561746F7220352E302066726F6D20486967682D4C6F6769632E636F6D006F00620079010D0065006A006E00E9006E006F0072006D0061006C005300740061006E0064006100720064039A03B103BD03BF03BD03B903BA03AC004F0073006D006F007300690061006E002000A90020003200300030003600200054006800650020004F0073006D006F007300690061006E0020004F0072006400650072002E00200041006C006C0020005200690067006800740073002000520065007300650072007600650064002E0052006500670075006C00610072006F0073006D006F007300690061006E003A00560065007200730069006F006E00200033002E0030003000560065007200730069006F006E00200033002E003000300020004E006F00760065006D00620065007200200036002C00200032003000300035002C00200069006E0069007400690061006C002000720065006C0065006100730065005400680069007300200066006F006E00740020007700610073002000630072006500610074006500640020007500730069006E006700200046006F006E0074002000430072006500610074006F007200200035002E0030002000660072006F006D00200048006900670068002D004C006F006700690063002E0063006F006D004E006F0072006D00610061006C0069004E006F0072006D0061006C0065005300740061006E00640061006100720064004E006F0072006D0061006C006E0079041E0431044B0447043D044B0439004E006F0072006D00E1006C006E0065004E0061007600610064006E006F0041007200720075006E0074006100000002000000000000FF270096000000000000000000000000000000000000000000ED0000010201030003000400050006000700080009000A000B000C000D000E000F0010001100120013001400150016001700180019001A001B001C001D001E001F0020002100220023002400250026002700280029002A002B002C002D002E002F0030003100320033003400350036003700380039003A003B003C003D003E003F0040004100420043004400450046004700480049004A004B004C004D004E004F0050005100520053005400550056005700580059005A005B005C005D005E005F0060006100620063006400650066006700680069006A006B006C006D006E006F0070007100720073007400750076007700780079007A007B007C007D007E007F0080008100820083008400850086008700880089008A008B008C008D008E008F0090009100920093009400950096009700980099009A009C009D009E009F00A000A100A200A300A400A500A600A700A800A900AA00AB00AD00AE00AF00B000B100B200B300B400B500B600B700B800B900BA00BB00BC010400BE00BF00C200C300C400C500C600C700C800C900CA00CB00CC00CD00CE00CF00D000D100D300D400D500D600D700D800D900DD00DE00E100E400E500E600E700E800E900EA00EB00EC00ED00EE00EF00F001050106010700F400F500F600BD00DA052E6E756C6C106E6F6E6D61726B696E6772657475726E044575726F07756E693030423907756E693030423207756E693030423300000001FFFF0002.

to outdent any selected rows in a text:
  if the text is nil, exit.
  loop.
  get a row from the text's rows.
  if the row is nil, exit.
  if the row of the text is not selected, repeat.
  if the row's string's first's target is the space byte, remove the first byte from the row's string.
  if the row's string's first's target is the space byte, remove the first byte from the row's string.
  repeat.

to outdent a box given a number:
  subtract the number from the box's left.
  subtract the number from the box's top.
  add the number to the box's right.
  add the number to the box's bottom.

an outdent is a number.

a outlinetextmetric is a record with
  a number called otmsize,
  a textmetric called otmtextmetrics,
  3 bytes, \ needed to align structure
  a byte called otmfiller,
  a panose called otmpanosenumber,
  1 bytes, \ needed to align structure
  a number called otmfsselection,
  a number called otmfstype,
  a number called otmscharsloperise,
  a number called otmscharsloperun,
  a number called otmitalicangle,
  a number called otmemsquare,
  a number called otmascent,
  a number called otmdescent,
  a number called otmlinegap,
  a number called otmscapemheight,
  a number called otmsxheight,
  a box called otmrcfontbox,
  a number called otmmacascent,
  a number called otmmacdescent,
  a number called otmmaclinegap,
  a number called otmusminiumppem,
  a spot called otmptsubscriptsize,
  a spot called otmptsubscriptoffset,
  a spot called otmptsuperscriptsize,
  a spot called otmptsuperscriptoffset,
  a number called otmsstrikeoutsize,
  a number called otmsstrikeoutposition,
  a number called otmsunderscoresize,
  a number called otmsunderscoreposition,
  a pointer called otmpfamilyname,
  a pointer called otmpfacename,
  a pointer called otmpstylename,
  a pointer called otmpfullname.

to output the arc of an ellipse given a string:
  put 2761/10000 into a ratio. \ 2/3*(sqrt(2)-1)
  put the ellipse's center into a center spot.
  put the ellipse's x-extent divided by 2 into a half width.
  put the ellipse's y-extent divided by 2 into a half height.
  put the ellipse's x-extent times the ratio into an x offset.
  put the ellipse's y-extent times the ratio into a y offset.
  \ control point 1
  if the string is "left-top", put the ellipse's left and the center's y minus the y offset into a first control spot. 
  if the string is "right-top", put the center's x plus the x offset and the ellipse's top into the first control spot.
  if the string is "right-bottom", put the ellipse's right and the center's y plus the y offset into the first control spot.
  if the string is "left-bottom", put the center's x minus the x offset and the ellipse's bottom into the first control spot.
  \ control point 2
  if the string is "left-top", put the center's x minus the x offset and the ellipse's top into a second control spot.
  if the string is "right-top", put the ellipse's right and the center's y minus the y offset into the second control spot.
  if the string is "right-bottom", put the center's x plus the x offset and the ellipse's bottom into the second control spot.
  if the string is "left-bottom", put the ellipse's left and the center's y plus the y offset into the second control spot.
  \ ending point
  if the string is "left-top", put the ellipse's left plus the half width and the ellipse's top into an ending spot.
  if the string is "right-top", put the ellipse's right and the ellipse's top plus the half height into the ending spot.
  if the string is "right-bottom", put the ellipse's right minus the half width and the ellipse's bottom into the ending spot.
  if the string is "left-bottom", put the ellipse's left and the ellipse's bottom minus the half height into the ending spot.
  \ spit it out
  output the first control spot without advancing.
  output the second control spot without advancing.
  output the ending spot without advancing.
  output "c".

to output a color without advancing:
  convert the color to a rgb.
  put the rgb's red byte / 255 into a ratio.
  convert the ratio to a red string given 4.
  put the rgb's green byte / 255 into the ratio.
  convert the ratio to a green string given 4.
  put the rgb's blue byte / 255 into the ratio.
  convert the ratio to a blue string given 4.
  output the red string then " " then the green string then " " then the blue string without advancing.

to output lineto given a spot:
  output the spot without advancing.
  output "l".

to output lineto given an x number and a y number:
  put the x and the y into a spot.
  output lineto given the spot.

to output moveto given a spot:
  output the spot without advancing.
  output "m".

to output moveto given an x number and a y number:
  put the x and the y into a spot.
  output moveto given the spot.

to output a number without advancing:
  convert the number to a string.
  output the string without advancing.
  output " " without advancing.

to output the pdf border given a color:
  if the color is the pdf state's current border, exit.
  output the color without advancing.
  output " RG".
  put the color into the pdf state's current border.

to output the pdf fill given a color:
  if the color is the pdf state's current fill, exit.
  output the color without advancing.
  output " rg".
  put the color into the pdf state's current fill.

to output setcolor given a border color and a fill color:
  if the fill is not clear, output the pdf fill given the fill.
  if the border is not clear, output the pdf border given the border.

to output a spot without advancing:
  output the spot's x without advancing.
  output the pdf state's current height minus the spot's y without advancing.

to output a string:
  append the string to the pdf state's current contents.

to output a string without advancing:
  append the string to the pdf state's current contents without advancing.

to output stroke and fill given a border color and a fill color:
  put "B" into a string. \ stroke and fill
  if the fill is clear, put "S" into the string. \ stroke
  if the border is clear, put "f" into the string. \ fill
  output the string.

the p-key is a key equal to 80.

a pabc is a pointer to an abc.

the page-down key is a key equal to 34.

the page-up key is a key equal to 33.

a paintstruct is a record with
  an hdc called hdc,
  a number called ferase,
  a box called rcpaint,
  a number called frestore,
  a number called fincupdate,
  32 bytes.

a pair has an x number and a y number.

a panose is a record with
  a byte called bfamilytype,
  a byte called bserifstyle,
  a byte called bweight,
  a byte called bproportion,
  a byte called bcontrast,
  a byte called bstrokevariation,
  a byte called barmstyle,
  a byte called bletterform,
  a byte called bmidline,
  a byte called bxheight.

the paragraph byte is a byte equal to 182.

a path is a string. \ complete name = c:\folder1\folder2\file.ext

the pause key is a key equal to 19.

a pchar is a byte pointer.

a pdevmode is a pointer to a devmode.

a pdf is a buffer.

a pdf object is a thing with
  a kind [contents, font definition, font descriptor, font streamoutline, image object, outline entry, page, parent, root],
  a number,
  an offset,
  a data buffer,
  a font name [font definition],
  a font info [font definition],
  some string things called font strings [page],
  some string things called image strings [page].

a pdf outline entry is a thing with
  a pdf object (reference),
  a title string,
  a page height,
  a destination number.

a pdf pointer is a pointer to a pdf.

a pdf state has
  a pdf pointer,
  a document flag,
  a page flag,
  an object number,
  some pdf objects called objects,
  an xref offset,
  an outline pdf object (reference),
  some pdf outline entries called outline entries,
  a root pdf object (reference),
  a parent pdf object (reference),
  a current contents pdf object (reference),
  a current page pdf object (reference),
  a current height,
  a current border color,
  a current fill color,
  a font index.

the pdf state is a pdf state.

a pdf string is a string. \ string surrounded by ( ) and has \( for left paren, \) for right paren, \\ for backslash

the per-mille-sign byte is a byte equal to 137.

a percent is a number. \ a scale with 100 in the denominator

the percent-sign byte is a byte equal to 37.

the period byte is a byte equal to 46.

to pick a color between another color and a third color:
  pick the color's hue between the other color's hue and the third color's hue.
  pick the color's saturation between the other color's saturation and the third color's saturation.
  pick the color's lightness between the other color's lightness and the third color's lightness.

to pick a number:
  pick the number between 0 and the largest number. 

to pick a number within an amount of another number:
  pick the number between the other number minus the amount and the other number plus the amount.

to pick a random number between a min number and a max number:
  put the seed's whereabouts into eax.
  \ put address of randseed into ecx
  intel $8BC8. \ mov ecx,eax
  \ calculate zero based max
  intel $8B8510000000. \ mov eax,[ebp+16] \ the max
  intel $8B00. \ mov eax,[eax]
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the min
  intel $2B03. \ sub eax,[ebx]
  intel $40. \ inc eax
  \ adjust randseed
  intel $691105840808. \ imul edx,[ecx],134775813
  intel $42. \ inc edx
  intel $8911. \ mov [ecx],edx
  \ mul adjusted randseed by the zero based max
  intel $F7E2. \ mul edx
  \ add the min to un-zero base the number
  intel $0313. \ add edx,[ebx] the min
  \ store the result
  intel $8B9D08000000. \ mov ebx,[ebp+08] \ the random number
  intel $8913. \ mov [ebx],edx

to pick a spot anywhere in a box:
  pick the spot's x between the box's left and the box's right.
  pick the spot's y between the box's top and the box's bottom.

to pick a spot within a distance of another spot:
  pick the spot's x within the distance of the other spot's x.
  pick the spot's y within the distance of the other spot's y.

a picture is a thing with
 \ all boxes are in twits
  a box [location of cropped picture on the page],
  a uncropped box [location of entire picture on the page],
  a grayscale flag,
  a mirror flag,
  a rotate angle, \ rotation is clockwise
  a hex string called data [original bytes in original format],
  a gpbitmap.

to play a wave:
  call "winmm.dll" "PlaySound" with the wave's first and 0 and 5 [snd_memory+snd_async].

to play a wave and wait:
  call "winmm.dll" "PlaySound" with the wave's first and 0 and 4 [snd_memory+snd_sync].

to play a wave file:
  privatize the wave file.
  null terminate the wave file.
  call "winmm.dll" "PlaySound" with the wave file's first and 0 and 131073 [snd_filename+snd_async].

to play a wave file and wait:
  privatize the wave file.
  null terminate the wave file.
  call "winmm.dll" "PlaySound" with the wave file's first and 0 and 131072 [snd_filename+snd_sync].

the plus-or-minus byte is a byte equal to 177.

a pointer has 4 bytes.

a polygon is a thing with some vertices.

a portrait sheet is a sheet.

a position is a pair with a column# and a row#.

to position a substring on a string:
  intel $8B8508000000. \ mov eax,[ebp+8] \ the substring
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the string
  \ put the string's first into the substring's first
  intel $8B8B00000000. \ mov ecx,[ebx+0] \ the string's first
  intel $898800000000. \ mov [eax+0],ecx \ the substring's first
  \ put the string's first minus 1 into the substring's last
  intel $49. \ dec ecx
  intel $898804000000. \ mov [eax+4],ecx \ the substring's last

to post a data string to a url and receive a response string: \ only works with http and https
  clear the response.
  clear the i/o error.
  create a winhttp request for posting to the url.
  if the i/o error is not blank, exit.
  send the data to the winhttp request.
  if the i/o error is not blank, destroy the winhttp request; exit.
  receive the response from the winhttp request.
  if the i/o error is not blank, destroy the winhttp request; exit.
  read the response from the winhttp request.
  if the i/o error is not blank, destroy the winhttp request; exit.
  destroy the winhttp request.

the pound-sign byte is a byte equal to 163.

a poutlinetextmetric is a pointer to an outlinetextmetric.

the ppi is some twips.

to prepend a byte to a string:
  put the string's length into a saved length.
  reassign the string's first given the string's length plus 1.
  copy bytes from the string's first to the string's first plus 1 for the saved length.
  put the string's first plus the saved length into the string's last.
  put the byte into the string's first's target.

to prepend a string to another string:
  put the other string's length plus the string's length into a combined length.
  reassign a pointer given the combined length.
  put the pointer into a substring's first.
  copy bytes from the string's first to the substring's first for the string's length.
  add the string's length to the substring's first.
  copy bytes from the other string's first to the substring's first for the other string's length.
  unassign the other string's first. \ to avoid extra allocates and copies
  put the pointer into the other string's first.
  put the other string's first plus the combined length minus 1 into the other string's last.

to prepend a thing to some things:
  if the thing is nil, exit.
  put the things' first into the thing's next.
  if the things is not empty, put the thing into the things' first's previous.
  if the things are empty, put the thing into the things' last.
  put the thing into the things' first.

to prepend some things to some other things:
  get a thing from the things (backwards).
  if the thing is nil, exit.
  remove the thing from the things.
  prepend the thing to the other things.
  repeat.

the print-screen key is a key equal to 44.

a printdlgex is a record with
  a number called lstructsize,
  a window called hwndowner,
  a handle called hdevmode,
  a handle called hdevnames,
  a canvas called hdc,
  a number called flags,
  a number called flags2,
  a number called exclusionflags,
  a number called npageranges,
  a number called nmaxpageranges,
  a pointer called lppageranges,
  a number called nminpage,
  a number called nmaxpage,
  a number called ncopies,
  a handle called hinstance,
  a pointer called lpprinttemplatename,
  a pointer called lpcallback,
  a number called npropertypages,
  a pointer called lphpropertypages,
  a number called nstartpage,
  a number called dwresultaction.

the printer canvas is a canvas.

the printer device mode handle is a handle.

a process is a handle.

a process pointer is a pointer to a process.

a processinfo is a record with
  a handle called hprocess,
  a handle called hthread,
  a number called dwprocessid,
  a number called dwthreadid.

the purple color is a color.

to put the actual data of a font into a buffer: \ only works with true/open type fonts
  create the hfont of the memory canvas given the font.
  call "gdi32.dll" "GetFontData" with the memory canvas and 0 and 0 and nil and 0 returning a count.
  reassign the buffer's first given the count.
  call "gdi32.dll" "GetFontData" with the memory canvas and 0 and 0 and the buffer's first and the count.
  put the buffer's first plus the count minus 1 into the buffer's last.
  destroy the hfont of the memory canvas.

to put a box and a radius into a roundy box:
  put the box's left into the roundy box's left.
  put the box's top into the roundy box's top.
  put the box's right into the roundy box's right.
  put the box's bottom into the roundy box's bottom.
  put the radius into the roundy box's radius.

to put a box into another box:
  put the box's left into the other box's left.
  put the box's top into the other box's top.
  put the box's right into the other box's right.
  put the box's bottom into the other box's bottom.

to put a box's bottom line into a line:
  put the box's left and the box's bottom into the line's start.
  put the box's right and the box's bottom into the line's end.

to put a box's center into a spot:
  put the box's left plus the box's right into the spot's x.
  put the box's top plus the box's bottom into the spot's y.
  divide the spot by 2.

to put a box's center-bottom into a spot:
  put the box's center's x into the spot's x.
  put the box's bottom into the spot's y.

to put a box's center-top into a spot:
  put the box's center's x into the spot's x.
  put the box's top into the spot's y.

to put a box's height into a height:
  put the box's bottom into the height.
  subtract the box's top from the height.
  add the tpp to the height.

to put a box's left line into a line:
  put the box's left and the box's top into the line's start.
  put the box's left and the box's bottom into the line's end.

to put a box's left-bottom into a spot:
  put the box's left into the spot's x.
  put the box's bottom into the spot's y.

to put a box's left-center into a spot:
  put the box's left into the spot's x.
  put the box's center's y into the spot's y.

to put a box's right line into a line:
  put the box's right and the box's top into the line's start.
  put the box's right and the box's bottom into the line's end.

to put a box's right-center into a spot:
  put the box's right into the spot's x.
  put the box's center's y into the spot's y.

to put a box's right-top into a spot:
  put the box's right into the spot's x.
  put the box's top into the spot's y.

to put a box's top line into a line:
  put the box's left and the box's top into the line's start.
  put the box's right and the box's top into the line's end.

to put a box's width into a width:
  put the box's right into the width.
  subtract the box's left from the width.
  add the tpp to the width.

to put a box's x-extent into a width:
  put the box's right into the width.
  subtract the box's left from the width.

to put a box's y-extent into a height:
  put the box's bottom into the height.
  subtract the box's top from the height.

to put a byte and a number into a ratio:
  put the byte into the ratio's numerator.
  put the number into the ratio's denominator.

to put a byte into another byte:
  intel $8B8508000000. \ mov eax,[ebp+8] \ the byte
  intel $8A00. \ mov al,[eax]
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the other byte
  intel $8803. \ mov [ebx],al

to put a byte into eax:
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the byte
  intel $0FB603. \ movzx eax,byte ptr [ebx]

to put a byte into a number:
  intel $8B8508000000. \ mov eax,[ebp+8] \ the byte
  intel $0FB600. \ movzx eax,byte ptr [eax]
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the number
  intel $8903. \ mov [ebx],eax

to put a byte into a string:
  put 1 into a length.
  reassign the string's first given the length.
  put the byte into the string's first's target.
  put the string's first into the string's last.

to put a byte into a wyrd:
  intel $8B8508000000. \ mov eax,[ebp+8] \ the byte
  intel $660FB600. \ movzx eax,byte ptr [eax]
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the wyrd
  intel $668903. \ mov [ebx],ah

to put the character under a finger into a character:
  if the finger is nil, clear the character; exit.
  put the finger's target into the character.

to put a color into another color:
  put the color's hue into the other color's hue.
  put the color's saturation into the other color's saturation.
  put the color's lightness into the other color's lightness.

to put a date/time into another date/time:
  put the date/time's year into the other date/time's year.
  put the date/time's month into the other date/time's month.
  put the date/time's week day into the other date/time's week day.
  put the date/time's day into the other date/time's day.
  put the date/time's hour into the other date/time's hour.
  put the date/time's minute into the other date/time's minute.
  put the date/time's second into the other date/time's second.
  put the date/time's millisecond into the other date/time's millisecond.

to put a date/time's string into a string:
  clear the string.
  append the date/time's year to the string.
  append "/" to the string.
  zero fill the date/time's month given 2 and append it to the string.
  append "/" to the string.
  zero fill the date/time's day given 2 and append it to the string.
  append " " to the string.
  zero fill the date/time's hour given 2 and append it to the string.
  append ":" to the string.
  zero fill the date/time's minute given 2 and append it to the string.
  append ":" to the string.
  zero fill the date/time's second given 2 and append it to the string.
  append ":" to the string.
  zero fill the date/time's millisecond given 3 and append it to the string.

to put eax into a byte:
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the number
  intel $8803. \ mov [ebx],al

to put eax into a flag: employ put eax into a number.

to put eax into a number:
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the number
  intel $8903. \ mov [ebx],eax

to put eax into a pointer: employ put eax into a number.

to put eax into a wyrd:
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the wyrd
  intel $668903. \ mov [ebx],ax

to put an ellipse into another ellipse:
  put the ellipse's box into the other ellipse's box.

to put a finger on the first character of a string:
  put the string's first into the finger.

to put a flag into another flag: employ put a number into another number.

to put a flag into eax: employ put a number into eax.

to put a flag into a number: employ put a number into another number.

to put a flag into a string: employ convert a flag to a string.

to put a font into another font:
  put the font's name into the other font's name.
  put the font's height into the other font's height.

to put some font widths into a buffer: \ used for pdf conversion
  clear the buffer.
  if the font widths are nil, exit.
  put the font widths' data into a number pointer.
  loop.
  if a counter is past the font widths' count, break.
  append the number pointer's target then " " to the buffer.
  add 1 to a count.
  if the count is evenly divisible by 16, append the crlf string to the buffer.
  add a number's magnitude to the number pointer.
  repeat.

to put a font's adjusted height into a height:
  put the font's height times 3/4 into the height.

to put a gpimage's gprect into a gprect:
  put 0 into the gprect's x.
  put 0 into the gprect's y.
  put the gpimage's width into the gprect's width.
  put the gpimage's height into the gprect's height.

to put a gpimage's height into a height:
  if the gpimage is nil, put 0 into the height; exit.
  call "gdiplus.dll" "GdipGetImageHeight" with the gpimage and the height's whereabouts.

to put a gpimage's width into a width:
  if the gpimage is nil, put 0 into the width; exit.
  call "gdiplus.dll" "GdipGetImageWidth" with the gpimage and the width's whereabouts.

to put a gprect into another gprect:
  put the gprect's x into the other gprect's x.
  put the gprect's y into the other gprect's y.
  put the gprect's width into the other gprect's width.
  put the gprect's height into the other gprect's height.

to put a hue and a saturation and a lightness into a color:
  put the hue into the color's hue.
  if the color's hue is not -1, limit the color's hue to 0 and 3600. \ -1 is clear
  put the saturation into the color's saturation.
  limit the color's saturation to 0 and 1000.
  put the lightness into the color's lightness.
  limit the color's lightness to 0 and 1000.

to put an index's count into a count:
  put 0 into the count.
  if the index is nil, exit.
  loop.
  get a bucket given the index.
  if the bucket is nil, exit.
  add the bucket's refers' count to the count.
  repeat.

to put an index's used bucket count into a count:
  put 0 into the count.
  if the index is nil, exit.
  loop.
  get a bucket given the index.
  if the bucket is nil, exit.
  if the bucket's refers are empty, repeat.
  add 1 to the count.
  repeat.

to put a left coord and a top coord and a right coord and a bottom coord and a radius into a roundy box:
  put the left into the roundy box's left.
  put the top into the roundy box's top.
  put the right into the roundy box's right.
  put the bottom into the roundy box's bottom.
  put the radius into the roundy box's radius.

to put a left coord and a top coord and a right coord and a bottom coord into a box:
  put the left into the box's left.
  put the top into the box's top.
  put the right into the box's right.
  put the bottom into the box's bottom.

to put a left coord and a top coord and a right coord and a bottom coord into an ellipse:
  put the left into the ellipse's left.
  put the top into the ellipse's top.
  put the right into the ellipse's right.
  put the bottom into the ellipse's bottom.

to put a line into another line:
  put the line's start into the other line's start.
  put the line's end into the other line's end.

to put a line's box into a box:
  put the line's start into the box's left-top.
  put the line's end into the box's right-bottom.
  normalize the box.

to put a line's center into a spot:
  put the line's start's x plus the line's end's x into the spot's x.
  put the line's start's y plus the line's end's y into the spot's y.
  divide the spot by 2.

to put the mouse's spot into a spot:
  call "user32.dll" "GetCursorPos" with the spot's whereabouts.
  call "user32.dll" "ScreenToClient" with the main window and the spot's whereabouts. \ in case window is on another monitor.
  call "gdi32.dll" "DPtoLP" with the screen canvas and the spot's whereabouts and 1.

to put a name and a height into a font:
  put the name into the font's name.
  put the height into the font's height.

to put a number and another number into a pair:
  put the number into the pair's x.
  put the other number into the pair's y.

to put a number and another number into a ratio:
  put the number into the ratio's numerator.
  put the other number into the ratio's denominator.

to put a number into another number:
  intel $8B8508000000. \ mov eax,[ebp+8] \ the number
  intel $8B00. \ mov eax,[eax]
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the other number
  intel $8903. \ mov [ebx],eax

to put a number into a big-endian unsigned wyrd:
  put the number into a wyrd.
  put the wyrd into the big-endian unsigned wyrd.

to put a number into a byte:
  intel $8B8508000000. \ mov eax,[ebp+8] \ the number
  intel $8B00. \ mov eax,[eax]
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the byte
  intel $8803. \ mov [ebx],al

to put a number into eax:
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the number
  intel $8B03. \ mov eax,[ebx]

to put a number into a flag: employ put a number into another number.

to put a number into a pair:
  put the number into the pair's x.
  put the number into the pair's y.

to put a number into a pointer: employ put a number into another number.

to put a number into a ratio:
  put the number into the ratio's numerator.
  put 1 into the ratio's denominator.

to put a number into a string: employ convert a number to a string.

to put a number into a wyrd:
  intel $8B8508000000. \ mov eax,[ebp+8] \ the number
  intel $8B00. \ mov eax,[eax]
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the wyrd
  intel $668903. \ mov [ebx],ax

to put a number's absolute value into another number:
  put the number into the other number.
  de-sign the other number.

to put an outlinetextmetric into another outlinetextmetric:
  copy bytes from the outlinetextmetric's whereabouts to the other outlinetextmetric's whereabouts for the outlinetextmetric's magnitude.

to put a pair into another pair:
  put the pair's x into the other pair's x.
  put the pair's y into the other pair's y.

to put a pair's absolute value into another pair:
  put the pair into the other pair.
  de-sign the other pair.

to put a pointer into another pointer: employ put a number into another number.

to put a pointer into eax: employ put a number into eax.

to put a pointer into a number: employ put a number into another number.

to put a polygon's box into a box:
  if the polygon is nil, clear the box; exit.
  if the polygon's vertices are empty, clear the box; exit.
  put the largest number and the largest number and the smallest number and the smallest number into the box.
  loop.
  get a vertex from the polygon's vertices.
  if the vertex is nil, break.
  if the vertex's x is less than the box's left, put the vertex's x into the box's left.
  if the vertex's y is less than the box's top, put the vertex's y into the box's top.
  if the vertex's x is greater than the box's right, put the vertex's x into the box's right.
  if the vertex's y is greater than the box's bottom, put the vertex's y into the box's bottom.
  repeat.

to put a polygon's center into a spot:
  if the polygon is nil, clear the spot; exit.
  put the polygon's box's center into the spot.

to put a polygon's center-bottom into a spot:
  if the polygon is nil, clear the spot; exit.
  put the polygon's box's center-bottom into the spot.

to put a polygon's center-top into a spot:
  if the polygon is nil, clear the spot; exit.
  put the polygon's box's center-top into the spot.

to put a polygon's height into a height:
  if the polygon is nil, clear the height; exit.
  put the polygon's box's height into the height.

to put a polygon's left-bottom into a spot:
  if the polygon is nil, clear the spot; exit.
  put the polygon's box's left-bottom into the spot.

to put a polygon's left-center into a spot:
  if the polygon is nil, clear the spot; exit.
  put the polygon's box's left-center into the spot.

to put a polygon's left-top into a spot:
  if the polygon is nil, clear the spot; exit.
  put the polygon's box's left-top into the spot.

to put a polygon's right-bottom into a spot:
  if the polygon is nil, clear the spot; exit.
  put the polygon's box's right-bottom into the spot.

to put a polygon's right-center into a spot:
  if the polygon is nil, clear the spot; exit.
  put the polygon's box's right-center into the spot.

to put a polygon's right-top into a spot:
  if the polygon is nil, clear the spot; exit.
  put the polygon's box's right-top into the spot.

to put a polygon's width into a width:
  if the polygon is nil, clear the width; exit.
  put the polygon's box's width into the width.

to put a polygon's x-extent into a width:
  if the polygon is nil, clear the width; exit.
  put the polygon's box's x-extent into the width.

to put a polygon's y-extent into a height:
  if the polygon is nil, clear the height; exit.
  put the polygon's box's y-extent into the height.

to put a ratio into another ratio:
  put the ratio's numerator into the other ratio's numerator.
  put the ratio's denominator into the other ratio's denominator.

to put a ratio into a string: employ convert a ratio to a string.

to put a ratio pair into another ratio pair:
  put the ratio pair's ratio into the other ratio pair's ratio.
  put the ratio pair's other ratio into the other ratio pair's other ratio.

to put a ratio's absolute value into another ratio:
  put the ratio into the other ratio.
  de-sign the other ratio.

to put a rider into another rider:
  copy bytes from the rider's whereabouts to the other rider's whereabouts for the rider's magnitude.

to put a roundy box into another roundy box:
  put the roundy box's left into the other roundy box's left.
  put the roundy box's top into the other roundy box's top.
  put the roundy box's right into the other roundy box's right.
  put the roundy box's bottom into the other roundy box's bottom.
  put the roundy box's radius into the other roundy box's radius.

to put a row's working string into a substring:
  if the row is nil, clear the substring; exit.
  slap the substring on the row's string.
  subtract 1 from the substring's last.

to put a selection into another selection:
  put the selection's anchor into the other selection's anchor.
  put the selection's caret into the other selection's caret.

to put a sockaddr into another sockaddr:
  copy bytes from the sockaddr's whereabouts to the other sockaddr's whereabouts for the sockaddr's magnitude.

to put a spot and another spot and a radius into a roundy box:
  put the spot into the roundy box's left-top.
  put the other spot into the roundy box's right-bottom.
  put the radius into the roundy box's radius.

to put a spot and another spot into a box:
  put the spot into the box's left-top.
  put the other spot into the box's right-bottom.

to put a spot and another spot into an ellipse:
  put the spot into the ellipse's left-top.
  put the other spot into the ellipse's right-bottom.

to put a spot and another spot into a line:
  put the spot into the line's start.
  put the other spot into the line's end.

to put a string into another string:
  put the string's length into a saved length.
  assign a pointer given the saved length.
  copy bytes from the string's first to the pointer for the saved length.
  unassign the other string's first.
  put the pointer into the other string's first.
  put the other string's first plus the saved length minus 1 into the other string's last.

to put a string into a text:
  if the text is nil, exit.
  destroy the text's rows.
  reset the origin of the text.
  reset the caret of the text.
  deselect the text.
  privatize the string.
  append the return byte to the string.
  convert the string to the text's rows.
  wrap the text.

to put a string on the windows clipboard:
  call "user32.dll" "OpenClipboard" with the main window.
  call "user32.dll" "EmptyClipboard".
  put the string's length plus 1 into a number.
  call "kernel32.dll" "GlobalAlloc" with 66 [ghnd] and the number returning a handle.
  call "kernel32.dll" "GlobalLock" with the handle returning a pointer.
  copy bytes from the string's first to the pointer for the string's length.
  call "kernel32.dll" "GlobalUnlock" with the handle.
  call "user32.dll" "SetClipboardData" with 1 [cf_text] and the handle.
  call "user32.dll" "CloseClipboard".

to put a string's length into a length:
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the string
  \ load default result
  intel $B900000000. \ mov ecx,0
  \ if first is 0, store 0
  intel $833B00. \ cmp [ebx],0
  intel $0F8414000000. \ je store it
  \ if last is less than first, store 0
  intel $8B5304. \ mov edx,[ebx+4] \ last pointer
  intel $3B13. \ cmp edx,[ebx]
  intel $0F8C09000000. \ jl store it
  \ calc length
  intel $8B8B04000000. \ mov ecx,[ebx+4] \ last pointer
  intel $2B0B. \ sub ecx,[ebx] \ subtract first
  intel $41. \ inc ecx \ add 1
  \ STORE IT:
  intel $8B950C000000. \ mov edx,[ebp+12] \ the number
  intel $890A. \ mov [edx],ecx

to put a string's width into a width:
  get the width given the string and the memory canvas and the default font.

to put a substring into another substring:
  copy bytes from the substring's whereabouts to the other substring's whereabouts for the substring's magnitude.

to put the system's date/time into a date/time:
  call "kernel32.dll" "GetLocalTime" with a systemtime's whereabouts.
  put the systemtime's wyear into the date/time's year.
  put the systemtime's wmonth into the date/time's month.
  put the systemtime's wdayofweek into the date/time's week day.
  put the systemtime's wday into the date/time's day.
  put the systemtime's whour into the date/time's hour.
  put the systemtime's wminute into the date/time's minute.
  put the systemtime's wsecond into the date/time's second.
  put the systemtime's wmilliseconds into the date/time's millisecond.

to put the system's last error into a number:
  call "kernel32.dll" "GetLastError" returning the number.

to put the system's last winsock error into a number:
  call "ws2_32.dll" "WSAGetLastError" returning the number.

to put the system's tick count into some ticks: \ wraps every 24.8 days or so
  call "kernel32.dll" "GetTickCount" returning the ticks.
  bitwise and the ticks with the largest number.

to put a text's first line into a string:
  if the text is nil, clear the string; exit.
  put the text's first row's string into the string.
  remove the last byte from the string.

to put a text's globalized origin into a spot:
  if the text is nil, clear the spot; exit.
  put the text's origin into the spot.
  globalize the spot given the text's left-top.

to put a text's grid into a grid:
  if the text is nil, clear the grid; exit.
  put the text's font's height times 4 into the grid's x.
  put the text's font's height into the grid's y.

to put a text's normalized selection into a selection:
  if the text is nil, exit.
  put the text's selection into the selection.
  normalize the selection.

to put a text's row count into a count:
  if the text is nil, put 0 into the count; exit.
  if the text's rows are empty, put 0 into the count; exit.
  put the text's rows' last's row# into the count.

to put a text's row height into a height:
  if the text is nil, put 0 into the height; exit.
  put the text's font's height into the height.

to put a text's rows/box into a count:
  if the text is nil, put 0 into the count; exit.
  put the text's box's height divided by the text's row height into the count.

to put a text's selected byte count into a count:
  put 0 into the count.
  if the text is nil, exit.
  if nothing is selected in the text, exit.
  loop.
  get a row from the text's rows.
  if the row is nil, exit.
  slap a substring on any selected bytes in the row of the text.
  add the substring's length to the count.
  repeat.

to put a text's selected row count into a count:
  put 0 into the count.
  if the text is nil, exit.
  put the text's normalized selection into a selection.
  if the selection's anchor row# is the selection's caret row#, exit.
  put the selection's caret row# into the count.
  subtract the selection's anchor row# from the count.
  if the selection's caret column# is not 1, add 1 to the count.

to put a text's status string into a string:
  if the text is nil, clear the string; exit.
  put the text's selected row count into a count.
  if the count is not 0, format the count and "line" or "lines" into the string; exit.
  put the text's selected byte count into another count.
  if the other count is not 0, format the other count and "byte" or "bytes" into the string; exit.
  convert the text's caret row# to the string.
  append ":" to the string.
  append the text's caret column# to the string.

to put some things into some other things:
  put the things' first into the other things' first.
  put the things' last into the other things' last.

to put some things' count into a count:
  put 0 into the count.
  loop.
  get a thing from the things.
  if the thing is nil, exit.
  add 1 to the count.
  repeat.

to put a timer into a string: employ convert a timer to a string.

to put a timer's string into a string:
  convert the timer's ticks to the string.

to put a timer's ticks into some ticks:
  put the timer's total ticks into the ticks.
  if the timer's count is 0, exit.
  put the system's tick count into some other ticks.
  subtract the timer's start ticks from the other ticks.
  add the other ticks to the ticks.

to put a wyrd into another wyrd:
  intel $8B8508000000. \ mov eax,[ebp+8] \ the wyrd
  intel $668B00. \ mov ax,[eax]
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the other wyrd
  intel $668903. \ mov [ebx],ax

to put a wyrd into a big-endian unsigned wyrd:
  intel $8B8508000000. \ mov eax,[ebp+8] \ the wyrd
  intel $668B00. \ mov ax,word ptr [eax]
  intel $86E0. \ xchg al,ah
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the big-endian unsigned wyrd
  intel $668903. \ mov word ptr [ebx],ax

to put a wyrd into a byte:
  intel $8B8508000000. \ mov eax,[ebp+8] \ the wyrd
  intel $668B00. \ mov ax,[eax]
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the byte
  intel $8803. \ mov [ebx],al

to put a wyrd into eax:
  intel $8B9D08000000. \ mov ebx,[ebp+8] \ the wyrd
  intel $0FBF03. \ movsx eax,word ptr [ebx]

to put a wyrd into a number:
  intel $8B8508000000. \ mov eax,[ebp+8] \ the wyrd
  intel $0FBF00. \ movsx eax,wyrd ptr [eax]
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the number
  intel $8903. \ mov [ebx],eax

to put an x coord and a y coord and another x coord and another y coord into a line:
  put the x into the line's start's x.
  put the y into the line's start's y.
  put the other x into the line's end's x.
  put the other y into the line's end's y.

the q-key is a key equal to 81.

a query byte is a query string.

a query string is a string.

the question-mark byte is a byte equal to 63.

to quote a string: \ inserts leading, trailing and nested double-quotes
  put the double-quote byte into another string.
  slap a substring on the string.
  loop.
  if the substring is blank, break.
  append the substring's first's target to the other string.
  if the substring's first's target is the double-quote byte, append the double-quote byte to the other string.
  add 1 to the substring's first.
  repeat.
  append the double-quote byte to the other string.
  put the other string into the string.

a quotient is a number.

the r-key is a key equal to 82.

a radius is some twips.

to raise a number to another number:
  if the other number is 0, put 1 into the number; exit.
  if the other number is less than 0, put 0 into the number; exit. \ should be 1/the raised result, but always comes out 0 with numbers
  put 1 into a result number.
  loop.
  if a counter is past the other number, break.
  multiply the result by the number.
  repeat.
  put the result into the number.

a random number is a number.

a ratio has a numerator number and a denominator number.

a ratio pair has a ratio and another ratio.

to read a byte:
  read a string.
  if the string is blank, put the null byte into the byte; exit.
  put the string's first's target into the byte.

to read a console into a string:
  if the console is nil, clear the string; exit.
  flush all events.
  clear the console's reply.
  show the console.
  handle events given the console.
  put the console's reply into the string.
  flush all events.
  refresh the cursor.

to read a file into a buffer:
  clear the i/o error.
  call "kernel32.dll" "GetFileSize" with the file and nil returning a size.
  reassign the buffer's first given the size.
  put the buffer's first plus the size minus 1 into the buffer's last.
  call "kernel32.dll" "ReadFile" with the file and the buffer's first and the size and a number's whereabouts and 0 returning a result number.
  if the result number is 0, put "Error reading file." into the i/o error; exit.

to read a flag:
  read a string.
  convert the string to the flag.

to read a number:
  read a string.
  convert the string to the number.

to read a path into a buffer:
  clear the i/o error.
  privatize the path.
  null terminate the path.
  if the path is not in the file system, put "File '" then the path then "' doesn't exist." into the i/o error; exit.
\  set the path to read-write mode.
  call "kernel32.dll" "CreateFileA" with the path's first and -2147483648 [generic_read] and 3 [file_share_read+file_share_write] and 0 
    and 3 [open_existing] and 0 and 0 returning a handle.
  if the handle is -1 [invalid_handle_value], put "Error opening file '" then the path then "'." into the i/o error; exit.
  call "kernel32.dll" "GetFileSize" with the handle and nil returning a size.
  reassign the buffer's first given the size.
  put the buffer's first plus the size minus 1 into the buffer's last.
  call "kernel32.dll" "ReadFile" with the handle and the buffer's first and the size and a number's whereabouts and 0 returning the number.
  call "kernel32.dll" "CloseHandle" with the handle.
  if the number is not 0, exit.
  put "Error reading file '" then the path then "'." into the i/o error.

to read a path into a picture:
  read the path into a buffer.
  if the i/o error is not blank, void the picture; exit.
  create the picture given the buffer.

to read a ratio:
  read a string.
  convert the string to the ratio.

to read a response string from a winhttp request:
  if the winhttp request is nil, exit.
  clear the response.
  put 8 kilobytes into a buffer size.
  loop.
  put 0 into a size.  
  call "winhttp.dll" "WinHttpQueryDataAvailable"
    with the winhttp request's request and the size's whereabouts returning a result number.
  if the result is 0, put "Unable to query data available." into the i/o error; clear the response; break.
  put the response's length into a saved length.
  reassign the response's first given the saved length plus the buffer size.
  put the response's first plus the saved length into a pointer.
  call "winhttp.dll" "WinHttpReadData" with the winhttp request's request and the pointer
    and the buffer size and a count's whereabouts returning the result number.
  if the result number is 0, put "Error reading data." into the i/o error; clear the response; break.
  put the pointer plus the count minus 1 into the response's last.
  if the count is 0, break.
  repeat.

to read stdin into a buffer:
  clear the i/o error.
  clear the buffer.
  find a string given the environment variables and "CONTENT_LENGTH".
  if the string is blank, put "Error getting content_length" into the i/o error; exit.
  convert the string into a length.
  if the length is 0, exit.
  reassign the buffer's first given the length.
  call "kernel32.dll" "ReadFile" with the stdin handle and the buffer's first and the length and a number's whereabouts and nil.
  if the number is not the length, put "Error reading stdin data" into the i/o error; clear the buffer; exit.
  put the buffer's first plus the length minus 1 into the buffer's last.

to read a string:
  read the default console into the string.

to read a url into a buffer:
  \ prepare
  clear the buffer.
  clear the i/o error.
  \ internet open
  call "wininet.dll" "InternetOpenA" with the module's name's first and 0 [internet_open_type_preconfig] and nil and nil returning a internet handle.
  if the internet handle is 0, put "Could not connect to the internet." into the i/o error; exit.
  \ internet open url
  privatize the url.
  null terminate the url.
  call "wininet.dll" "InternetOpenUrlA" with the internet handle and the url's first and nil and 0 and 0 and 0 returning a url handle.
  if the url handle is 0, put "Could not connect to url '" then the url then "'." into the i/o error; call "wininet.dll" "InternetCloseHandle" with the internet handle; exit.
  \ read the file
  put 64 kilobytes into a buffer size.
  loop.
  put the buffer's length into a saved length.
  reassign the buffer's first given the saved length plus the buffer size.
  put the buffer's first plus the saved length into a  pointer.
  call "wininet.dll" "InternetReadFile" with the url handle and the pointer and the buffer size and a count's whereabouts returning a result number.
  if the result number is 0, put "Error reading url '" then the url then "'." into the i/o error; break.
  put the pointer plus the count minus 1 into the buffer's last.
  if the count is 0, break.
  repeat.
  \ clean up
  call "wininet.dll" "InternetCloseHandle" with the url handle.
  call "wininet.dll" "InternetCloseHandle" with the internet handle.

to reassign a pointer given a byte count:
  if the pointer is nil, assign the pointer given the byte count; exit.
  if the byte count is 0, unassign the pointer; exit.
  privatize the byte count.
  round the byte count up to the nearest power of two.
  call "kernel32.dll" "HeapReAlloc" with the heap pointer and 8 [heap_zero_memory] and the pointer and the byte count returning the pointer.

to receive a buffer from a socket:
  clear the i/o error.
  clear the buffer.
  put 8 kilobytes into a buffer size.
  loop.
  put 0 into a size.  
  put the buffer's length into a saved length.
  reassign the buffer's first given the saved length plus the buffer size.
  put the buffer's first plus the saved length into a  pointer.
  call "ws2_32.dll" "recv" with the socket and the pointer and the buffer size and 0 returning a count.
  if the count is not -1 [socket_error], put the pointer plus the count minus 1 into the buffer's last; exit.
  if the system's last winsock error is not 10040 [wsamsgsize], put "Error receiving data." into the i/o error; clear the buffer; exit.
  put the pointer plus the count minus 1 into the buffer's last.
  repeat.

to receive the response from a winhttp request:
  if the winhttp request is nil, exit.
  call "winhttp.dll" "WinHttpReceiveResponse"
    with the winhttp request's request
    and 0
    returning a result number.
  if the result is 0, put "Could not send request." into the i/o error; exit.

a recipient is a string.

the record-separator byte is a byte equal to 30.

the red color is a color.

to reduce a ratio:
  get a gcd given the ratio's numerator and the ratio's denominator.
  divide the ratio's numerator by the gcd.
  divide the ratio's denominator by the gcd.

a refer is a thing with a string and a pointer (reference).

to refresh the cursor:
  create an event.
  put "set cursor" into the event's kind.
  if the alt key is down, set the event's alt flag.
  if the ctrl key is down, set the event's ctrl flag.
  if the shift key is down, set the event's shift flag.
  put the mouse's spot into the event's spot.
  enque the event.

to refresh the screen:
  refresh the screen given the screen's box.

to refresh the screen given a box:
  call "gdi32.dll" "BitBlt" with the screen canvas and the box's left and the box's top and the box's width and the box's height 
   and the current canvas and the box's left and the box's top and 13369376 [srccopy].

the registered byte is a byte equal to 174.

the registered-trade-mark byte is a byte equal to 174.

to relinquish control:
  flush the event queue.
  create an event.
  put "done" into the event's kind.
  enque the event.

a remainder is a number.

to remember a text:
  if the text is nil, exit.
  destroy the text's redos.
  copy the text into another text.
  scale the other text to 1/1.
  append the other text to the text's undos.
  limit the text's undos to the max text undos.
  set the text's modified flag.

to remember a text with an operation:
  if the text is nil, exit.
  if the text's last operation is the operation, set the text's modified flag; exit.
  remember the text.
  put the operation into the text's last operation.

the remembered pdf path is a path.

to remove any leading noise from a string:
  if the string is blank, exit.
  if the string's first's target is not noise, exit.
  remove the first byte from the string.
  repeat.

to remove any selected bytes in a text:
  if the text is nil, exit.
  if nothing is selected in the text, exit.
  put the text's selection into a selection.
  normalize the selection.
  get a row given the selection's anchor row# and the text.
  slap a substring on the row's string.
  put the substring's first plus the selection's anchor column# minus 2 into the substring's last.
  get another row given the selection's caret row# and the text.
  slap another substring on the other row's string.
  put the other substring's first plus the selection's caret column# minus 1 into the other substring's first.
  put the substring then the other substring into the row's string.
  remove the rows of the text between the row's next and the other row.
  put the selection's anchor into the text's caret.
  deselect the text.

to remove any trailing backslash from a string:
  if the string is blank, exit.
  if the string's last's target is not the backslash byte, exit.
  remove the last byte from the string.

to remove any trailing linefeed byte from a string:
  if the string is blank, exit.
  if the string's last's target is not the linefeed byte, exit.
  remove the last byte from the string.

to remove any trailing noise from a string:
  if the string is blank, exit.
  if the string's last's target is not noise, exit.
  remove the last byte from the string.
  repeat.

to remove any trailing return byte from a string:
  if the string is blank, exit.
  if the string's last's target is not the return byte, exit.
  remove the last byte from the string.

to remove bytes from a string given a substring:
  if the string is blank, exit.
  if the substring is blank, exit.
  put the string's last minus the substring's last into a length.
  put the substring's last plus 1 into a pointer.
  copy bytes from the pointer to the substring's first for the length.
  put the string's length minus the substring's length into a new length.
  reassign the string's first given the new length.
  put the string's first plus the new length minus 1 into the string's last.

to remove bytes from a text (backspace over a return):
  if the text is nil, exit.
  if the text's caret row# is 1, exit.
  get a row given the text's caret row# minus 1 and the text.
  put the row's string's length and the text's caret row# minus 1 into the text's caret.
  remove any selected bytes in the text.

to remove bytes from a text (backspace with jump):
  if the text is nil, exit.
  if something is selected in the text, remove any selected bytes in the text; exit.
  if the text's caret column# is 1, remove bytes from the text (backspace over a return); exit.
  jump the caret left in the text.
  remove any selected bytes in the text.

to remove bytes from a text (backspace):
  if the text is nil, exit.
  if something is selected in the text, remove any selected bytes in the text; exit.
  if the text's caret column# is 1, remove bytes from the text (backspace over a return); exit.
  move the caret left in the text.
  remove any selected bytes in the text.

to remove bytes from a text (forward delete a return):
  if the text is nil, exit.
  if the text's caret row# is the text's row count, exit.
  put 1 and the text's caret row# plus 1 into the text's caret.
  remove any selected bytes in the text.

to remove bytes from a text (forward delete with jump):
  if the text is nil, exit.
  if something is selected in the text, remove any selected bytes in the text; exit.
  get a row given the text's caret row# and the text.
  if the text's caret column# is the row's string's length, remove bytes from the text (forward delete a return); exit.
  jump the caret right in the text.
  remove any selected bytes in the text.

to remove bytes from a text (forward delete):
  if the text is nil, exit.
  if something is selected in the text, remove any selected bytes in the text; exit.
  get a row given the text's caret row# and the text.
  if the text's caret column# is the row's string's length, remove bytes from the text (forward delete a return); exit.
  move the caret right in the text.
  remove any selected bytes in the text.

to remove every byte in a text:
  if the text is nil, exit.
  put "" into the text.

to remove the first byte from a string:
  slap a substring on the first byte of the string.
  remove bytes from the string given the substring.

to remove the last byte from a string:
  slap a substring on the last byte of the string.
  remove bytes from the string given the substring.

to remove the last two bytes from a string:
  remove trailing bytes from the string given 2.

to remove leading bytes from a string given a count:
  privatize the count.
  if the count is greater than the string's length, clear the string; exit.
  slap a substring on the first byte of the string.
  put the substring's first plus the count minus 1 into the substring's last.
  remove bytes from the string given the substring.

to remove the rows of a text between a row and another row:
  if the text is nil, exit.
  if the row is nil, exit.
  if the other row is nil, exit.
  if the row's row# is greater than the other row's row#, exit.
  privatize the row.
  put the other row's next into a stop row.
  loop.
  if the row is the stop row, break.
  put the row's next into a next row.
  remove the row from the text's rows.
  destroy the row.
  put the next row into the row.
  repeat.
  renumber the text's rows.

to remove a thing from some things:
  if the thing is nil, exit.
  if the thing is the things' first, put the thing's next into the things' first.
  if the thing is the things' last, put the thing's previous into the things' last.
  if the thing's next is not nil, put the thing's previous into the thing's next's previous.
  if the thing's previous is not nil, put the thing's next into the thing's previous' next.
  void the thing's next.
  void the thing's previous.

to remove trailing bytes from a string given a count:
  privatize the count.
  if the count is greater than the string's length, clear the string; exit.
  slap a substring on the last byte of the string.
  put the substring's last minus the count plus 1 into the substring's first.
  remove bytes from the string given the substring.

to rename a path to another path in the file system:
  privatize the path.
  remove any trailing backslash from the path.
  null terminate the path.
  privatize the other path.
  remove any trailing backslash from the other path.
  null terminate the other path.
  call "kernel32.dll" "MoveFileA" with the path's first and the other path's first returning a number.
  clear the i/o error.
  if the number is not 0, exit.
  put "Error renaming file '" then the path then "'." into the i/o error.

to renumber some rows:
  get a row from the rows.
  if the row is nil, exit.
  add 1 to a row#.
  put the row# into the row's row#.
  repeat.

to replace a byte with another byte in a string:
  slap a substring on the string.
  loop.
  if the substring is blank, exit.
  if the substring's first's target is not the byte, add 1 to the substring's first; repeat.
  put the other byte into the substring's first's target.
  add 1 to the substring's first.
  repeat.

to reque an event:
  copy the event into another event.
  enque the other event.

to reset the caret of a text:
  if the text is nil, exit.
  put 1 and 1 into the text's caret.

to reset the drawing origin:
  set the drawing origin to the zero spot.

to reset the origin of a text:
  if the text is nil, exit.
  put the text's margin into the text's x.
  put 0 into the text's y.

to reset a timer:
  put 0 into the timer's count.
  put 0 into the timer's start ticks.
  put 0 into the timer's total ticks.

to resize a box given a ratio pair:
  put the box's x-extent into a width.
  put the box's y-extent into a height.
  scale the width given the ratio pair's ratio.
  scale the height given the ratio pair's other ratio.
  put the box's left plus the width into the box's right.
  put the box's top plus the height into the box's bottom.

to resize a box given a twip pair:
  add the twip pair's x to the box's right.
  add the twip pair's y to the box's bottom.

to resize an ellipse given a ratio pair:
  resize the ellipse's box given the ratio pair.

to resize an ellipse given a twip pair:
  resize the ellipse's box given the twip pair.

to resize a line given a ratio pair:
  put the line's box into a box.
  subtract the box's left-top from the line's start.
  scale the line's start given the ratio pair.
  add the box's left-top to the line's start.
  subtract the box's left-top from the line's end.
  scale the line's end given the ratio pair.
  add the box's left-top to the line's end.

to resize a line given a twip pair:
  put the line's box into a box.
  put the box into another box.
  resize the other box given the twip pair.
  make a ratio pair given the other box and the box.
  resize the line given the ratio pair.

to resize a picture to a width by a height:
  if the picture is nil, exit.
  put the width divided by the tpp into a pixel width.
  put the height divided by the tpp into a pixel height.
  call "gdiplus.dll" "GdipCreateBitmapFromScan0" with the pixel width and the pixel height and 0 and 137224 [pixelformat24bpprgb] and 0 and a gpbitmap's whereabouts.
  call "gdiplus.dll" "GdipGetImageGraphicsContext" with the gpbitmap and a gpgraphic's whereabouts.
  call "gdiplus.dll" "GdipDrawImageRectRectI" with the gpgraphic and the picture's gpbitmap
    and 0 and 0 and the pixel width and the pixel height
    and 0 and 0 and the picture's gpbitmap's width minus 1 and the picture's gpbitmap's height minus 1
    and 2 [unitpixel] and nil and nil and 0.
  call "gdiplus.dll" "GdipDeleteGraphics" with the gpgraphic.
  destroy the picture's gpbitmap.
  put the gpbitmap into the picture's gpbitmap.
  adjust the picture (extract boxes from gpbitmap).
  clear the picture's data.

to resize a polygon given a ratio pair:
  if the polygon is nil, exit.
  put the polygon's box into a box.
  loop.
  get a vertex from the polygon's vertices.
  if the vertex is nil, exit.
  subtract the box's left-top from the vertex's spot.
  scale the vertex's spot given the ratio pair.
  add the box's left-top to the vertex's spot.
  repeat.

to resize a polygon given a twip pair:
  if the polygon is nil, exit.
  put the polygon's box into a box.
  put the box into another box.
  resize the other box given the twip pair.
  make a ratio pair given the other box and the box.
  resize the polygon given the ratio pair.

to resize a text given a ratio pair:
  if the text is nil, exit.
  resize the text's box given the ratio pair.
  wrap the text.

to resize a text given a twip pair:
  if the text is nil, exit.
  resize the text's box given the twip pair.
  wrap the text.

to restart a timer:
  add 1 to the timer's count.
  if the timer's count is not 1, exit.
  put the system's tick count into the timer's start ticks.

to restore a canvas:
  call "gdi32.dll" "RestoreDC" with the canvas and -1. \ need to use -1, windows documentation is wrong

to restore a window:
  call "user32.dll" "ShowWindow" with the window and 9 [sw_restore].

the return byte is a byte equal to 13.

to reverse any selected rows of a text:
  if the text is nil, exit.
  split the rows of the text into some rows and some selected rows and some other rows.
  reverse the selected rows.
  append the rows to the text's rows.
  append the selected rows to the text's rows.
  append the other rows to the text's rows.
  renumber the text's rows.

to reverse a flag:
  if the flag is yes, put no into the flag; exit.
  put yes into the flag.

to reverse some things:
  swap the things with some other things.
  loop.
  put the other things' last into a thing.
  if the thing is nil, exit.
  move the thing from the other things to the things.
  repeat.

a rgb is a record with
  a byte called blue byte,
  a byte called green byte,
  a byte called red byte.

a rgb pointer is a pointer to a rgb.

a rider has \ fix "bump a rider" if you change me
  an original substring,
  a source substring and 
  a token substring.

the right-alligator byte is a byte equal to 62.

the right-alligator-quote byte is a byte equal to 155.

the right-arrow key is a key equal to 39.

the right-brace byte is a byte equal to 125.

the right-bracket byte is a byte equal to 93.

the right-double-alligator-quote byte is a byte equal to 187.

the right-double-quote byte is a byte equal to 148.

the right-paren byte is a byte equal to 41.

the right-single-quote byte is a byte equal to 146.

the right-window key is a key equal to 92.

to rotate a box:
  put the box's center into a center spot.
  put the box into another box.
  put the center's y minus the other box's top plus the center's x into the box's right.
  put the other box's left minus the center's x plus the center's y into the box's top.
  put the center's y minus the other box's bottom plus the center's x into the box's left.
  put the other box's right minus the center's x plus the center's y into the box's bottom.

to rotate an ellipse:
  rotate the ellipse's box.

to rotate a gpimage:
  if the gpimage is nil, exit.
  call "gdiplus.dll" "GdipImageRotateFlip" with the gpimage and 1 [rotate90flipnone].

to rotate a gpimage given an angle: \ angle can be 0, 900, 1800, 2700
  if the gpimage is nil, exit.
  put 0 [rotatenoneflipnone] into a number.
  if the angle is 900, put 1 [rotate90flipnone] into the number.
  if the angle is 1800, put 2 [rotate180flipnone ] into the number.
  if the angle is 2700, put 3 [rotate270flipnone ] into the number.
  call "gdiplus.dll" "GdipImageRotateFlip" with the gpimage and the number.

to rotate a line:
  put the line's center into a center spot.
  rotate the line's start around the center.
  rotate the line's end around the center.

to rotate a picture:
  if the picture is nil, exit.
  add 900 to the picture's rotate angle.
  if the picture's mirror flag is set, add 1800 to the picture's rotate angle.
  normalize the picture's rotate angle.
  rotate the picture's box.
  rotate the picture's uncropped box.
  put the picture's box's center into a center spot.
  put the picture's uncropped box's center into another center spot.
  put the center's y minus the other center's y plus the center's x into a twip pair's x.
  subtract the other center's x from the twip pair's x.
  put the center's y plus the other center's x minus the center's x into the twip pair's y.
  subtract the other center's y from the twip pair's y.
  move the picture's uncropped box given the twip pair.
  rotate the picture's gpbitmap.

to rotate a polygon:
  if the polygon is nil, exit.
  put the polygon's center into a center spot.
  loop.
  get a vertex from the polygon's vertices.
  if the vertex is nil, exit.
  rotate the vertex's spot around the center.
  repeat.

to rotate a spot around a center spot:
  put the spot into another spot.
  put the center's y minus the other spot's y plus the center's x into the spot's x.
  put the other spot's x minus the center's x plus the center's y into the spot's y.

to rotate a text:
  if the text is nil, exit.
  rotate the text's box.
  wrap the text.

to round a number to another number: 
  round the number to the nearest multiple of the other number.

to round a number down to the nearest multiple of another number:
  divide the number by the other number.
  multiply the number by the other number.

to round a number to the nearest multiple of another number:
  if the other number is 0, exit.
  privatize the other number.
  divide the number by the other number giving a quotient and a remainder.
  divide the other number by 2.
  if the remainder is greater than or equal to the other number, round the number up to the nearest multiple of the original other number; exit.
  round the number down to the nearest multiple of the original other number.

to round a number up to the nearest multiple of another number:
  divide the number by the other number giving a quotient and a remainder.
  if the remainder is 0, exit.
  add the other number minus the remainder to the number.

to round a number up to the nearest power of two:
  intel $8B8D08000000. \ mov ecx,[ebp+8] \ the number
  intel $8B09. \ mov ecx,[ecx]
  intel $49. \ dec ecx
  intel $0FBDC9. \ bsr ecx,ecx
  intel $41. \ inc ecx
  intel $81F904000000. \ cmp ecx,4
  intel $0F8F05000000. \ jg over the next 1 statement
  intel $B904000000. \ mov ecx,4
  intel $8B8508000000. \ mov eax,[ebp+8] \ the number
  intel $C70001000000. \ mov [eax],1
  intel $D320. \ shl [eax],ecx  

to round a pair to another pair:
  round the pair to the nearest multiple of the other pair.

to round a pair to the nearest multiple of another pair:
  round the pair's x to the nearest multiple of the other pair's x.
  round the pair's y to the nearest multiple of the other pair's y.

to round a pair to the nearest multiple of a number:
  round the pair's x to the nearest multiple of the number.
  round the pair's y to the nearest multiple of the number.

to round a pair to a number:
  round the pair to the nearest multiple of the number.

a roundy box is a box with
  a left coord, a top coord, a right coord, a bottom coord,
  a left-top spot at the left, a right-bottom spot at the right, and 
  a radius.

a row is a thing with a row# and a string.

a row# is a number.

the s-key is a key equal to 83.

a saturation is a number [0 to 1000].

to save a canvas:
  call "gdi32.dll" "SaveDC" with the canvas.

the saved memory hbitmap is a hbitmap.

the saved tpp is a number.

to say a string: employ speak a string.

to say a string and wait: employ speak a string and wait.

to scale a box given a ratio:
  if the ratio is 1/1, exit.
  scale the box's left given the ratio.
  scale the box's top given the ratio.
  scale the box's right given the ratio.
  scale the box's bottom given the ratio.

to scale a box to a percent:
  put the percent / 100 into a ratio.
  scale the box given the ratio.

to scale an ellipse given a ratio:
  if the ratio is 1/1, exit.
  scale the ellipse's box given the ratio.

to scale an ellipse to a percent:
  put the percent / 100 into a ratio.
  scale the ellipse given the ratio.

to scale a font given a ratio:
  if the ratio is 1/1, exit.
  scale the font's height given the ratio.

to scale a line given a ratio:
  if the ratio is 1/1, exit.
  scale the line's start given the ratio.
  scale the line's end given the ratio.  

to scale a line to a percent:
  put the percent / 100 into a ratio.
  scale the line given the ratio.

to scale a number given a ratio:
  if the ratio's denominator is 0, exit.
  call "kernel32.dll" "MulDiv" with the number and the ratio's numerator and the ratio's denominator returning the number.

to scale a pair given a ratio:
  if the ratio is 1/1, exit.
  scale the pair's x given the ratio.
  scale the pair's y given the ratio.

to scale a pair given a ratio pair:
  scale the pair's x given the ratio pair's ratio.
  scale the pair's y given the ratio pair's other ratio.

to scale a pair to a percent:
  put the percent / 100 into a ratio.
  scale the pair given the ratio.

to scale a picture given a ratio:
  if the picture is nil, exit.
  if the ratio is 1/1, exit.
  scale the picture's box given the ratio.
  scale the picture's uncropped box given the ratio.

to scale a picture to a percent:
  if the picture is nil, exit.
  put the percent / 100 into a ratio.
  scale the picture given the ratio.

to scale a polygon given a ratio:
  if the polygon is nil, exit.
  if the ratio is 1/1, exit.
  loop.
  get a vertex from the polygon's vertices.
  if the vertex is nil, exit.
  scale the vertex given the ratio.
  repeat.

to scale a polygon to a percent:
  if the polygon is nil, exit.
  put the percent / 100 into a ratio.
  scale the polygon given the ratio.

to scale a ratio given another ratio: employ multiply a ratio by another ratio.

to scale a roundy box given a ratio:
  if the ratio is 1/1, exit.
  scale the roundy box as a box given the ratio.
  scale the roundy box's radius given the ratio.

to scale a roundy box to a percent:
  put the percent / 100 into a ratio.
  scale the roundy box given the ratio.

to scale a text given a ratio:
  if the text is nil, exit.
  if the ratio is 1/1, exit.
  scale the text's box given the ratio.
  scale the text's origin given the ratio.
  scale the text's font given the ratio.
  scale the text's scale given the ratio.

to scale a text to a percent:
  if the text is nil, exit.
  put the percent / 100 into a ratio.
  scale the text given the ratio.

to scale a text to a ratio: \ absolute
  if the text is nil, exit.
  put the text's scale into another ratio.
  flip the other ratio.
  multiply the other ratio by the ratio.
  scale the text given the other ratio.

to scale a vertex given a ratio:
  if the vertex is nil, exit.
  if the ratio is 1/1, exit.
  scale the vertex's x given the ratio.
  scale the vertex's y given the ratio.

the screen canvas is a canvas.

the screen has a box, a pixel height and a pixel width.

to scroll a console given an event:
  if the console is nil, exit.
  find a sector given the console's grid and the event's spot.
  loop.
  if the mouse's right button is up, exit.
  find another sector given the console's grid and the mouse's spot.
  get a difference between the other sector and the sector.
  if the difference is 0, repeat.
  scroll the console's text given the difference.
  show the console.
  add the difference to the sector.
  repeat.

to scroll a text to the bottom:
  if the text is nil, exit.
  if the text's vertical scroll flag is not set, exit.
  put the text's row count minus 1 into a number.
  put - the number times the text's row height into the text's y.
  limit the origin of the text.

to scroll a text to the caret:
  if the text is nil, exit.
  if the text's caret's column# is 1, put the text's margin into the text's x.
  get a box for the caret in the text.
  adjust the box given 0 and - the tpp and 0 and the tpp. \ caret boxes don't fill entire row
  if the box's top is less than the text's top, put the text's top minus the box's top into a difference's y.
  if the box's bottom is greater than the text's bottom, put the text's bottom minus the box's bottom into the difference's y.
  if the box's left is less than the text's left, put the text's left minus the box's left into the difference's x.
  if the box's right is greater than the text's right, put the text's right minus the box's right into the difference's x.
  if the difference is 0, exit.
  scroll the text given the difference.

to scroll a text to the caret and center it:
  if the text is nil, exit.
  put the text's margin into the text's x.
  get a box for the caret in the text.
  if the box is inside the text's box, exit.
  adjust the box given 0 and - the tpp and 0 and the tpp. \ caret boxes don't fill entire row
  put the text's box's y-extent divided by 2 into a height.
  round the height down to the nearest multiple of the text's row height.
  put the text's box's top plus the height into a top coord.
  put the top plus the text's row height into a bottom coord.
  if the box's top is less than the top, put the top minus the box's top into a difference's y.
  if the box's bottom is greater than the bottom, put the bottom minus the box's bottom into the difference's y.
  if the box's left is less than the text's left, put the text's left minus the box's left into the difference's x.
  if the box's right is greater than the text's right, put the text's right minus the box's right into the difference's x.
  if the difference is 0, exit.
  scroll the text given the difference.

to scroll a text down one line:
  if the text is nil, exit.
  if the text's vertical scroll flag is not set, exit.
  put - the text's row height into a difference's y.
  scroll the text given the difference.

to scroll a text down one page:
  if the text is nil, exit.
  if the text's vertical scroll flag is not set, exit.
  subtract the text's box's y-extent from the text's y.
  add the text's row height to the text's y.
  limit the origin of the text.

to scroll a text given a difference:
  if the text is nil, exit.
  privatize the difference.
  if the text's horizontal scroll flag is not set, put 0 into the difference's x.
  if the text's vertical scroll flag is not set, put 0 into the difference's y.
  if the difference is 0, exit.
  move the text's origin given the difference.
  limit the origin of the text.

to scroll a text to the top:
  if the text is nil, exit.
  if the text's vertical scroll flag is not set, exit.
  put 0 into the text's y.
  limit the origin of the text.

to scroll a text up one line:
  if the text is nil, exit.
  if the text's vertical scroll flag is not set, exit.
  put the text's row height into a difference's y.
  scroll the text given the difference.

to scroll a text up one page:
  if the text is nil, exit.
  if the text's vertical scroll flag is not set, exit.
  add the text's box's y-extent to the text's y.
  subtract the text's row height from the text's y.
  limit the origin of the text.

the scrolllock key is a key equal to 145.

a second is 1000 milliseconds.

the sector byte is a byte equal to 167.

a sector is a pair with an x coord and an y coord [indicating the left-top of the sector].

the seed is a number.

to seed the random number generator:
  put the system's tick count into the seed.

to select every byte in a text:
  if the text is nil, exit.
  put 1 and 1 into the text's anchor.
  put the text's rows' last's string's length and the text's row count into the text's caret.

to select a row# given a text:
  if the text is nil, exit.
  get a row given the row# and the text.
  if the row is nil, exit.
  put the row# into the text's anchor row#.
  put 1 into the text's anchor column#.
  put the row# into the text's caret row#.
  put the row's string's length into the text's caret column#.

a selection box is a box.

a selection has 
  an anchor column#, an anchor row#, an anchor at the anchor column#,
  a caret column#, a caret row#, a caret at the caret column#.

the semi-colon byte is a byte equal to 59.

to send a buffer to a socket:
  clear the i/o error.
  put the buffer's first into a pointer.
  put the buffer's length into a length.
  loop.
  if the length is 0, break.
  call "ws2_32.dll" "send" with the socket and the pointer and the length and 0 returning a number.
  if the number is -1 [socket_error], put "Error sending data." into the i/o error; exit.
  subtract the number from the length.
  add the number to the pointer.
  repeat.

to send a data string to a winhttp request:
  if the winhttp request is nil, exit.
  call "winhttp.dll" "WinHttpSendRequest"
    with the winhttp request's request
    and 0 [winhttp_no_additional_headers]
    and 0 
    and the data's first
    and the data's length
    and the data's length
    and 0
    returning a result number.
  if the result is 0, put "Could not send request." into the i/o error; exit.

to send an email:
  clear the i/o error.
  \ create socket
  create a socket given the email's smtp server and 25.
  if the i/o error is not blank, exit.
  \ initial receive here for date/time stuff from server
  receive a response string from the socket.
  if the i/o error is not blank, destroy the socket; exit.
  if the response starts with "5", put the response into the i/o error; trim the i/o error; destroy the socket; exit.
  \ send HELO
  send "HELO " then the module's name then the crlf string to the socket and receive the response string.
  if the i/o error is not blank, destroy the socket; exit.
  if the response starts with "5", put the response into the i/o error; trim the i/o error; destroy the socket; exit.
  \ send MAIL FROM: <xxx>
  send "MAIL FROM: <" then the email's sender then ">" then the crlf string to the socket and receive the response string.
  if the i/o error is not blank, destroy the socket; exit.
  if the response starts with "5", put the response into the i/o error; trim the i/o error; destroy the socket; exit.
  \ send RCPT TO: <xxx>
  send "RCPT TO: <" then the email's recipient then ">" then the crlf string to the socket and receive the response string.
  if the i/o error is not blank, destroy the socket; exit.
  if the response starts with "5", put the response into the i/o error; trim the i/o error; destroy the socket; exit.
  \ send DATA
  send "DATA" then the crlf string to the socket and receive the response string.
  if the i/o error is not blank, destroy the socket; exit.
  if the response starts with "5", put the response into the i/o error; trim the i/o error; destroy the socket; exit.
  \ send From: xxx crlf To: xxx crlf Subject: xxx crlf Reply-To: xxx crlf message crlf . crlf
  clear a temp string.
  append "From: " then the email's sender then the crlf string to the temp string.
  append "To: " then the email's recipient then the crlf string to the temp string.
  append "Subject: " then the email's subject then the crlf string into the temp string.
  append "Reply-To: " then the email's sender then the crlf string into the temp string.
  append the crlf string to the temp string.
  append the email's message to the temp string (handling email transparency).
  append the crlf string then "." then the crlf string to the temp string.
  send the temp string to the socket and receive the response string.
  if the i/o error is not blank, destroy the socket; exit.
  if the response starts with "5", put the response into the i/o error; trim the i/o error; destroy the socket; exit.
  \ send QUIT
  send "QUIT" then the crlf string to the socket.
  \ destroy socket
  destroy the socket.

to send a message from a sender to a recipient:
  send the message to the recipient from the sender.

to send a message from a sender to a recipient via a smtp server:
  send the message to the recipient from the sender via the smtp server.

to send a message from a sender to a recipient with a subject:
  send the message to the recipient from the sender with the subject.

to send a message from a sender to a recipient with a subject via a smtp server:
  send the message to the recipient from the sender with the subject via the smtp server.

to send a message to a recipient from a sender:
  put the default smtp server into an email's smtp server.
  put the recipient into the email's recipient.
  put the sender into the email's sender.
  put the message into the email's message.
  send the email.

to send a message to a recipient from a sender via a smtp server:
  put the smtp server into an email's smtp server.
  put the recipient into the email's recipient.
  put the sender into the email's sender.
  put the message into the email's message.
  send the email.

to send a message to a recipient from a sender with a subject:
  put the default smtp server into an email's smtp server.
  put the recipient into the email's recipient.
  put the sender into the email's sender.
  put the subject into the email's subject.
  put the message into the email's message.
  send the email.

to send a message to a recipient from a sender with a subject via a smtp server:
  put the smtp server into an email's smtp server.
  put the recipient into the email's recipient.
  put the sender into the email's sender.
  put the subject into the email's subject.
  put the message into the email's message.
  send the email.

to send a string to a socket and receive a response string:
  clear the response string.
  send the string to the socket.
  if the i/o error is not blank, exit.
  receive the response string from the socket.

a sender is a string.

to set the colorref of a canvas given a color:
  convert the color to a colorref.
  call "gdi32.dll" "SetTextColor" with the canvas and the colorref.

to set the drawing origin to a spot:
  call "gdi32.dll" "GetDeviceCaps" with the current canvas and 112 [physicaloffsetx] returning a pair's x.
  call "gdi32.dll" "GetDeviceCaps" with the current canvas and 113 [physicaloffsety] returning the pair's y.
  negate the pair.
  if the current canvas is not the printer canvas, clear the pair.
  call "gdi32.dll" "SetViewportOrgEx" with the current canvas and the pair's x and the pair's y and nil.
  privatize the spot.
  call "gdi32.dll" "LPtoDP" with the current canvas and the spot's whereabouts and 1.
  call "gdi32.dll" "SetViewportOrgEx" with the current canvas and the spot's x and the spot's y and nil.

to set a flag:
  put yes into the flag.

to set a path to read-write mode:
  privatize the path.
  null terminate the path.
  call "kernel32.dll" "GetFileAttributesA" with the path's first returning a number.
  bitwise and the number with -2 [everything except file_attribute_readonly].
  call "kernel32.dll" "SetFileAttributesA" with the path's first and the number.

the seven byte is a byte equal to 55.

the seven key is a key equal to 55.

the sharp-s byte is a byte equal to 223.

a sheet is a box.

to shift a byte left some bits:
  intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the bits
  intel $8B09. \ mov ecx,[ecx]
  intel $8B8508000000. \ mov eax,[ebp+8] \ the byte
  intel $D220. \ shl byte pointer [eax],ecx

to shift a byte right some bits:
  intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the bits
  intel $8B09. \ mov ecx,[ecx]
  intel $8B8508000000. \ mov eax,[ebp+8] \ the byte
  intel $D228. \ shr byte pointer [eax],ecx

the shift key is a key equal to 16.

to shift a number left some bits:
  intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the bits
  intel $8B09. \ mov ecx,[ecx]
  intel $8B8508000000. \ mov eax,[ebp+8] \ the number
  intel $D320. \ shl [eax],ecx

to shift a number right some bits:
  intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the bits
  intel $8B09. \ mov ecx,[ecx]
  intel $8B8508000000. \ mov eax,[ebp+8] \ the number
  intel $D328. \ shr [eax],ecx

to shift a wyrd left some bits:
  intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the bits
  intel $8B09. \ mov ecx,[ecx]
  intel $8B8508000000. \ mov eax,[ebp+8] \ the wyrd
  intel $66D320. \ shl word ptr [eax],ecx

to shift a wyrd right some bits:
  intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the bits
  intel $8B09. \ mov ecx,[ecx]
  intel $8B8508000000. \ mov eax,[ebp+8] \ the wyrd
  intel $66D328. \ shr word ptr [eax],ecx

the shift-in byte is a byte equal to 15.

the shift-out byte is a byte equal to 14.

to show a console:
  if the console is nil, exit.
  save the current canvas.
  draw the console.
  refresh the screen given the console's box.
  restore the current canvas.

to show a cursor:
  call "user32.dll" "SetCursor" with the cursor.
  call "user32.dll" "ShowCursor" with 1 returning a number.
  if the number is greater than 0, exit.
  repeat.

to shut down:
  destroy the lexicon.
  destroy the default console.
  finalize the canvases.
  finalize the mouse.
  finalize the cursors.
  finalize the fonts.
  finalize the window.
  finalize the screen.
  finalize the colors.
  finalize the module.
  finalize the talker.
  finalize gdi+.
  finalize winsock.
  finalize com.

to shut down the cgi:
  finalize the cgi.
  finalize the module.
  finalize winsock.

the silent flag is a flag.

the single-quote byte is a byte equal to 39.

the six byte is a byte equal to 54.

the six key is a key equal to 54.

a size is a number.

to skip any leading linefeed byte in a substring:
  if the substring is blank, exit.
  if the substring's first's target is not the linefeed byte, exit.
  add 1 to the substring's first.

to skip any leading noise in a substring:
  if the substring is blank, exit.
  if the substring's first's target is not noise, exit.
  add 1 to the substring's first.
  repeat.

to skip any non-alphanumeric bytes in a substring:
  if the substring is blank, exit.
  if the substring's first's target is alphanumeric, exit.
  add 1 to the substring's first.
  repeat.

to skip word characters in a substring:
  if the substring is blank, exit.
  if the substring is on any contraction, add 1 to the substring's first; repeat.
  if the substring's first's target is not alphanumeric, exit.
  add 1 to the substring's first.
  repeat.

the sky color is a color.

to slap a rider on another rider:
  slap the rider's source on the other rider's source.
  position the rider's token on the rider's source.

to slap a rider on a string:
  slap the rider's original on the string.
  slap the rider's source on the string.
  position the rider's token on the rider's source.

to slap a substring on any selected bytes in a row of a text:
  clear the substring.
  if the text is nil, exit.
  if the row of the text is not selected, exit.
  slap the substring on the row's string.
  put the text's normalized selection into a selection.
  if the row's row# is the selection's caret row#, put the substring's first plus the selection's caret column# minus 2 into the substring's last.
  if the row's row# is the selection's anchor row#, put the substring's first plus the selection's anchor column# minus 1 into the substring's first.

to slap a substring on the first byte of a string:
  slap the substring on the string.
  if the string is blank, exit.
  put the string's first into the substring's last.

to slap a substring on the last byte of a string:
  slap the substring on the string.
  if the string is blank, exit.
  put the string's last into the substring's first.

to slap a substring on a string:
  intel $8B8508000000. \ mov eax,[ebp+8] \ the substring
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the string
  \ put the string's first into the substring's first
  intel $8B8B00000000. \ mov ecx,[ebx+0] \ the string's first
  intel $898800000000. \ mov [eax+0],ecx \ the substring's first
  \ put the string's last into the substring's last
  intel $8B8B04000000. \ mov ecx,[ebx+4] \ the string's last
  intel $898804000000. \ mov [eax+4],ecx \ the substring's last

the slash byte is a byte equal to 47.

the small-bullet byte is a byte equal to 183.

the smallest number is -2147483648.

to smooth a polygon:
  if the polygon is nil, exit.
  if the polygon's vertices' count is less than 3, exit.
  if the polygon is closed, append the polygon's first vertex's next's spot to the polygon; set a flag.
  put the polygon's first vertex into a left vertex.
  loop.
  if the left vertex's next is nil, break.
  put the left vertex's next into a right vertex.
  get a center spot given the left vertex's spot and the right vertex's spot.
  insert the center into the polygon after the left vertex.
  put the left vertex's next into a new vertex.
  if the left vertex's previous is nil, put the right vertex into the left vertex; repeat.
  get another center spot given the left vertex's previous' spot and the new vertex's spot.
  get a difference between the other center and the left vertex's spot.
  divide the difference by 2.
  add the difference to the left vertex's spot.
  put the right vertex into the left vertex.
  repeat.
  if the flag is not set, exit.
  destroy the polygon's first vertex given the polygon.
  destroy the polygon's last vertex given the polygon.

an smtp server is a string.

a sockaddr is a record with
  a wyrd called sin_family,
  a big-endian unsigned wyrd called sin_port,
  a in_addr called sin_addr,
  8 bytes called sin_zero.

a sockaddrptr is a pointer to a sockaddr.

a socket is a pointer.

the soft-dash byte is a byte equal to 173.

to sort any selected rows in a text:
  if the text is nil, exit.
  split the rows of the text into some rows and some selected rows and some other rows.
  sort the selected rows.
  append the rows to the text's rows.
  append the selected rows to the text's rows.
  append the other rows to the text's rows.
  renumber the text's rows.

to sort some rows:
  if the rows' first is the rows' last, exit.
  split the rows into some left rows and some right rows.
  sort the left rows.
  sort the right rows.
  loop.
  put the left rows' first into a left row.
  put the right rows' first into a right row.
  if the left row is nil, append the right rows to the rows; exit.
  if the right row is nil, append the left rows to the rows; exit.
  if the left row's string is greater than the right row's string, move the right row from the right rows to the rows; repeat.
  move the left row from the left rows to the rows.
  repeat.

the space byte is a byte equal to 32.

the space key is a key equal to 32.

the space string is a string equal to " ".

to speak a string:
  if the silent flag is set, exit.
  if the talker is nil, exit.
  if the string is blank, exit.
  convert the string to a wide string.
  null terminate the wide string.
  call the talker's vtable's speak with the talker and the wide string's first and 17 [svsfdefault+svsflagsasyn+svsfisnotxml] and 0.

to speak a string and wait:
  if the silent flag is set, exit.
  if the talker is nil, exit.
  if the string is blank, exit.
  convert the string to a wide string.
  null terminate the wide string.
  call the talker's vtable's speak with the talker and the wide string's first and 16 [svsfdefault+svsfisnotxml] and 0.

to split a buffer into some dyads:
  destroy the dyads.
  if the buffer is blank, exit.
  slap a rider on the buffer.
  loop.
  move the rider given the ampersand byte.
  if the rider's token is blank, exit.
  create a dyad. 
  append the dyad to the dyads.
  split the rider's token into a name substring and a query substring given the equal-sign byte.
  put the name substring into the dyad's name.
  convert the query substring as a query string into the dyad's value.
  repeat.

to split a byte into a nibble and another nibble:
  put the byte into the nibble.
  shift the nibble right 4 bits.
  put the byte into the other nibble.
  bitwise and the other nibble with 15.

to split a line into another line and a third line:
  privatize the line.
  put the line's center into a center spot.
  put the line's start and the center into the other line.
  put the center and the line's end into the third line. 

to split a number into a wyrd and another wyrd:
  privatize the number.
  shift the number right 16 bits.
  put the number into the wyrd.
  put the original number into the other wyrd.

to split the rows of a text into some rows and some selected rows and some other rows:
  if the text is nil, clear the rows; clear the selected rows; clear the other rows; exit.
  loop.
  put the text's rows' first into a row.
  if the row is nil, exit.
  remove the row from the text's rows.
  if the row of the text is selected, set a flag; append the row to the selected rows; repeat.
  if the flag is set, append the row to the other rows; repeat.
  append the row to the rows.
  repeat.

to split a string into a left substring and a right substring given a separator byte:
  clear the left.
  clear the right.
  if the string is blank, exit.
  put the string's first into a substring's first.
  put the substring's first minus 1 into the substring's last.
  loop.
  if the substring's last is greater than the string's last, exit.
  add 1 to the substring's last.
  if the substring's last's target is the separator byte, break.
  repeat.
  put the substring's first into the left's first.
  put the substring's last minus 1 into the left's last.
  put the substring's last plus 1 into the right's first.
  put the string's last into the right's last.

to split a string into some string things given a separator byte:
  destroy the string things.
  if the string is blank, exit.
  slap a rider on the string.
  loop.
  move the rider given the separator byte.
  add the rider's token to the string things.
  if the rider's source is blank, break.
  repeat.
  if the string's last's target is not the separator byte, exit.
  add "" to the string things.

to split some things into some left things and some right things:
  if the things are empty, clear the left things; clear the right things; exit.
  put the things' count divided by 2 into a count.
  loop.
  get a thing from the things.
  if the count is 0, break.
  subtract 1 from the count.
  repeat.
  split the things into the left things and the right things at the thing. 

to split some things into some left things and some right things at a thing:
  clear the left things.
  clear the right things.
  if the thing is nil, swap the things with the left things; exit.
  if the thing's previous is nil, swap the things with the left things; exit.
  \ set up the left chain
  put the things' first into the left things' first.
  put the thing's previous into the left things' last.
  void the thing's previous' next.
  \ set up the right chain
  put the thing into the right things' first.
  void the thing's previous.
  put the things' last into the right things' last.
  \ fix the original chain
  clear the things.

to split a wyrd into a byte and another byte:
  privatize the wyrd.
  shift the wyrd right 8 bits.
  put the wyrd into the byte.
  put the original wyrd into the other byte.

a spot is a pair with an x coord and a y coord.

a spot pointer is a pointer to a spot.

to square up any selection in a text:
  if the text is nil, exit.
  if nothing is selected in the text, exit.
  normalize the text's selection.
  get a row given the text's caret row# and the text.
  put 1 into the text's anchor column#.
  if the text's caret column# is not 1, add 1 to the text's caret row#; put 1 into the text's caret column#.
  if the text's caret row# is less than or equal to the text's row count, exit.
  put the text's row count into the text's caret's row#.
  put the row's string's length into the text's caret's column#.

to start a process given a path: \ must be called with a global variable
  clear the i/o error.
  if the process is not 0, put "I'm sorry, but that process is already running." into the i/o error; exit.
  put a startupinfo's magnitude into the startupinfo's cb.
  extract a directory from the path. null terminate the directory.
  privatize the path. null terminate the path.
  call "kernel32.dll" "CreateProcessA" with the path's first and 0 and 0 and 0 and 0 and 67108904 [create_default_error_mode + normal_priority_class + detached_process] and 0 
    and the directory's first and the startupinfo's whereabouts and a processinfo's whereabouts returning a number.
  if the number is 0, put "I'm unable to run the program." into the i/o error; exit.
  put the processinfo's hprocess into the process.
  call "kernel32.dll" "CloseHandle" with the processinfo's hthread.
  point a pointer to routine wait for a process pointer.
  call "kernel32.dll" "CreateThread" with 0 and 0 and the pointer and the process's whereabouts and 0 and another number's whereabouts returning a handle.
  call "kernel32.dll" "CloseHandle" with the handle. \ does not end the thread, just dumps the handle

to start a timer:
  reset the timer.
  restart the timer.

to start up:
  initialize com.
  initialize winsock.
  initialize gdi+.
  initialize the talker.
  initialize the module.
  initialize the colors.
  initialize the screen.
  initialize the window.
  initialize the fonts.
  initialize the cursors.
  initialize the mouse.
  initialize the canvases.
  create the default console.

to start up the cgi:
  initialize winsock.
  initialize the module.
  initialize the cgi.

the start-of-heading byte is a byte equal to 1.

the start-of-text byte is a byte equal to 2.

a startupinfo is a record with
  a number called cb,
  a pointer called lpreserved,
  a pointer called lpdesktop,
  a pointer called lptitle,
  a number called dwx,
  a number called dwy,
  a number called dwxsize,
  a number called dwysize,
  a number called dwxcountchars,
  a number called cwycountchars,
  a number called dwfillattribute,
  a number called dwflags,
  a wyrd called wshowwindow,
  a wyrd called cbreserved2,
  a pointer called lpreserved2,
  a handle called hstdinput,
  a handle called hstdoutput,
  a handle called hstderror.

the stdin handle is a handle.

the stdout handle is a handle.

to stop a process:
  if the process is 0, exit.
  call "kernel32.dll" "TerminateProcess" with the process and 0.
  put 0 into the process.

to stop a timer:
  if the timer's count is 0, exit.
  subtract 1 from the timer's count.  
  if the timer's count is not 0, exit.
  put the system's tick count into some ticks.
  subtract the timer's start ticks from the ticks.
  add the ticks to the timer's total ticks.

a string has a first byte pointer and a last byte pointer.

a string thing is a thing with a string.

a string# is a number.

a subject is a string.

the substitute byte is a byte equal to 26.

a substring is a string.

to subtract a byte from another byte:
  intel $8B8508000000. \ mov eax,[ebp+8] \ the byte
  intel $0FB600. \ movzx eax,[eax]
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the other byte
  intel $2803. \ sub [ebx],al

to subtract a byte from a number:
  intel $8B8508000000. \ mov eax,[ebp+8] \ the byte
  intel $0FB600. \ movzx eax,[eax]
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the number
  intel $2903. \ sub [ebx],eax

to subtract a number and another number from a pair:
  subtract the number from the pair's x.
  subtract the other number from the pair's y.

to subtract a number from another number:
  intel $8B8508000000. \ mov eax,[ebp+8] \ the number
  intel $8B00. \ mov eax,[eax]
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the other number
  intel $2903. \ sub [ebx],eax

to subtract a number from a byte:
  intel $8B8508000000. \ mov eax,[ebp+8] \ the number
  intel $8B00. \ mov eax,[eax]
  intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the byte
  intel $0FB60B. \ movzx ecx,[ebx]
  intel $2BC8. \ sub ecx,eax
  intel $880B. \ mov [ebx],cl

to subtract a number from a pair:
  subtract the number from the pair's x.
  subtract the number from the pair's y.

to subtract a number from a pointer: employ subtract a number from another number.

to subtract a number from a ratio:
  subtract the number / 1 from the ratio.

to subtract a pair from another pair:
  subtract the pair's x from the other pair's x.
  subtract the pair's y from the other pair's y.

to subtract a pointer from another pointer: employ subtract a number from another number.

to subtract a ratio from another ratio:
  privatize the ratio.
  normalize the ratio and the other ratio.
  subtract the ratio's numerator from the other ratio's numerator.
  reduce the other ratio.

the superscript-one byte is a byte equal to 185.

the superscript-three byte is a byte equal to 179.

the superscript-two byte is a byte equal to 178.

to swap a color with another color:
  swap the color's hue with the other color's hue.
  swap the color's saturation with the other color's saturation.
  swap the color's lightness with the other color's lightness.

to swap a number with another number:
  put the number into a third number.
  put the other number into the number.
  put the third number into the other number.

to swap a pair with another pair:
  swap the pair's x with the other pair's x.
  swap the pair's y with the other pair's y.

to swap a pointer with another pointer: employ swap a number with another number.

to swap some things with some other things:
  swap the things' first with the other things' first.
  swap the things' last with the other things' last.

the synchronous-idle byte is a byte equal to 22.

a systemtime is a record with
  a wyrd called wyear,
  a wyrd called wmonth,
  a wyrd called wdayofweek,
  a wyrd called wday,
  a wyrd called whour,
  a wyrd called wminute,
  a wyrd called wsecond,
  a wyrd called wmilliseconds.

the t-key is a key equal to 84.

the tab byte is a byte equal to 9.

the tab key is a key equal to 9.

a talker is a pointer to a talker object.

the talker is a talker.

a talker object is a record with a talker vtable called vtable.

a talker vtable is a pointer to a talker vtable record.

a talker vtable record is a record with
  \ iunknown
  a pointer called queryinterface,
  a pointer called addref,
  a pointer called release, \ IN this:pspvoice OUT number
  \ italker
  a pointer called setnotifysink,
  a pointer called setnotifywindowmessage,
  a pointer called setnotifycallbackfunction,
  a pointer called setnotifycallbackinterface,
  a pointer called setnotifywin32event,
  a pointer called waitfornotifyevent,
  a pointer called getnotifyeventhandle,
  a pointer called setinterest,
  a pointer called getevents,
  a pointer called getinfo,
  a pointer called setoutput,
  a pointer called getoutputobjecttoken,
  a pointer called getoutputstream,
  a pointer called pause,
  a pointer called resume,
  a pointer called setvoice,
  a pointer called getvoice,
  a pointer called speak, \ IN this:pspvoice; pwcs:pwchar; dwflags:number; pulStreamnumber:pnumber OUT number
  a pointer called speakstream,
  a pointer called getstatus,
  a pointer called skip,
  a pointer called setpriority,
  a pointer called getpriority,
  a pointer called setalertboundary,
  a pointer called getalertboundary,
  a pointer called setrate,
  a pointer called getrate,
  a pointer called setvolume,
  a pointer called getvolume,
  a pointer called waituntildone,
  a pointer called setsyncspeaktimeout,
  a pointer called getsyncspeaktimeout,
  a pointer called speakcompleteevent,
  a pointer called isuisupported,
  a pointer called displayui.

the teal color is a color.

the temp path is a path.

the text cutoff is a number equal to 500.

a text is a thing with 
  a box,
  an origin,
  a pen color,
  a font,
  an alignment,
  some rows,
  a margin,
  a scale ratio,
  a wrap flag,
  a horizontal scroll flag,
  a vertical scroll flag,
  a selection,
  a modified flag,
  a last operation,
  some texts called undos,
  some texts called redos.

a textmetric is a record with
  a number called tmheight,
  a number called tmascent,
  a number called tmdescent,
  a number called tminternalleading,
  a number called tmexternalleading,
  a number called tmavecharwidth,
  a number called tmmaxcharwidth,
  a number called tmweight,
  a number called tmoverhang,
  a number called tmdigitizedaspectx,
  a number called tmdigitizedaspecty,
  a byte called tmfirstchar,
  a byte called tmlastchar,
  a byte called tmdefaultchar,
  a byte called tmbreakchar,
  a byte called tmitalic,
  a byte called tmunderlined,
  a byte called tmstruckout,
  a byte called tmpitchandfamily,
  a byte called tmcharset.

a thing is a pointer to a thing record.

a thing record has a next thing and a previous thing.

some things has a first thing and a last thing.

a thousand is 10 hundreds.

the three byte is a byte equal to 51.

the three key is a key equal to 51.

the three-quarter byte is a byte equal to 190.

a tick is a number.

the tilde byte is a byte equal to 126.

a timer has a count, some start ticks and some total ticks.

the tpi is some twips equal to 1440.

the tpp is some twips.

the trade-mark byte is a byte equal to 153.

to trim a string:
  remove any leading noise from the string.
  remove any trailing noise from the string.

a twip is a number.

the two byte is a byte equal to 50.

the two key is a key equal to 50.

the u-key is a key equal to 85.

to unassign a pointer:
  if the pointer is nil, exit.
  call "kernel32.dll" "HeapFree" with the heap pointer and 0 [no options] and the pointer returning a number.
  if the number is 0, exit.
  void the pointer.
  subtract 1 from the heap count.

the underscore byte is a byte equal to 95.

a unit is a number.

the unit-separator byte is a byte equal to 31.

to unlock a gpbitmap given a bitmapdata:
  call "gdiplus.dll" "GdipBitmapUnlockBits" with the gpbitmap and the bitmapdata's whereabouts.

to unmask everything:
  call "gdi32.dll" "SelectClipRgn" with the current canvas and 0.

to unmask inside a box:
  create an hrgn given the box.
  unmask inside the hrgn.
  destroy the hrgn.

to unmask inside an ellipse:
  create an hrgn given the ellipse.
  unmask inside the hrgn.
  destroy the hrgn.

to unmask inside an hrgn:
  call "gdi32.dll" "ExtSelectClipRgn" with the current canvas and the hrgn and 2 [rgn_or].

to unmask inside a polygon:
  create an hrgn given the polygon.
  unmask inside the hrgn.
  destroy the hrgn.

to unmask inside a roundy box:
  create an hrgn given the roundy box.
  unmask inside the hrgn.
  destroy the hrgn.

to unmask outside a box:
  create an hrgn given the box.
  unmask outside the hrgn.
  destroy the hrgn.

to unmask outside an ellipse:
  create an hrgn given the ellipse.
  unmask outside the hrgn.
  destroy the hrgn.

to unmask outside an hrgn:
  create an old hrgn given the zero box.
  call "gdi32.dll" "GetClipRgn" with the current canvas and the old hrgn returning a number.
  if the number is not 1, clear the old hrgn.
  call "gdi32.dll" "SelectClipRgn" with the current canvas and 0.
  call "gdi32.dll" "ExtSelectClipRgn" with the current canvas and the hrgn and 4 [rgn_diff].
  call "gdi32.dll" "ExtSelectClipRgn" with the current canvas and the old hrgn and 2 [rgn_or].
  destroy the old hrgn.

to unmask outside a polygon:
  create an hrgn given the polygon.
  unmask outside the hrgn.
  destroy the hrgn.

to unmask outside a roundy box:
  create an hrgn given the roundy box.
  unmask outside the hrgn.
  destroy the hrgn.

to unquote a string:
  slap a substring on the string.
  if the substring is blank, break.
  if the substring's first's target is not the double-quote byte, exit.
  add 1 to the substring's first.
  loop.
  if the substring is blank, break.
  if the substring's first is the substring's last, break.
  append the substring's first's target to another string.
  if the substring's first's target is the double-quote byte, add 1 to the substring's first.
  add 1 to the substring's first.
  repeat.
  put the other string into the string.

the up-arrow key is a key equal to 38.

to uppercase any selected bytes in a text:
  if the text is nil, exit.
  loop.
  get a row from the text's rows.
  if the row is nil, exit.
  if the row of the text is not selected, repeat.
  slap a substring on any selected bytes in the row of the text.  
  uppercase the substring.
  repeat.

to uppercase a byte:
  intel $8B8508000000. \ mov eax,[ebp+8] \ the byte
  intel $803861. \ cmp byte ptr [eax],'a'
  intel $0F820C000000. \ jb END
  intel $80387A. \ cmp byte ptr [eax],'z'
  intel $0F8703000000. \ ja END
  intel $802820. \ sub byte ptr [eax],$20
  \ END

to uppercase the character under a finger and put it into a string:
  if the finger is nil, exit.
  put the finger's target into the string.
  uppercase the string.

to uppercase a string:
  slap a substring on the string.
  loop.
  if the substring is blank, exit.
  uppercase the substring's first's target.
  add 1 to the substring's first.
  repeat.

to uppercase a text:
  if the text is nil, exit.
  loop.
  get a row from the text's rows.
  if the row is nil, break.
  uppercase the row's string.
  repeat.
  wrap the text.

the upperscore byte is a byte equal to 175.

a url is a string.

a url record has
  a scheme string,
  a host name string,
  a path string,
  an extra string,
  a port number.

a urlcomponents is a record with
  a number called dwstructsize,
  a pchar called lpszscheme,
  a number called dwschemelength,
  a number called nscheme,
  a pchar called lpszhostname,
  a number called dwhostnamelength,
  a number called nport, \ this is typed as a wyrd in windows documentation, but dosen't work
  a pchar called lpszusername,
  a number called dwusernamelength,
  a pchar called lpszpassword,
  a number called dwpasswordlength,
  a pchar called lpszurlpath,
  a number called dwurlpathlength,
  a pchar called lpszextrainfo,
  a number called dwextrainfolength.  

a uuid is a record with
  a number called d1,
  a wyrd called d2,
  a wyrd called d3,
  8 bytes called d4.

the v-key is a key equal to 86.

a vertex array is a pointer to a vertex array record.

a vertex array record has a count and a spot pointer.

a vertex is a thing with an x coord, a y coord, a spot at the x.

the vertical-tab byte is a byte equal to 11.

the violet color is a color.

to void a pointer:
  intel $8B8508000000. \ mov eax,[ebp+8] \ the pointer
  intel $C70000000000. \ mov [eax],0

the w-key is a key equal to 87.

a w-param is a number.

to wait for some milliseconds:
  if the milliseconds are 0, exit.
  call "kernel32.dll" "Sleep" with the milliseconds.

to wait until speaking is done:
  if the talker is nil, exit.
  call the talker's vtable's waituntildone with the talker and -1.

a wave file is a path.

a wave is a hex string.

the white color is a color.

a wide string is a string.

a width is some twips.

a win32finddata is a record with
  a number called dwfileattributes,
  a filetime called ftcreationtime,
  a filetime called ftlastaccesstime,
  a filetime called ftlastwritetime,
  a number called nfilesizehigh,
  a number called nfilesizelow,
  a number called dwreserved0,
  a number called dwreserved1,
  260 bytes called cfilename,
  14 bytes called calternatefilename.

a window class is a record with
  a number called cbsize,
  a number called style,
  a pointer called lpfnwndproc,
  a number called cbclsextra,
  a number called cbwndextra,
  a handle called hinstance,
  a hicon called hicon,
  a cursor called hcursor,
  an hbrush called hbrbackground,
  a pointer called lpszmenuname,
  a pointer called lpszclassname,
  a hicon called hiconsm.

the window class is a window class.

a window is a handle.

a winhttp request is a thing with
  a session handle,
  a connection handle,
  a request handle.

a word is a substring.

to wrap a text:
  if the text is nil, exit.
  if the text's wrap flag is not set, exit.
  convert the text's anchor to an absolute position given the text.
  convert the text's caret to another absolute position given the text.
  put the text's scale into a ratio.
  scale the text to 1/1.
  extract a string from the text.
  append the return byte to the string.
  destroy the text's rows.
  slap a rider on the string.
  create the hfont of the memory canvas given the text's font.
  loop.
  move the rider given the text's box (word wrapping rules).
  if the rider's token is blank, break.
  create a row given the rider's token.
  append the row to the text's rows.
  repeat.
  destroy the hfont of the memory canvas.
  renumber the text's rows.
  scale the text to the ratio.
  convert the absolute position to the text's anchor given the text.
  convert the other absolute position to the text's caret given the text.
  limit the origin of the text.

to write a buffer to a file:
  clear the i/o error.
  call "kernel32.dll" "SetFilePointer" with the file and 0 and 0 and 0 [file_begin] returning a result number.
  if the result number is -1, put "Error positioning file pointer." into the i/o error; exit.
  call "kernel32.dll" "WriteFile" with the file and the buffer's first and the buffer's length and a number's whereabouts and 0 returning the result number.
  if the result number is 0, put "Error writing file." into the i/o error; exit.

to write a buffer to a path:
  clear the i/o error.
  extract a directory from the path.
  if the directory is not in the file system, put "Directory '" then the directory then "' doesn't exist." into the i/o error; exit.
  set the path to read-write mode.
  privatize the path.
  null terminate the path.
  call "kernel32.dll" "CreateFileA" with the path's first and 1073741824 [generic_write] 
    and 0 and 0 and 2 [create_always] and -2147483520 [file_flag_write_through or file_attribute_normal] and 0 returning a handle.
  if the handle is -1 [invalid_handle_value], put "Error opening file '" then the path then "'." into the i/o error; exit.
  call "kernel32.dll" "WriteFile" with the handle and the buffer's first and the buffer's length and a number's whereabouts and 0 returning the number.
  call "kernel32.dll" "CloseHandle" with the handle.
  if the number is not 0, exit.
  put "Error writing file '" then the path then "'." into the i/o error.

to write a byte:
  put the byte into a string.
  write the string.

to write a byte to stdout:
  call "kernel32.dll" "WriteFile" with the stdout handle and the byte's whereabouts and 1 and a number's whereabouts and nil.

to write a byte without advancing:
  put the byte into a string.
  write the string without advancing.

to write a flag:
  convert the flag to a string.
  write the string.

to write a flag without advancing:
  convert the flag to a string.
  write the string without advancing.

to write a number:
  convert the number to a string.
  write the string.

to write a number without advancing:
  convert the number to a string.
  write the string without advancing.

to write a ratio:
  convert the ratio to a string.
  write the string.

to write a ratio without advancing:
  convert the ratio to a string.
  write the string without advancing.

to write a string:
  write the string on the default console.

to write a string on a console:
  if the console is nil, exit.
  insert the string into the console's text.
  insert the return byte into the console's text.
  wrap the console's text.
  scroll the console's text to the caret.
  show the console.

to write a string on a console without advancing:
  if the console is nil, exit.
  insert the string into the console's text.
  wrap the console's text.
  scroll the console's text to the caret.
  show the console.

to write a string to stdout:
  call "kernel32.dll" "WriteFile" with the stdout handle and the string's first and the string's length and a number's whereabouts and nil.

to write a string without advancing:
  write the string on the default console without advancing.

a wsadata is a record with
  a wyrd called wversion,
  a wyrd called whighversion,
  257 bytes called szdescription,
  127 bytes called szsystemstatus,
  a wyrd [unsigned] called imaxsockets,
  a wyrd [unsigned] called imaxudpdg,
  a pointer called lpvendorinfo.

a wyrd has a low byte and a high byte.

the x-key is a key equal to 88.

an xor-mask is a mask.

the y-key is a key equal to 89.

the yellow color is a color.

the yen-sign byte is a byte equal to 165.

to yield to windows:
  if the event queue is not empty, exit.
  call "user32.dll" "GetMessageA" with an msg's whereabouts and 0 and 0 and 0 returning a number.
  if the number is 0, exit.
  call "user32.dll" "TranslateMessage" with the msg's whereabouts.
  call "user32.dll" "DispatchMessageA" with the msg's whereabouts.

the z-key is a key equal to 90.

the zero box is a box.

the zero byte is a byte equal to 48.

to zero fill a number given a count and append it to a string:
  convert the number to another string.
  zero fill the other string given the count.
  append the other string to the string.

to zero fill a string given a count:
  if the string's length is greater than or equal to the count, exit.
  prepend the zero byte to the string.
  repeat.

the zero key is a key equal to 48.

the zero spot is a spot.

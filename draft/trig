\ Copyright 2017 by Jasper Paulsen.

to add a mixio to another mixio:
  privatize the mixio.
  normalize the mixio.
  normalize the other mixio.
  add the mixio's whole number to the other mixio's whole number.
  add the mixio's nips to the other mixio's nips.
  add the mixio's trifles to the other mixio's trifles.
  normalize the other mixio.

to add a mixio to another mixio returning a mixio called result:
  privatize the other mixio.
  add the mixio to the other mixio.
  put the other mixio in the result.

to add a number to a mixio:
  normalize the mixio.
  add the number to the mixio's whole number.
  normalize the mixio.

to add tau to some radians:
  get tau returning some other radians.
  add the other radians to the radians.

to add some trifles to a mixio:
  add the trifles to the mixio's trifles.
  normalize the mixio.

to convert a mixio to a ratio:
  privatize the mixio.
  normalize the mixio.
  put the mixio's trifles in the ratio.
  reduce the ratio.
  put the mixio's nips / the trifle root in another ratio.
  add the other ratio to the ratio.
  reduce the ratio.
  add the mixio's whole number to the ratio.
  reduce the ratio.

to convert a mixio to a string:
  if the mixio is 0,
    put "0" in the string; exit.
  put "" in the string.
  privatize the mixio.
  normalize the mixio.
  if the mixio's whole number is -1,
    subtract the trifle root from the mixio's nips;
    put 0 in the mixio's whole number.
  if the mixio's whole number is negative,
    negate the mixio;
    normalize the mixio;
    put "-" into the string.
  if the mixio's whole number is positive,
    append the mixio's whole number to the string.
  put the mixio's nips in a number.
  multiply the number by the trifle root.
  add the mixio's trifles to the number.
  if the number is 0, exit.
  put the number / the trifle denominator in a ratio.
  reduce the ratio.
  if the mixio's whole number is not 0,
    append the dash byte to the string.
  append the ratio's numerator then "/" then the ratio's denominator
    to the string.

to convert a mixio to a string (long):
  privatize the mixio.
  put the mixio's whole number in the string.
  if the mixio's nips are negative,
    negate the mixio's nips;
    append " - " then the mixio's nips
      then "/" then the trifle root to the string;
    negate the mixio's nips.
  if the mixio's nips are positive,
    append " + " then the mixio's nips
      then "/" then the trifle root to the string.
  if the mixio's trifles are negative,
    negate the mixio's trifles;
    append " - " then the mixio's trifles
      then "/" then the trifle denominator to the string;
    negate the mixio's trifles.
  if the mixio's trifles are positive,
    append " + " then the mixio's trifles
      then "/" then the trifle denominator to the string.

to convert a number to a mixio:
  put the number in the mixio.

to convert a precise angle to a mixio:
  put the precise angle's degrees in the mixio's whole number.
  put 60 times the precise angle's minutes in a number.
  multiply the number by 60.
  add the precise angle's seconds to the number.
  multiply the number by 100.
  add the precise angle's hundredths to the number.
  scale the number by the trifle denominator / 360000.
  put the number in the mixio's trifles.
  normalize the mixio.

to convert a precise angle to some radians:
  put the precise angle's degrees in a mixio's whole number.
  put the precise angle's minutes in the mixio's nips.
  multiply the mixio's nips by the trifle root / 60.
  put the precise angle's seconds in the mixio's trifles.
  multiply the mixio's trifles by the trifle denominator / 3600.
  put the precise angle's hundredths in a number.
  multiply the number by the trifle denominator / 360000.
  add the number to the mixio's trifles.
  normalize the mixio.
  divide the mixio by 10.
  put tau in some tau radians.
  multiply the mixio by the tau radians.
  divide the mixio by 36.
  put the mixio in the radians.

to convert a precise angle to a string:
  put the precise angle's degrees
    then the degree-symbol byte in the string.
  if the precise angle is just degrees, exit.
  append the precise angle's minutes
    then the minute-symbol byte to the string.
  if the precise angle is just degrees and minutes, exit.
  if the precise angle's hundredths are 0,
    append the precise angle's seconds
      then the second-symbol byte to the string;
    exit.
  if the precise angle's hundredths are negative,
    append the precise angle's seconds
      then the second-symbol byte
      then the precise angle's hundredths
      then "cas" to the string;
    exit.
  if the precise angle's hundredths are at least 100,
    append the precise angle's seconds
      then the second-symbol byte
      then the precise angle's hundredths
      then "cas" to the string;
    exit.
  if the precise angle's hundredths are less than 10,
    append the precise angle's seconds
      then ".0" then the precise angle's hundredths
      then the second-symbol byte to the string;
    exit.
    append the precise angle's seconds
      then the period byte
      then the precise angle's hundredths
      then the second-symbol byte to the string.

to convert some radians to a mixio:
  put the radians in the mixio.

to convert some radians to a precise angle:
  put the radians in a mixio.
  multiply the mixio by 6.
  put tau in some tau radians.
  divide the mixio by the tau radians.
  multiply the mixio by 60.
  normalize the mixio.
  put the mixio's whole number in the precise angle's degrees.
  put 0 in the mixio's whole number.
  multiply the mixio by 60.
  normalize the mixio.
  put the mixio's whole number in the precise angle's minutes.
  put 0 in the mixio's whole number.
  multiply the mixio by 60.
  normalize the mixio.
  put the mixio's whole number in the precise angle's seconds.
  put 0 in the mixio's whole number.
  multiply the mixio by 100.
  normalize the mixio.
  put the mixio's whole number in the precise angle's hundredths.
  put the trifle root in a number called threshold.
  divide the threshold by 2.
  if the mixio's nips are at least the threshold,
    add 1 to the precise angle's hundredths.
  subtract the trifle root from the threshold.
  if the mixio's nips are less than the threshold,
    subtract 1 from the precise angle's hundredths.

to convert a ratio to a mixio:
  privatize the ratio.
  if the ratio is -1/2, set a flag.
  convert the ratio to a mixed.
  put the mixed's whole number in the mixio's whole number.
  if the mixed's ratio is negative,
    set a sign flag;
    de-sign the mixed's ratio.
  scale the mixed's ratio's numerator
    given the trifle denominator / the mixed's denominator.
  divide the mixed's ratio's numerator by the trifle root
    giving the mixio's nips and the mixio's trifles.
  if the sign flag is set,
    negate the mixio's nips;
    negate the mixio's trifles.
  normalize the mixio.

to convert a tangent to a flopped tangent:
  \ assumes the tangent is between 0 and 1.
  convert the tangent to a mixio.
  put the mixio in the flopped tangent.
  multiply the flopped tangent by -5.
  add 11 to the flopped tangent.
  multiply the flopped tangent by the mixio.
  divide the flopped tangent by 6.

a cosine is a ratio.

to debug a mixio:
  convert the mixio to a string.
  debug the string.

to debug a mixio (long):
  convert the mixio to a string (long).
  debug the string.

to debug a precise angle:
  convert the precise angle to a string.
  debug the string.

to debug a string and a mixio and another string and another mixio (long):
  convert the mixio to a string called description (long).
  convert the other mixio to a string called other description (long).
  debug the string then the description then the other string then the other description.

to decide if a mixio is another mixio:
  privatize the mixio.
  privatize the other mixio.
  normalize the mixio.
  normalize the other mixio.
  if the mixio's whole number is not the other mixio's whole number, say no.
  if the mixio's nips are not the other mixio's nips, say no.
  if the mixio's trifles are not the other mixio's trifles, say no.
  say yes.

to decide if a mixio is at least another mixio:
  if the mixio is less than the other mixio, say no.
  say yes.

to decide if a mixio is at least a number:
  put the number in another mixio.
  if the mixio is less than the other mixio, say no.
  say yes.

to decide if a mixio is at least a ratio:
  convert the ratio to another mixio.
  if the mixio is at least the other mixio, say yes.
  say no.

to decide if a mixio is at most another mixio:
  if the mixio is greater than the other mixio, say no.
  say yes.

to decide if a mixio is at most a number:
  put the number in another mixio.
  if the mixio is greater than the other mixio, say no.
  say yes.

to decide if a mixio is greater than another mixio:
  privatize the mixio.
  privatize the other mixio.
  normalize the mixio.
  normalize the other mixio.
  if the mixio's whole number is greater than the other mixio's whole number, say yes.
  if the mixio's whole number is less    than the other mixio's whole number, say no.
  if the mixio's nips are greater than the other mixio's nips, say yes.
  if the mixio's nips are less    than the other mixio's nips, say no.
  if the mixio's trifles are greater than the other mixio's trifles, say yes.
  say no.

to decide if a mixio is less than another mixio:
  privatize the mixio.
  privatize the other mixio.
  normalize the mixio.
  normalize the other mixio.
  if the mixio's whole number is less than    the other mixio's whole number, say yes.
  if the mixio's whole number is greater than the other mixio's whole number, say no.
  if the mixio's nips are less    than the other mixio's nips, say yes.
  if the mixio's nips are greater than the other mixio's nips, say no.
  if the mixio's trifles are less than the other mixio's trifles, say yes.
  say no.

to decide if a mixio is modest given a number:
  privatize the mixio.
  normalize the mixio.
  if the mixio's whole number is at least the number,
    say no.
  if the mixio's whole number is positive, say yes.
  negate the mixio's whole number.
  if the mixio's whole number is more than the number,
    say no.
  if the mixio is the number, say no.
  say yes.

to decide if a mixio is negative:
  convert 0 to another mixio.
  if the mixio is less than the other mixio, say yes.
  say no.

to decide if a mixio is a number:
  privatize the mixio.
  normalize the mixio.
  if the mixio's whole number is not the number, say no.
  if the mixio's nips are not 0, say no.
  if the mixio's trifles are not 0, say no.
  say yes.

to decide if a number is wrapped given a number called alpha and a number called omega:
 privatize the alpha.
 privatize the omega.
 if the alpha is more than the omega,
   swap the alpha with the omega.
 if the number is less than the alpha, say no.
 if the number is more than the omega, say no.
 say yes.

to decide if a precise angle is another precise angle:
  if the precise angle's degrees are not the other precise angle's degrees, say no.
  if the precise angle's minutes are not the other precise angle's minutes, say no.
  if the precise angle's seconds are not the other precise angle's seconds, say no.
  if the precise angle's hundredths are not the other precise angle's hundredths, say no.
  say yes.

to decide if a precise angle is just degrees:
  if the precise angle's minutes are not 0, say no.
  if the precise angle's seconds are not 0, say no.
  if the precise angle's hundredths are not 0, say no.
  say yes.

to decide if a precise angle is just degrees and minutes:
  if the precise angle's seconds are not 0, say no.
  if the precise angle's hundredths are not 0, say no.
  say yes.

to decide if square root nips are close given a mixio and a mixio called result:
  privatize the result.
  add 1 to the result's nips.
  multiply the result by the result returning a mixio called bigger product.
  if the bigger product is less than the mixio, say no.
  subtract 2 from the result's nips.
  multiply the result by the result returning a mixio called smaller product.
  if the smaller product is greater than the mixio, say no.
  say yes.

to decide if square root trifles are close given a mixio and a mixio called result:
  privatize the result.
  add 1 to the result's trifles.
  multiply the result by the result returning a mixio called bigger product.
  if the bigger product is less than the mixio, say no.
  subtract 2 from the result's trifles.
  multiply the result by the result returning a mixio called smaller product.
  if the smaller product is greater than the mixio, say no.
  say yes.

to decide if square root trifles should be decreased given a mixio and a mixio called result:
  privatize the result.
  subtract 1 from the result's trifles.
  if square root trifles should be increased given the mixio and the result,
    say no.
  say yes.

to decide if square root trifles should be increased given a mixio and a mixio called result:
  privatize the result.
  multiply the result by the result returning a mixio called product.
  if the product is at least the mixio, say no.
  subtract the product from the mixio returning a mixio called shortage.
  add 1 to the result's trifles.
  multiply the result by the result returning the product.
  if the product is at most the mixio, say yes.
  subtract the mixio from the product returning a mixio called complement.
  if the shortage is less than the complement, say no.
  say yes.

to decide if a tangent is extreme:
  privatize the tangent.
  de-sign the tangent.
  if the tangent's denominator is 0, say yes.
  if the tangent's denominator is greater than 1, say no.
  if the tangent's numerator is the largest number, say yes.
  say no.

to divide a mixio by another mixio:
  divide the mixio by the other mixio returning a mixio called result.
  put the result in the mixio.

to divide a mixio by a mixio called divisor returning a mixio called result:
  privatize the mixio.
  privatize the divisor.
  put 0 in the result.
  normalize the mixio.
  normalize the result.
  if the divisor is 0,
    put the largest number in the result; exit.
  if the mixio is negative,
    set a sign flag;
    negate the mixio;
    normalize the mixio.
  if the divisor is negative,
    reverse the sign flag;
    negate the divisor;
    normalize the divisor.
  put the mixio in a mixio called temp.
  divide the temp by the trifle root.
  divide the temp by the divisor
    returning a number and a mixio called remainder mixio (loop).
  multiply the number by the trifle root.
  put the divisor in the temp.
  multiply the temp by the number.
  subtract the temp from the mixio.
  put the number in the result's whole number.
  divide the mixio by the divisor
    returning the number and the remainder mixio (loop).
  add the number to the result's whole number.
  put the remainder mixio in the mixio.
  multiply the mixio by the trifle root.
  divide the mixio by the divisor
    returning the number and the remainder mixio (loop).
  put the number in the result's nips.
  put the remainder mixio in the mixio.
  multiply the mixio by the trifle root.
  divide the mixio by the divisor
    returning the number and the remainder mixio (loop).
  put the number in the result's trifles.
  put the remainder mixio in the mixio.
  multiply the mixio by the trifle root.
  divide the mixio by the divisor
    returning the number and the remainder mixio (loop).
  divide the number by the trifle root
    giving a quotient and a remainder.
  add the quotient to the result's trifles.
  put the remainder in the number.
  put the trifle root in a number called threshold.
  divide the threshold by 2.
  if the number is at least the threshold,
    add 1 to the result's trifles.
  if the number is less than the threshold,
    subtract the trifle root from the threshold.
  if the sign flag is set,
    negate the result.
  normalize the result.

to divide a mixio by a mixio called divisor returning a number called quotient and a mixio called remnant:
  if the divisor is 0,
    put the largest number in the quotient;
    put 0 in the remnant;
    exit.
  privatize the mixio.
  privatize the divisor.
  put the mixio in the remnant.
  normalize the remnant.
  put the divisor in another mixio.
  normalize the other mixio.
  if the mixio is negative,
    set a sign flag;
    negate the mixio.
  if the divisor is negative,
    reverse the sign flag;
    negate the divisor.
  normalize the mixio.
  normalize the divisor.
  if the mixio is less than the divisor,
    put 0 in the quotient; break.
  if the mixio is the divisor,
    put 1 in the quotient; break.
  if the divisor's whole number is not 0,
    divide the mixio's whole number by the divisor's whole number
      giving the quotient and a remainder;
    break.
  \ to get here, the divisor's whole number is 0.
  multiply the divisor by the trifle root.
  put 1 in a count.
  if the divisor's whole number is 0,
    multiply the divisor by the trifle root;
    add 1 to the count.
  if the mixio's whole number is at least the trifle root,
    divide the mixio's whole number by the divisor's whole number
      giving the quotient and the remainder;
    break.
  multiply the mixio's whole number by the trifle root.
  subtract 1 from the count.
  if the mixio's whole number is at least the trifle root,
    divide the mixio's whole number by the divisor's whole number
      giving the quotient and the remainder;
    break.
  multiply the mixio's whole number by the trifle root.
  subtract 1 from the count.
  divide the mixio's whole number by the divisor's whole number
    giving the quotient and the remainder.
  break.
  repeat. \ a go-to label.
  if the count is 2,
    multiply the quotient by the trifle root;
    multiply the quotient by the trifle root;
    put 0 in the count.
  if the count is 1,
    multiply the quotient by the trifle root;
    put 0 in the count.
  if the sign flag is set,
    negate the quotient.
  multiply the other mixio by the quotient.
  normalize the other mixio.
  subtract the other mixio from the remnant.
  normalize the remnant.

to divide a mixio by a mixio called divisor returning a number called quotient and a mixio called remnant (loop):
  privatize the mixio.
  put 0 in the quotient.
  get modesty threshold given the divisor returning a number called threshold.
  loop.
    divide the mixio by the divisor
      returning a number and the remnant.
    add the number to the quotient.
    if the remnant is modest given the threshold, exit.
    put the remnant in the mixio.
  repeat.

to divide a mixio by a number:
  divide the mixio by the number returning another mixio.
  put the other mixio in the mixio.

to divide a mixio by a number returning another mixio:
  if the number is 0,
    put the largest number in the mixio; exit.
  put the number in another number.
  de-sign the other number.
  if the other number is at most the trifle root,
    divide the mixio by the number
      returning the other mixio (modest divisor);
    exit.
  get a gcd given the number and the trifle root.
  if the gcd is at most 1,
    divide the mixio by the number
      returning the other mixio (large divisor);
    exit.
  divide the mixio by the gcd
    returning a mixio called temp (modest divisor).
  put the number in a number called remnant.
  divide the remnant by the gcd.
  divide the temp by the remnant returning the other mixio.

to divide a mixio by a number returning another mixio (large divisor):
  if the number is 0,
    put the largest number in the mixio; exit.
  privatize the mixio.
  normalize the mixio.
  divide the mixio's whole number by the number
    giving a quotient and a remainder.
  put the quotient in the other mixio's whole number.
  put the remainder in another number.
  multiply the other number by the trifle root / the number.
  put the other number in the other mixio's nips.
  \ the other mixio's nips have been rounded to the nearest nip.
  normalize the other mixio.
  divide the mixio's nips by the number
    giving the quotient and the remainder.
  add the quotient to the other mixio's nips.
  put the remainder in the other number.
  multiply the other number by the trifle root / the number.
  put the other number in the other mixio's trifles.
  normalize the other mixio.
  divide the mixio's trifles by the number
    giving the quotient and the remainder.
  add the quotient to the other mixio's trifles.
  put the remainder in the other number.
  multiply the other number by the trifle root / the number.
  divide the other number by the trifle root
    giving the quotient and the remainder.
  add the quotient to the other mixio's trifles.
  put the trifle root in a number called threshold.
  divide the threshold by 2.
  if the other number is at least the threshold,
    add 1 to the other mixio's trifles.
  subtract the trifle root from the threshold.
  if the other number is less than the threshold,
    subtract 1 from the other mixio's trifles.
  normalize the other mixio.

to divide a mixio by a number returning another mixio (modest divisor):
  if the number is 0,
    put the largest number in the mixio; exit.
  privatize the mixio.
  normalize the mixio.
  divide the mixio's whole number by the number
    giving a quotient and a remainder.
  put the quotient in the other mixio's whole number.
  put the remainder in another number.
  multiply the other number by the trifle root.
  add the mixio's nips to the other number.
  divide the other number by the number
    giving the quotient and the remainder.
  put the quotient in the other mixio's nips.
  put the remainder in the other number.
  multiply the other number by the trifle root.
  add the mixio's trifles to the other number.
  divide the other number by the number
    giving the quotient and the remainder.
  put the quotient in the other mixio's trifles.
  put the remainder in the other number.
  multiply the other number by the trifle root.
  divide the other number by the number
    giving the quotient and the remainder.
  put the quotient in the other number.
  put the trifle root in a number called threshold.
  divide the threshold by 2.
  if the other number is at least the threshold,
    add 1 to the other mixio's trifles.
  subtract the trifle root from the threshold.
  if the other number is less than the threshold,
    subtract 1 from the other mixio's trifles.
  normalize the other mixio.

a flopped tangent is a mixio.

to get modesty threshold given a mixio called divisor returning a number:
  put the divisor's whole number in the number.
  de-sign the number.
  if the number is less than the trifle root,
    put the trifle root in the number.

to get a precise angle given a cosine:
  get some radians given the cosine.
  convert the radians to the precise angle.

to get a precise angle given a sine:
  get some radians given the sine.
  convert the radians to the precise angle.

to get a precise angle given a tangent:
  get some radians given the tangent.
  convert the radians to the precise angle.

to get some radians given a cosine:
  put the cosine in a ratio.
  put the ratio in a sine.
  get the radians given the sine.
  negate the radians.
  put half pi in some other radians.
  add the other radians to the radians.
  normalize the radians.

to get some radians given a flopped tangent called goal mixio:
  \ the radians are x.  Assume 0 <= x <= pi / 4.
  if the goal mixio is at most 0,
    put 0 in the radians; exit.
  put tau in some radians called guess radians.
  divide the guess radians by 8.
  \ Use Newton's method, in a region where y(x)
  \ is monotonically increasing and concave downward.
  \ Thus, the point (low x, low y) never moves from (0, 0),
  \ and the point (high x, high y) is the guess.
  put 1 in a mixio called guess mixio.
  loop.
    if the goal mixio is at least the guess mixio,
      put the guess radians in the radians; exit.
    divide the guess radians by the guess mixio
      returning a mixio called next factor.
    put the guess radians in some radians called previous radians.
    multiply the goal mixio by the next factor
      returning the guess radians.
    put the guess radians' tangent in a tangent.
    convert the tangent to a flopped tangent.
    if the flopped tangent is the guess mixio,
      put the guess radians in the radians; exit.
    if the flopped tangent is less than the goal mixio,
      strictly interpolate the radians from the goal mixio
        between the previous radians and the guess radians
        from between the guess mixio and the flopped tangent;
      exit.
    put the flopped tangent in the guess mixio.
  repeat.

to get some radians given a sine:
  privatize the sine.
  if the sine is negative,
    set a sign flag;
    negate the sine.
  if the sine is not positive,
    convert 0 to the radians; exit.
  \ Use Newton's method, in a region where sin(angle)
  \ is monotonically increasing and concave downward.  Thus,
  \ the point (low radians, low sine) never moves from (0, 0),
  \ and the point (high radians, high sine) is the guess.
  convert the sine to a mixio called goal mixio.
  put half pi in some radians called guess radians.
  put 1 in a mixio called guess mixio.
  loop.
    if the goal mixio is at least the guess mixio,
      convert the guess radians to the radians;
      negate the radians given the sign flag;
      normalize the radians;
      exit.
    divide the guess radians by the guess mixio
      returning a mixio called next factor.
    put the guess radians in some radians called previous radians.
    multiply the goal mixio by the next factor
      returning the guess radians.
    put the guess radians' sine in another sine.
    convert the other sine to a mixio.
    if the mixio is the guess mixio,
      convert the guess radians to the radians;
      negate the radians given the sign flag;
      normalize the radians;
      exit.
    if the mixio is less than the goal mixio,
      strictly interpolate the radians from the goal mixio
        between the previous radians and the guess radians
        from between the guess mixio and the mixio;
      normalize the radians;
      exit.
    put the mixio in the guess mixio.
  repeat.
  normalize the radians.

to get some radians given a tangent:
  put half pi in some radians called bogus radians.
  if the tangent is extreme,
    put the bogus radians in the radians; exit.
  privatize the tangent.
  if the tangent is negative,
    set a sign flag;
    negate the tangent.
  if the tangent is not positive,
    convert 0 to the radians; exit.
  if the tangent is greater than 1 / 1,
    set an invert flag;
    flip the tangent.
  convert the tangent to a flopped tangent.
  \ The search region is 0 <= x <= pi/4,
  \ where x = pi/4 - angle, y = 1 - tangent(x)
  get the radians given the flopped tangent.
  if the invert flag is set,
    negate the radians;
    add the bogus radians to the radians.
  if the sign flag is set,
    negate the radians.
  normalize the radians.

to get square root nips given a mixio and a mixio called result:
  \ assumes that the result is already within 1 of correct answer.
  if the mixio's whole number is the largest number,
    put 41040 in the result's nips; exit.
  loop.
    if square root nips are close given the mixio and the result,
      exit.
    refine square root nips given the mixio and the result.
  repeat.

to get square root trifles given a mixio and a mixio called result:
  if the mixio's whole number is the largest number,
    put 1007 in the result's trifles;
    put the mixio's nips in a number called bonus nips;
    divide the bonus nips by 2;
    scale the bonus nips by the trifle root / the largest square root;
    add the bonus nips to the result's trifles;
    exit.
  \ assumes that the result is already within 2 nips of correct answer.
  loop.
    if square root trifles are close given the mixio and the result,
      exit.
    refine square root trifles given the mixio and the result.
  repeat.

to get tau returning some radians:
  put tau in the radians.

to make a mixio given a number and a number called nips and some trifles:
  put the number in the mixio's whole number.
  put the nips in the mixio's nips.
  put the trifles in the mixio's trifles.

to make a precise angle given a number called degrees:
  make the precise angle with the degrees and 0 and 0 and 0.

to make a precise angle given a number called degrees and a number called minutes and a number called seconds and a number called hundredths:
  put the degrees in the precise angle's degrees.
  put the minutes in the precise angle's minutes.
  put the seconds in the precise angle's seconds.
  put the hundredths in the precise angle's hundredths.

a mixio has
  a whole number,
  a number called nips, and  \ implied denominator = trifle root
  some trifles.              \ implied denominator = trifle denominator

to multiply a mixio by another mixio:
  multiply the mixio by the other mixio returning a mixio called result.
  put the result in the mixio.

to multiply a mixio by another mixio returning a mixio called result:
  privatize the mixio.
  privatize the other mixio.
  normalize the mixio.
  normalize the other mixio.
  put the other mixio in the result.
  multiply the result by the mixio's whole number.
  normalize the result.
  put the other mixio in a mixio called nippy.
  put the nippy's nips in the nippy's trifles.
  divide the nippy's whole number by the trifle root
    giving a quotient and a remainder.
  put the quotient in the nippy's whole number.
  put the remainder in the nippy's nips.
  multiply the nippy by the mixio's nips.
  normalize the nippy.
  add the nippy to the result.
  make a mixio called trifly with 0 and 0 and the other mixio's whole number.
  normalize the trifly.
  multiply the trifly by the mixio's trifles.
  add the trifly to the result.
  make a mixio called scrappy
    given 0 and the mixio's nips and the mixio's trifles.
  multiply the scrappy by the other mixio's trifles.
  normalize the scrappy.
  put the mixio's trifles in a number.
  multiply the number by the other mixio's nips.
  add the number to the scrappy's nips.
  normalize the scrappy.
  divide the scrappy by the trifle root.
  divide the scrappy by the trifle root.
  add the scrappy to the result.
  normalize the result.

to multiply a mixio by a number:
  multiply the mixio by the number returning a mixio called result.
  put the result in the mixio.

to multiply a mixio by a number returning another mixio:
  privatize the mixio.
  normalize the mixio.
  multiply the mixio's whole number by the number.
  divide the number by the trifle root
    giving a quotient and a remainder.
  put the mixio's nips in a number called nips.
  multiply the nips by the quotient.
  add the nips to the mixio's whole number.
  multiply the mixio's nips by the remainder.
  put the mixio's trifles in a number called trifles.
  multiply the trifles by the quotient.
  add the trifles to the mixio's nips.
  multiply the mixio's trifles by the remainder.
  normalize the mixio.
  put the mixio in the other mixio.

to negate a mixio:
  normalize the mixio.
  negate the mixio's whole number.
  negate the mixio's nips.
  negate the mixio's trifles.
  normalize the mixio.

to negate a mixio given a flag:
  if the flag is set, negate the mixio.

to negate a ratio given a flag:
  if the flag is set, negate the ratio.

to normalize a mixio:
  put the trifle root in a number.
  subtract 1 from the number.
  wrap the mixio's trifles
    given 0 and the number and the mixio's nips.
  wrap the mixio's nips
    given 0 and the number and the mixio's whole number.

to normalize a precise angle:
  wrap the precise angle's degrees    given 0 and 359.
  wrap the precise angle's minutes    given 0 and  59 and the precise angle's degrees.
  wrap the precise angle's seconds    given 0 and  59 and the precise angle's minutes.
  wrap the precise angle's hundredths given 0 and  99 and the precise angle's seconds.
  wrap the precise angle's seconds    given 0 and  59 and the precise angle's minutes.
  wrap the precise angle's minutes    given 0 and  59 and the precise angle's degrees.
  wrap the precise angle's degrees    given 0 and 359.

to normalize some radians:
  if the radians are negative, 
    normalize the radians (negative); exit.
  normalize the radians (positive).

to normalize some radians (negative):
  negate the radians.
  normalize the radians (positive).
  negate the radians.
  if the radians are not negative, exit.
  add tau to the radians.

to normalize some radians (positive):
  put tau into some radians called tau radians.
  loop.
    if the radians are less than the tau radians, 
      exit.
    if the radians's whole number is 6,
      subtract the tau radians from the radians;
      exit.
    divide the radians's whole number by 7 giving a quotient and a remainder.
    multiply the quotient by 7 returning a number.
    multiply the tau radians by the quotient returning some other radians.
    subtract the other radians from the radians.
  repeat.

a precise angle has             \ normalized ranges
  a number called degrees,      \   0° - 359°
  a number called minutes,      \   0’ -  59’
  a number called seconds, and  \   0” -  59”
  a number called hundredths.   \   0  -  99 cas

to put half pi into some radians:
  put tau into the radians.
  divide the radians by 4.

to put a mixio in another mixio:
  put the mixio's whole number in the other mixio's whole number.
  put the mixio's nips in the other mixio's nips.
  put the mixio's trifles in the other mixio's trifles.

to put a mixio in a string:
  convert the mixio to the string.

to put a mixio's square root into a mixio called result:
  \ Finds magnitude of the square root.
  privatize the mixio.
  put 0 in the result.
  if the mixio is 0, exit.
  if the mixio is negative,
    negate the mixio.  \ similar to cal-4700's behavior.
  if the mixio is 1,
    put 1 into the result; exit.
  normalize the mixio.
  put the square root of the mixio's whole number in the result's whole number.
  put the result's whole number times the result's whole number in a number.
  if the mixio is the number, exit.
  get square root nips given the mixio and the result.
  get square root trifles given the mixio and the result.
  if square root trifles should be increased given the mixio and the result,
    add 1 to the result's trifles;
    normalize the result;
    exit.
  if square root trifles should be decreased given the mixio and the result,
    subtract 1 from the result's trifles.
  normalize the result.

to put a number in a mixio:
  put the number in the mixio's whole number.
  put 0 in the mixio's nips.
  put 0 in the mixio's trifles.

to put pi into some radians:
  put tau into the radians.
  divide the radians by 2.

to put a precise angle into another precise angle:
  put the precise angle's degrees into the other precise angle's degrees.
  put the precise angle's minutes into the other precise angle's minutes.
  put the precise angle's seconds into the other precise angle's seconds.
  put the precise angle's hundredths into the other precise angle's hundredths.

to put a precise angle's cosine into a cosine:
  convert the precise angle to some radians.
  put the radians' cosine into the cosine.

to put a precise angle's sine into a sine:
  convert the precise angle to some radians.
  put the radians' sine into the sine.

to put a precise angle's tangent into a tangent:
  privatize the precise angle.
  normalize the precise angle.
  make a precise angle called up angle given 90.
  make a precise angle called down angle given 270.
  if the precise angle is the up angle,
    put the largest number / 1 in the tangent; exit.
  if the precise angle is the down angle,
    put the largest number / 1 in the tangent; exit.
  put the precise angle's sine into a sine.
  put the precise angle's cosine into a cosine.
  put the sine's numerator in the tangent's numerator.
  multiply the tangent's numerator
    by the trifle denominator / the sine's denominator.
  put the cosine's numerator in the tangent's denominator.
  multiply the tangent's denominator
    by the trifle denominator / the cosine's denominator.
  reduce the tangent.

to put some radians' cosine into a cosine:
  if the radians are 0,
    put 1 in the cosine; exit.
  privatize the radians.
  normalize the radians.
  put tau into some radians called tau.
  put pi into some radians called pi.
  if the radians are greater than the pi,
    subtract the tau from the radians;
    negate the radians.
  put half pi into some radians called half pi.
  if the radians are greater than the half pi,
    subtract the pi from the radians;
    set a sign flag;
    negate the radians.
  if the radians are at least 85 / 108, \ slightly more than pi / 4
    subtract the half pi from the radians;
    negate the radians;
    put the radians' sine into the cosine;
    negate the cosine given the sign flag;
    exit.
  put 1 in a mixio.
  multiply the radians by the radians returning a mixio called square mixio.
  put 0 in a count called power.
  loop.
    add the mixio to a mixio called result.
    if the power is at least 12, break.
    negate the mixio.
    multiply the mixio by the square mixio.
    add 1 to the power.
    put the power in a number.
    add 1 to the power.
    multiply the number by the power.
    divide the mixio by the number.
  repeat.
  convert the result to the cosine.
  negate the cosine given the sign flag.

to put some radians' sine into a sine:
  if the radians are 0,
    put 0 in the sine; exit.
  privatize the radians.
  normalize the radians.
  put tau into some radians called tau.
  put pi into some radians called pi.
  if the radians are greater than the pi,
    subtract the tau from the radians;
    negate the radians;
    set a sign flag.
  put half pi into some radians called half pi.
  if the radians are greater than the half pi,
    subtract the pi from the radians;
    negate the radians.
  if the radians are at least 85 / 108, \ slightly more than pi / 4
    subtract the half pi from the radians;
    negate the radians;
    put the radians' cosine into the sine;
    negate the sine given the sign flag;
    exit.
  put the radians in a mixio.
  multiply the mixio by the mixio returning a mixio called square mixio.
  put 1 in a count called power.
  loop.
    add the mixio to a mixio called result.
    if the power is at least 11, break.
    negate the mixio.
    multiply the mixio by the square mixio.
    add 1 to the power.
    put the power in a number.
    add 1 to the power.
    multiply the number by the power.
    divide the mixio by the number.
  repeat.
  convert the result to the sine.
  negate the sine given the sign flag.

to put some radians' tangent into a tangent:
  privatize the radians.
  normalize the radians.
  put tau in some radians called up angle.
  divide the up angle by 4.
  put the up angle in some radians called down angle.
  negate the down angle.
  normalize the down angle.
  if the radians are the up angle,
    put the largest number / 1 in the tangent; exit.
  if the radians are the down angle,
    put the largest number / 1 in the tangent; exit.
  put the radians' sine into a sine.
  put the radians' cosine into a cosine.
  put the sine's numerator in the tangent's numerator.
  multiply the tangent's numerator
    by the trifle denominator / the sine's denominator.
  put the cosine's numerator in the tangent's denominator.
  multiply the tangent's denominator
    by the trifle denominator / the cosine's denominator.
  reduce the tangent.

to put tau into some radians:
  put 6 into the radians' whole number.
  put 12233 into the radians' nips.
  put 26148 into the radians' trifles.

to put some trifles in a ratio:
  put the trifles / the trifle denominator in the ratio.

some radians are a mixio.

to refine square root nips given a mixio and a mixio called result:
  \ assumes that the result is already within 1 of correct answer.
  if the result's whole number is 0,
    put the mixio's nips in a number;
    multiply the number by the trifle root;
    add the mixio's trifles to the number;
    put the square root of the number in the result's nips;
    exit.
  privatize the mixio.
  multiply the result by the result returning a mixio called product.
  subtract the product from the mixio.
  divide the mixio by 2.
  put the result's whole number in the number.
  multiply the number by the trifle root.
  add the result's nips to the number.
  multiply the mixio by the trifle root.
  divide the mixio by the number.
  add the mixio to the result.

to refine square root trifles given a mixio and a mixio called result:
  \ assumes that the result is already within 2 nips of correct answer.
  if the result's whole number is 0, exit.
  privatize the mixio.
  multiply the result by the result returning a mixio called product.
  subtract the product from the mixio.
  divide the mixio by 2.
  divide the mixio by the result.
  add the mixio to the result.

a sine is a ratio.

to stash a fuzzy test given a ratio:
  convert the ratio to a mixio.
  stash the fuzzy test given the mixio.

to stash a test result using a precise angle:
  convert the precise angle to a string.
  stash the test result using the string.

to strictly interpolate some radians called goal radians from a mixio called goal mixio between some radians and some other radians from between a mixio and another mixio:
  put the other radians in some radians called delta radians.
  subtract the radians from the delta radians.
  put the other mixio in a mixio called delta mixio.
  subtract the mixio from the delta mixio.
  put the goal mixio in a mixio called partial mixio.
  subtract the mixio from the partial mixio.
  divide the partial mixio by the delta mixio.
  if the partial mixio is at most 0,
    put the radians in the goal radians; exit.
  if the partial mixio is at least 1,
    put the other radians in the goal radians; exit.
  multiply the delta radians by the partial mixio.
  put the radians in the goal radians.
  add the delta radians to the goal radians.

to subtract a mixio from another mixio:
  privatize the mixio.
  normalize the mixio.
  normalize the other mixio.
  convert the mixio to a string (long).
  convert the other mixio to another string (long).
  subtract the mixio's whole number from the other mixio's whole number.
  subtract the mixio's nips from the other mixio's nips.
  subtract the mixio's trifles from the other mixio's trifles.
  convert the other mixio to the other string (long).
  normalize the other mixio.

to subtract a mixio from another mixio returning a mixio called result:
  privatize the mixio.
  negate the mixio.
  add the mixio to the other mixio returning the result.

to subtract some trifles from a mixio:
  subtract the trifles from the mixio's trifles.
  normalize the mixio.

a tangent is a ratio.

to test (mixio square root of 0):
  create a test result about "trig"
    and "mixio square root of 0" and expecting "0".
  put 0 in a mixio.
  put the mixio's square root in another mixio.
  convert the other mixio to a string called actual.
  stash the test result given the actual.

to test (mixio square root of 1):
  create a test result about "trig"
    and "mixio square root of 1" and expecting "1".
  put 1 in a mixio.
  put the mixio's square root in another mixio.
  convert the other mixio to a string called actual.
  stash the test result given the actual.

to test (mixio square root of 100):
  create a test result about "trig"
    and "mixio square root of 100" and expecting "10".
  put 100 in a mixio.
  put the mixio's square root in another mixio.
  convert the other mixio to a string called actual.
  stash the test result given the actual.

to test (mixio square root of 1000000):
  create a test result about "trig"
    and "mixio square root of 1000000" and expecting "1000".
  put 1000000 in a mixio.
  put the mixio's square root in another mixio.
  convert the other mixio to a string called actual.
  stash the test result given the actual.

to test (mixio square root of 1002000):
  make a fuzzy test about "trig"
    and "mixio square root of 1002000"
    and targeting 2004001/2002 with tight tolerance.
  put 1002000 in a mixio.
  put the mixio's square root in a mixio called actual.
  stash the fuzzy test given the actual.

to test (mixio square root of 1002001):
  create a test result about "trig"
    and "mixio square root of 1002001" and expecting "1001".
  put 1002001 in a mixio.
  put the mixio's square root in another mixio.
  convert the other mixio to a string called actual.
  stash the test result given the actual.

to test (mixio square root of 121):
  create a test result about "trig"
    and "mixio square root of 121" and expecting "11".
  put 121 in a mixio.
  put the mixio's square root in another mixio.
  convert the other mixio to a string called actual.
  stash the test result given the actual.

to test (mixio square root of 1866240000):
  create a test result about "trig"
    and "mixio square root of 1866240000" and expecting "43200".
  put 1866240000 in a mixio.
  put the mixio's square root in another mixio.
  convert the other mixio to a string called actual.
  stash the test result given the actual.

to test (mixio square root of 2147395600):
  create a test result about "trig"
    and "mixio square root of 2147395600" and expecting "46340".
  put 2147395600 in a mixio.
  put the mixio's square root in another mixio.
  convert the other mixio to a string called actual.
  stash the test result given the actual.

to test (mixio square root of 2147483647):
  make a fuzzy test about "trig"
    and "mixio square root of 2147483647"
    and targeting 926819/20 with tolerance 21600 trifles.
  put 2147483647 in a mixio.
  put the mixio's square root in a mixio called actual.
  stash the fuzzy test given the actual.

to test (mixio square root of 3):
  make a fuzzy test about "trig"
    and "mixio square root of 3"
    and targeting 1292969/746496 with tight tolerance.
  put 3 in a mixio.
  put the mixio's square root in a mixio called actual.
  stash the fuzzy test given the actual.

to test (mixio square root of 81):
  create a test result about "trig"
    and "mixio square root of 81" and expecting "9".
  put 81 in a mixio.
  put the mixio's square root in another mixio.
  convert the other mixio to a string called actual.
  stash the test result given the actual.

to test (mixio square root of 99):
  make a fuzzy test about "trig"
    and "mixio square root of 99"
    and targeting 41264119/4147200 with tolerance 5 trifles.
  put 99 in a mixio.
  put the mixio's square root in a mixio called actual.
  stash the fuzzy test given the actual.

to test (mixio square root of 999999):
  make a fuzzy test about "trig"
    and "mixio square root of 999999"
    and targeting 1999999/2000 with tight tolerance.
  put 999999 in a mixio.
  put the mixio's square root in a mixio called actual.
  stash the fuzzy test given the actual.

to test (mixio square root):
  test (mixio square root of 0).
  test (mixio square root of 1).
  test (mixio square root of 3).
  test (mixio square root of 81).
  test (mixio square root of 99).
  test (mixio square root of 100).
  test (mixio square root of 121).
  test (mixio square root of 999999).
  test (mixio square root of 1000000).
  test (mixio square root of 1002000).
  test (mixio square root of 1002001).
  test (mixio square root of 1866240000).
  test (mixio square root of 2147395600).
  test (mixio square root of 2147483647).

to test (trig - -1 is not wrapped between 0 and 99):
  create a test result about "trig"
    and "-1 is not wrapped between 0 and 99"
    and expecting "unwrapped".
  put "unwrapped" in a string called actual.
  if -1 is wrapped given 0 and 99,
    put "wrapped" in the actual.
  stash the test result using the actual.

to test (trig - arccosine of -1):
  put pi in some radians.
  make a fuzzy test about "trig" and "arccosine of -1" 
    and targeting the radians with tight tolerance.
  put -1 in a cosine.
  get some radians called actual given the cosine.
  stash the fuzzy test given the actual.

to test (trig - arccosine of 0):
  put half pi in some radians.
  make a fuzzy test about "trig" and "arccosine of 0" 
    and targeting the radians with tight tolerance.
  put 0 in a cosine.
  get some radians called actual given the cosine.
  stash the fuzzy test given the actual.

to test (trig - arccosine of 1):
  put 0 in some radians.
  make a fuzzy test about "trig" and "arccosine of 1" 
    and targeting the radians with tight tolerance.
  put 1 in a cosine.
  get some radians called actual given the cosine.
  stash the fuzzy test given the actual.

to test (trig - arccosine of 1/2):
  put tau in some radians.
  divide the radians by 6.
  make a fuzzy test about "trig" and "arccosine of 1/2" 
    and targeting the radians with tight tolerance.
  put 1/2 in a cosine.
  get some radians called actual given the cosine.
  stash the fuzzy test given the actual.

to test (trig - arccosine):
  test (trig - arccosine of 0).
  test (trig - arccosine of 1/2).
  test (trig - arccosine of 1).
  test (trig - arccosine of -1).

to test (trig - arcsine of -1):
  put tau in some radians.
  divide the radians by 4.
  negate the radians.
  normalize the radians.
  make a fuzzy test about "trig" and "arcsine of -1" 
    and targeting the radians with tight tolerance.
  put -1/1 in a sine.
  get some radians called actual given the sine.
  stash the fuzzy test given the actual.

to test (trig - arcsine of 0):
  put 0 in some radians.
  make a fuzzy test about "trig" and "arcsine of 0" 
    and targeting the radians with tight tolerance.
  put 0 in a sine.
  get some radians called actual given the sine.
  stash the fuzzy test given the actual.

to test (trig - arcsine of 1):
  put tau in some radians.
  divide the radians by 4.
  make a fuzzy test about "trig" and "arcsine of 1" 
    and targeting the radians with tight tolerance.
  put 1/1 in a sine.
  get some radians called actual given the sine.
  stash the fuzzy test given the actual.

to test (trig - arcsine of 1/2):
  put tau in some radians.
  divide the radians by 12.
  make a fuzzy test about "trig" and "arcsine of 1/2" 
    and targeting the radians with tight tolerance.
  put 1/2 in a sine.
  get some radians called actual given the sine.
  stash the fuzzy test given the actual.

to test (trig - arcsine):
  test (trig - arcsine of 0).
  test (trig - arcsine of 1/2).
  test (trig - arcsine of 1).
  test (trig - arcsine of -1).

to test (trig - arctangent of -1):
  put tau in some radians.
  divide the radians by 8.
  negate the radians.
  normalize the radians.
  make a fuzzy test about "trig" and "arctangent of -1" 
    and targeting the radians with tight tolerance.
  put -1 in a tangent.
  get some radians called actual given the tangent.
  stash the fuzzy test given the actual.

to test (trig - arctangent of -1/5):
  create a test result about "trig" and "arctangent of -1/5" 
    and expecting "348°41’24.24”".
  put -1/5 in a tangent.
  get a precise angle given the tangent.
  convert the precise angle to a string called actual.
  stash the test result given the actual.

to test (trig - arctangent of -14):
  create a test result about "trig" and "arctangent of -14" 
    and expecting "274°5’8.22”".
  put -14 in a tangent.
  get a precise angle given the tangent.
  convert the precise angle to a string called actual.
  stash the test result given the actual.

to test (trig - arctangent of 0):
  put 0 in some radians.
  make a fuzzy test about "trig" and "arctangent of 0" 
    and targeting the radians with tight tolerance.
  put 0 in a tangent.
  get some radians called actual given the tangent.
  stash the fuzzy test given the actual.

to test (trig - arctangent of 1):
  put tau in some radians.
  divide the radians by 8.
  make a fuzzy test about "trig" and "arctangent of 1" 
    and targeting the radians with tight tolerance.
  put 1 in a tangent.
  get some radians called actual given the tangent.
  stash the fuzzy test given the actual.

to test (trig - arctangent of 1/12):
  create a test result about "trig" and "arctangent of 1/12" 
    and expecting "4°45’49.11”".
  put 1/12 in a tangent.
  get a precise angle given the tangent.
  convert the precise angle to a string called actual.
  stash the test result given the actual.

to test (trig - arctangent of 12):
  create a test result about "trig" and "arctangent of 12" 
    and expecting "85°14’10.89”".
  put 12 in a tangent.
  get a precise angle given the tangent.
  convert the precise angle to a string called actual.
  stash the test result given the actual.

to test (trig - arctangent of 3/4):
  create a test result about "trig" and "arctangent of 3/4" 
    and expecting "36°52’11.63”".
  put 3/4 in a tangent.
  get a precise angle given the tangent.
  convert the precise angle to a string called actual.
  stash the test result given the actual.

to test (trig - arctangent of 4/3):
  create a test result about "trig" and "arctangent of 4/3" 
    and expecting "53°7’48.37”".
  put 4/3 in a tangent.
  get a precise angle given the tangent.
  convert the precise angle to a string called actual.
  stash the test result given the actual.

to test (trig - arctangent of largest number):
  put tau in some radians.
  divide the radians by 4.
  make a fuzzy test about "trig" and "arctangent of largest number" 
    and targeting the radians with tight tolerance.
  put the largest number in a tangent.
  get some radians called actual given the tangent.
  stash the fuzzy test given the actual.

to test (trig - arctangent):
  test (trig - arctangent of 0).
  test (trig - arctangent of 1).
  test (trig - arctangent of -1).
  test (trig - arctangent of -14).
  test (trig - arctangent of -1/5).
  test (trig - arctangent of 1/12).
  test (trig - arctangent of 3/4).
  test (trig - arctangent of 4/3).
  test (trig - arctangent of 12).
  test (trig - arctangent of largest number).

to test (trig - convert from 0 radians to 0°):
  make a fuzzy test about "trig" 
    and "convert from 0 radians to 0°" 
    and targeting 0/1 with tight tolerance.
  put 0 in some radians.
  convert the radians to a precise angle.
  convert the precise angle to a mixio.
  stash the fuzzy test given the mixio.

to test (trig - convert from 0° to 0 radians):
  make a fuzzy test about "trig" 
    and "convert from 0° to 0 radians" 
    and targeting 0/1 with tight tolerance.
  make a precise angle given 0.
  convert the precise angle to some radians called actual.
  stash the fuzzy test given the actual.

to test (trig - convert from 225° to radians):
  make a fuzzy test about "trig" 
    and "convert from 225° to radians" 
    and targeting 366435367/93312000 with tight tolerance.
  make a precise angle given 225.
  convert the precise angle to some radians called actual.
  stash the fuzzy test given the actual.

to test (trig - convert from 359°59’59.99” to radians):
  make a fuzzy test about "trig" 
    and "convert from 359°59’59.99” to radians" 
    and targeting 1954321943/311040000 with tight tolerance.
  make a precise angle given 359 and 59 and 59 and 99.
  convert the precise angle to some radians called actual.
  stash the fuzzy test given the actual.

to test (trig - convert from degrees to radians):
  test (trig - convert from 225° to radians).
  test (trig - convert from 0° to 0 radians).
  test (trig - convert from 359°59’59.99” to radians).

to test (trig - convert from pi radians to 180°):
  make a fuzzy test about "trig" 
    and "convert from pi radians to 180°" 
    and targeting 180/1 with tight tolerance.
  put tau in some radians.
  divide the radians by 2.
  convert the radians to a precise angle.
  convert the precise angle to a mixio.
  stash the fuzzy test given the mixio.

to test (trig - convert from radians to degrees):
  test (trig - convert from pi radians to 180°).
  test (trig - convert from 0 radians to 0°).

to test (trig - convert mixio to string):
  create a test result about "trig"
    and "convert mixio to string"
    and expecting "-100-221/432".
  make a mixio given -100 and -22100 and 0.
  normalize the mixio.
  convert the mixio to a string called actual.
  stash the test result using the actual.

to test (trig - cosine of -240°):
  make a fuzzy test about "trig" and "cosine of -240°" 
    and targeting -1/2 with tight tolerance.
  make a precise angle given -240.
  put the precise angle's cosine in a cosine called actual.
  stash the fuzzy test given the actual.

to test (trig - cosine of 0°):
  make a fuzzy test about "trig" and "cosine of 0°" 
    and targeting 1/1 with tight tolerance.
  make a precise angle given 0.
  put the precise angle's cosine in a cosine called actual.
  stash the fuzzy test given the actual.

to test (trig - cosine of 1/2 radian):
  make a fuzzy test about "trig" and "cosine of 1/2 radian" 
    and targeting 1137347/1296000 with tight tolerance.
  make a mixio given 0 and 21600 and 0.
  put the mixio in some radians.
  put the radians' cosine in a cosine called actual.
  stash the fuzzy test given the actual.

to test (trig - cosine of 30°):
  make a fuzzy test about "trig" and "cosine of 30°" 
    and targeting 1292969/1492992 with tight tolerance.
  make a precise angle given 30.
  put the precise angle's cosine in a cosine called actual.
  stash the fuzzy test given the actual.

to test (trig - cosine of 360°):
  make a fuzzy test about "trig" and "cosine of 360°" 
    and targeting 1/1 with tight tolerance.
  make a precise angle given 360.
  put the precise angle's cosine in a cosine called actual.
  stash the fuzzy test given the actual.

to test (trig - cosine of 41°15’):
  make a fuzzy test about "trig" and "cosine of 41°15’" 
    and targeting 1403113522/1866240000 with tight tolerance.
  make a precise angle given 41 and 15 and 0 and 0.
  put the precise angle's cosine in a cosine called actual.
  stash the fuzzy test given the actual.

to test (trig - cosine of 45°):
  make a fuzzy test about "trig" and "cosine of 45°" 
    and targeting 16495387/23328000 with tight tolerance.
  make a precise angle given 45.
  put the precise angle's cosine in a cosine called actual.
  stash the fuzzy test given the actual.

to test (trig - cosine of 90°):
  make a fuzzy test about "trig" and "cosine of 90°" 
    and targeting 0/1 with tight tolerance.
  make a precise angle given 90.
  put the precise angle's cosine in a cosine called actual.
  stash the fuzzy test given the actual.

to test (trig - cosine):
  test (trig - cosine of -240°).
  test (trig - cosine of 0°).
  test (trig - cosine of 1/2 radian).
  test (trig - cosine of 30°).
  test (trig - cosine of 41°15’).
  test (trig - cosine of 45°).
  test (trig - cosine of 90°).
  test (trig - cosine of 360°).

to test (trig - mixio / 388800):
  make a fuzzy test about "trig" and "mixio / 388800" 
    and targeting 1 / 1 with tight tolerance.
  put 388800 in a mixio called actual.
  divide the actual by 388800.
  stash the fuzzy test given the actual.

to test (trig - multiply mixios):
  create a test result about "trig"
    and "multiply mixios"
    and expecting "142 + 21600/43200 + 23/1866240000".
  make a mixio given 22 and 21600 and 0.
  make another mixio given 6 and 14400 and 1.
  multiply the mixio by the other mixio returning a mixio called result.
  convert the result to a string (long).
  stash the test result using the string.

to test (trig - normalize -123°-45’-6”-78cas to 236°14’53.22”):
  create a test result about "trig"
    and "normalize -123°-45’-6”-78cas to 236°14’53.22”"
    and expecting "236°14’53.22”".
  make a precise angle called actual with -123 and -45 and -6 and -78.
  normalize the actual.
  stash the test result using the actual.

to test (trig - normalize 0° to 0°):
  create a test result about "trig"
    and "normalize 0° to 0°"
    and expecting "0°".
  make a precise angle called actual with 0.
  normalize the actual.
  stash the test result using the actual.

to test (trig - normalize 0°0’0”-1cas to 359°59’59.99”):
  create a test result about "trig"
    and "normalize 0°0’0”-1cas to 359°59’59.99”"
    and expecting "359°59’59.99”".
  make a precise angle called actual with 0 and 0 and 0 and -1.
  normalize the actual.
  stash the test result using the actual.

to test (trig - normalize 360°60’60”100cas to 1°1’1”):
  create a test result about "trig"
    and "normalize 360°60’60”100cas to 1°1’1”"
    and expecting "1°1’1”".
  make a precise angle called actual with 360 and 60 and 60 and 100.
  normalize the actual.
  stash the test result using the actual.

to test (trig - normalize 432°10’54.32” to 72°10’54.32”):
  create a test result about "trig"
    and "normalize 432°10’54.32” to 72°10’54.32”"
    and expecting "72°10’54.32”".
  make a precise angle called actual with 72 and 10 and 54 and 32.
  normalize the actual.
  stash the test result using the actual.

to test (trig - normalize largest angle to 169°35’3.47”):
  create a test result about "trig"
    and "normalize largest angle to 169°35’3.47”"
    and expecting "169°35’3.47”".
  make a precise angle called actual with the largest number
    and the largest number and the largest number and the largest number.
  normalize the actual.
  stash the test result using the actual.

to test (trig - normalize precise angle):
  test (trig - normalize 360°60’60”100cas to 1°1’1”).
  test (trig - normalize 0° to 0°).
  test (trig - normalize 0°0’0”-1cas to 359°59’59.99”).
  test (trig - normalize largest angle to 169°35’3.47”).   \each place has largest number
  test (trig - normalize smallest angle to 189°23’55.52”). \each place has smallest number
  test (trig - normalize -123°-45’-6”-78cas to 236°14’53.22”).
  test (trig - normalize 432°10’54.32” to 72°10’54.32”).

to test (trig - normalize radians -84821 to about 2):
  make a fuzzy test about "trig" 
    and "normalize radians -84821 to 2" 
    and targeting 23059/11520 with tight tolerance.
  put -84821 in some radians called actual.
  normalize the actual.
  stash the fuzzy test given the actual.

to test (trig - normalize radians -84822 to about 1):
  make a fuzzy test about "trig" 
    and "normalize radians -84822 to 1" 
    and targeting 11539/11520 with tight tolerance.
  put -84822 in some radians called actual.
  normalize the actual.
  stash the fuzzy test given the actual.

to test (trig - normalize radians 0 to 0):
  make a fuzzy test about "trig" and "normalize radians 0 to 0" 
    and targeting 0/1 with tight tolerance.
  put 0 in some radians called actual.
  normalize the actual.
  stash the fuzzy test given the actual.

to test (trig - normalize radians 6 to 6):
  make a fuzzy test about "trig" 
    and "normalize radians 6 to 6" 
    and targeting 6/1 with tight tolerance.
  put 6 in some radians called actual.
  normalize the actual.
  stash the fuzzy test given the actual.

to test (trig - normalize radians 7):
  make a fuzzy test about "trig" 
    and "normalize radians 7" 
    and targeting 111479021/155520000 with tight tolerance.
  put 7 in some radians called actual.
  normalize the actual.
  stash the fuzzy test given the actual.

to test (trig - normalize radians 977160980 to 1):
  make a fuzzy test about "trig" 
    and "normalize radians 977160980 to 1" 
    and targeting 1/1 with tight tolerance.
  put 977160980 in some radians called actual.
  normalize the actual.
  stash the fuzzy test given the actual.

to test (trig - normalize radians):
  test (trig - normalize radians 0 to 0).
  test (trig - normalize radians 977160980 to 1).
  test (trig - normalize radians -84822 to about 1).
  test (trig - normalize radians -84821 to about 2).
  test (trig - normalize radians 6 to 6).
  test (trig - normalize radians 7).

to test (trig - normalize smallest angle to 189°23’55.52”):
  create a test result about "trig"
    and "normalize smallest angle to 189°23’55.52”"
    and expecting "189°23’55.52”".
  make a precise angle called actual with the smallest number
    and the smallest number and the smallest number and the smallest number.
  normalize the actual.
  stash the test result using the actual.

to test (trig - sine of -240°):
  make a fuzzy test about "trig" and "sine of -240°" 
    and targeting 1292969/1492992 with tight tolerance.
  make a precise angle given -240.
  put the precise angle's sine in a sine called actual.
  stash the fuzzy test given the actual.

to test (trig - sine of 0°):
  make a fuzzy test about "trig" and "sine of 0°" 
    and targeting 0/1 with tight tolerance.
  make a precise angle given 0.
  put the precise angle's sine in a sine called actual.
  stash the fuzzy test given the actual.

to test (trig - sine of 30°):
  make a fuzzy test about "trig" and "sine of 30°" 
    and targeting 1/2 with tight tolerance.
  make a precise angle given 30.
  put the precise angle's sine in a sine called actual.
  stash the fuzzy test given the actual.

to test (trig - sine of 360°):
  make a fuzzy test about "trig" and "sine of 360°" 
    and targeting 0/14400 with tight tolerance.
  make a precise angle given 360.
  put the precise angle's sine in a sine called actual.
  stash the fuzzy test given the actual.

to test (trig - sine of 41°15’):
  make a fuzzy test about "trig" and "sine of 41°15’" 
    and targeting 18457463/27993600 with tight tolerance.
  make a precise angle given 41 and 15 and 0 and 0.
  put the precise angle's sine in a sine called actual.
  stash the fuzzy test given the actual.

to test (trig - sine of 45°):
  make a fuzzy test about "trig" and "sine of 45°" 
    and targeting 16495387/23328000 with tight tolerance.
  make a precise angle given 45.
  put the precise angle's sine in a sine called actual.
  stash the fuzzy test given the actual.

to test (trig - sine of 90°):
  make a fuzzy test about "trig" and "sine of 90°" 
    and targeting 1/1 with tight tolerance.
  make a precise angle given 90.
  put the precise angle's sine in a sine called actual.
  stash the fuzzy test given the actual.

to test (trig - sine):
  test (trig - sine of -240°).
  test (trig - sine of 0°).
  test (trig - sine of 30°).
  test (trig - sine of 41°15’).
  test (trig - sine of 45°).
  test (trig - sine of 90°).
  test (trig - sine of 360°).

to test (trig - tangent of -240°):
  make a fuzzy test about "trig" and "tangent of -240°" 
    and targeting -1292969/746496 with tight tolerance.
  make a precise angle given -240.
  put the precise angle's tangent in a tangent called actual.
  stash the fuzzy test given the actual.

to test (trig - tangent of -90°):
  make a fuzzy test about "trig" and "tangent of -90°" 
    and targeting the largest number / 1 with tight tolerance.
  make a precise angle given 90.
  put the precise angle's tangent in a tangent called actual.
  stash the fuzzy test given the actual.

to test (trig - tangent of 0°):
  make a fuzzy test about "trig" and "tangent of 0°" 
    and targeting 0/1 with tight tolerance.
  make a precise angle given 0.
  put the precise angle's tangent in a tangent called actual.
  stash the fuzzy test given the actual.

to test (trig - tangent of 30°):
  make a fuzzy test about "trig" and "tangent of 30°" 
    and targeting 14964919/25920000 with tight tolerance.
  make a precise angle given 30.
  put the precise angle's tangent in a tangent called actual.
  stash the fuzzy test given the actual.

to test (trig - tangent of 360°):
  make a fuzzy test about "trig" and "tangent of 360°" 
    and targeting 0/1 with tight tolerance.
  make a precise angle given 360.
  put the precise angle's tangent in a tangent called actual.
  stash the fuzzy test given the actual.

to test (trig - tangent of 41°15’):
  make a fuzzy test about "trig" and "tangent of 41°15’" 
    and targeting 272774759/311040000 with tight tolerance.
  make a precise angle given 41 and 15 and 0 and 0.
  put the precise angle's tangent in a tangent called actual.
  stash the fuzzy test given the actual.

to test (trig - tangent of 45°):
  make a fuzzy test about "trig" and "sine of 45°" 
    and targeting 1/1 with tight tolerance.
  make a precise angle given 45.
  put the precise angle's tangent in a tangent called actual.
  stash the fuzzy test given the actual.

to test (trig - tangent of 90°):
  make a fuzzy test about "trig" and "tangent of 90°" 
    and targeting the largest number / 1 with tight tolerance.
  make a precise angle given 90.
  put the precise angle's tangent in a tangent called actual.
  stash the fuzzy test given the actual.

to test (trig - tangent of pi/4 radians):
  make a fuzzy test about "trig" and "sine of pi/4 radians" 
    and targeting 1/1 with tight tolerance.
  put tau in some radians.
  divide the radians by 8.
  put the radians' tangent in a tangent called actual.
  stash the fuzzy test given the actual.

to test (trig - tangent):
  test (trig - tangent of -240°).
  test (trig - tangent of 0°).
  test (trig - tangent of 30°).
  test (trig - tangent of 41°15’).
  test (trig - tangent of 45°).
  test (trig - tangent of pi/4 radians).
  test (trig - tangent of 90°).
  test (trig - tangent of -90°).
  test (trig - tangent of 360°).

to test (trig - wrap -1 between 0 and 99):
  create a test result about "trig"
    and "wrap -1 between 0 and 99"
    and expecting "99".
  put -1 in a number called actual.
  wrap the actual given 0 and 99.
  stash the test result using the actual.

to test (trig - wrap):
  test (trig - -1 is not wrapped between 0 and 99).
  test (trig - wrap -1 between 0 and 99).

to test (trig):
  test (trig - wrap).
  test (trig - normalize precise angle).
  test (trig - convert mixio to string).
  test (trig - normalize radians).
  test (trig - multiply mixios).
  test (trig - convert from degrees to radians).
  test (trig - convert from radians to degrees).
  test (trig - sine).
  test (trig - cosine).
  test (trig - tangent).
  test (trig - arcsine).
  test (trig - arccosine).
  test (trig - arctangent).
  test (trig - mixio / 388800).
  test (mixio square root).

the trifle denominator is a number equal to 1866240000. \ 43,200 * 43,200

the trifle root is 43200.

some trifles are a number. \ divided by trifle denominator.

to wrap a number given a number called alpha and a number called omega:
  wrap the number given the alpha and the omega and 0.

to wrap a number given a number called alpha and a number called omega and another number:
  if the number is wrapped given the alpha and the omega, exit.
  if the alpha is the omega,
    put the alpha in the number; exit.
  put the omega minus the alpha in a number called period.
  add 1 to the period.
  put the number minus the alpha in a number called shifted.
  if the shifted is the smallest number,
    add the period to the shifted;
    subtract 1 from the other number.
  if the shifted is at least 0,
    divide the shifted by the period giving a quotient and a remainder;
    add the quotient to the other number;
    add the alpha to the remainder;
    put the remainder in the number;
    exit.
  negate the shifted.
  divide the shifted by the period giving the quotient and the remainder.
  negate the quotient.
  negate the remainder.
  if the remainder is 0,
    add the quotient to the other number;
    put the remainder in the number; exit.
  add the period to the remainder.
  subtract 1 from the quotient.
  add the quotient to the other number.
  put the remainder in the number.
